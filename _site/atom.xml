<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Jeremy Wei</title>
 <link href="http://weizhifeng.net/atom.xml" rel="self"/>
 <link href="http://weizhifeng.net/"/>
 <updated>2013-08-01T16:56:24+08:00</updated>
 <id>http://weizhifeng.net/</id>
 <author>
   <name>Jeremy Wei</name>
   <email>shuimuqingshu@gmail.com</email>
 </author>

 
 <entry>
   <title>两个viewport的故事（第一部分）</title>
   <link href="http://weizhifeng.net/viewports.html"/>
   <updated>2013-07-21T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/viewports</id>
   <content type="html">&lt;p&gt;原文：&lt;a href=&quot;http://www.quirksmode.org/mobile/viewports.html&quot;&gt;http://www.quirksmode.org/mobile/viewports.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在这个迷你系列的文章里边我将会解释viewport，以及许多重要元素的宽度是如何工作的，比如&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;元素，也包括窗口和屏幕。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这篇文章是关于桌面浏览器的，其唯一的目的就是为移动浏览器中相似的讨论做个铺垫。大部分开发者凭直觉已经明白了大部分桌面浏览器中的概念。在移动端我们将会接触到相同的概念，但是会更加复杂，所以对大家已经知道的术语做个提前的讨论将会对你理解移动浏览器产生巨大的帮助。&lt;/p&gt;

&lt;h1&gt;概念：设备像素和CSS像素&lt;/h1&gt;

&lt;p&gt;你需要明白的第一个概念是CSS像素，以及它和设备像素的区别。&lt;/p&gt;

&lt;p&gt;设备像素是我们直觉上觉得「靠谱」的像素。这些像素为你所使用的各种设备都提供了正规的分辨率，并且其值可以（通常情况下）从&lt;code&gt;screen.width/height&lt;/code&gt;属性中读出。&lt;/p&gt;

&lt;p&gt;如果你给一个元素设置了&lt;code&gt;width: 128px&lt;/code&gt;的属性，并且你的显示器是1024px宽，当你最大化你的浏览器屏幕，这个元素将会在你的显示器上重复显示8次（大概是这样；我们先忽略那些微妙的地方）。&lt;/p&gt;

&lt;p&gt;如果用户进行缩放，那么计算方式将会发生变化。如果用户放大到200%，那么你的那个拥有&lt;code&gt;width: 128px&lt;/code&gt;属性的元素在1024px宽的显示器上只会重复显示4次。&lt;/p&gt;

&lt;p&gt;现代浏览器中实现缩放的方式无怪乎都是「拉伸」像素。所以，元素的宽度并没有从128个像素被修改为256个像素；相反是&lt;strong&gt;实际像素&lt;/strong&gt;被放大了两倍。形式上，元素仍然是128个CSS像素宽，即使它占据了256个设备像素的空间。&lt;/p&gt;

&lt;p&gt;换句话说，放大到200%使一个CSS像素变成为一个设备像素的四倍。（宽度2倍，高度2倍，总共4倍）&lt;/p&gt;

&lt;p&gt;一些配图可以解释清楚这个概念。这儿有四个100%缩放比的元素。这儿没有什么值得看的；CSS像素与设备像素完全重叠。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/viewport/csspixels_100.gif&quot; alt=&quot;csspixels_100&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在让我们缩小。CSS像素开始收缩，这意味着现在一个设备像素覆盖了多个CSS像素。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/viewport/csspixels_out.gif&quot; alt=&quot;csspixels_out&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果你进行放大，相反的行为会发生。CSS像素开始变大，现在一个CSS像素覆盖了多个设备像素。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/viewport/csspixels_in.gif&quot; alt=&quot;csspixels_in&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这儿的要点是你只对CSS像素感兴趣。这些就是那些控制你的样式表如何被渲染的像素。&lt;/p&gt;

&lt;p&gt;设备像素对你（译者：指的是开发者）来说基本上没用。但是对于用户不一样；用户将会放大或者缩小页面直到他能舒服的阅读为止。无论怎样，缩放比例对你不会产生影响。浏览器将会自动的使你的CSS布局被拉伸或者被压缩。&lt;/p&gt;

&lt;h1&gt;100%缩放&lt;/h1&gt;

&lt;p&gt;我是以假设缩放比例为100%来开始这个例子的。是时候需要更加严格的来定义一下这个100%了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;在缩放比例100%的情况下一个CSS像素完全等于一个设备像素。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;100%缩放的概念在接下来的解释中会非常有用，但是在你的日常工作中你不用过分的担心它。在桌面环境上你将会在100%缩放比例的情况下测试你的站点，但即使用户放大或者缩小，CSS像素的魔力将会保证你的布局保持相同的比率。&lt;/p&gt;

&lt;h1&gt;屏幕尺寸&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;screen.width/height&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;_意义：用户屏幕的整体大小。_&lt;/li&gt;
&lt;li&gt;_度量单位：设备像素。_&lt;/li&gt;
&lt;li&gt;_浏览器错误：IE8以CSS像素对其进行度量，IE7和IE8模式下都有这个问题。_&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;让我们看一些实用的度量。我们将会以&lt;code&gt;screen.width&lt;/code&gt;和&lt;code&gt;screen.height&lt;/code&gt;做为开始。它们包括用户屏幕的整个宽度和高度。它们的尺寸是以设备像素来进行度量的，因为它们永远不会变：它们是显示器的属性，而不是浏览器的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/viewport/desktop_screen.jpg&quot; alt=&quot;desktop_screen&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fun! 但是这些信息跟对我们有什么用呢？&lt;/p&gt;

&lt;p&gt;基本上没用。用户的显示器尺寸对于我们来说不重要－好吧，除非你想度量它来丰富你的web统计数据库。&lt;/p&gt;

&lt;h1&gt;窗口尺寸&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;window.innerWidth/Height&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;_意义：浏览器窗口的整体大小，包括滚动条。_&lt;/li&gt;
&lt;li&gt;_度量单位：CSS像素。_&lt;/li&gt;
&lt;li&gt;_浏览器错误：IE7不支持。Opera以设备像素进行度量。_&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;相反，你想知道的是浏览器窗口的内部尺寸。它告诉了你用户到底有多少空间可以用来做CSS布局。你可以通过&lt;code&gt;window.innerWidth&lt;/code&gt;和&lt;code&gt;window.innerHeight&lt;/code&gt;来获取这些尺寸。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/viewport/desktop_inner.jpg&quot; alt=&quot;desktop_inner&quot; /&gt;&lt;/p&gt;

&lt;p&gt;很显然，窗口的内部宽度是以CSS像素进行度量的。你需要知道你的布局空间中有多少可以挤进浏览器窗口，当用户放大的时候这个数值会减少。所以如果用户进行放大操作，那么在窗口中你能获取的空间将会变少，&lt;code&gt;window.innerWidth/Height&lt;/code&gt;的值也变小了。
（这儿的例外是Opera，当用户放大的时候&lt;code&gt;window.innerWidth/Height&lt;/code&gt;并没有减少：它们是以设备像素进行度量的。这个问题在桌面上是比较烦人的，但是就像我们将要看到的，这在移动设备上却是非常严重的。）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/viewport/desktop_inner_zoomed.jpg&quot; alt=&quot;desktop_inner_zoomed&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意度量的宽度和高度是包括滚动条的。它们也被视为内部窗口的一部分。（这大部分是因为历史原因造成的。）&lt;/p&gt;

&lt;h1&gt;滚动距离&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;window.pageX/YOffset&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;_意义：页面滚动的距离。_&lt;/li&gt;
&lt;li&gt;_度量单位：CSS像素。_&lt;/li&gt;
&lt;li&gt;_浏览器错误：无。_&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;code&gt;window.pageXOffset&lt;/code&gt;和&lt;code&gt;window.pageYOffset&lt;/code&gt;，包含了文档水平和垂直方向的滚动距离。所以你可以知道用户已经滚动了多少距离。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/viewport/desktop_page.jpg&quot; alt=&quot;desktop_page&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这些属性也是以CSS像素进行度量的。你想知道的是文档已经被滚动了多长距离，不管它是放大还是缩小的状态。&lt;/p&gt;

&lt;p&gt;理论上，如果用户向上滚动，然后放大，&lt;code&gt;window.pageX/YOffset&lt;/code&gt;将会发生变化。但是，浏览器为了想保持web页面的连贯，会在用户缩放的时候保持相同的元素位于可见页面的顶部。这个机制并不能一直很完美的执行，但是它意味着在实际情况下&lt;code&gt;window.pageX/YOffset&lt;/code&gt;并没有真正的更改：被滚动出窗口的CSS像素的数量仍然（大概）是相同的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/viewport/desktop_page_zoomed.jpg&quot; alt=&quot;desktop_page_zoomed&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;概念：viewport&lt;/h1&gt;

&lt;p&gt;在我们继续介绍更多的JavaScript属性之前，我们必须介绍另一个概念：viewport。&lt;/p&gt;

&lt;p&gt;viewport的功能是用来约束你网站中最顶级包含块元素（containing block）&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;的。&lt;/p&gt;

&lt;p&gt;这听起来有一点模糊，所以看一个实际的例子。假设你有一个流式布局，并且你众多边栏中的一个具有&lt;code&gt;width: 10%&lt;/code&gt;属性。现在这个边栏会随着浏览器窗口大小的调整而恰好的放大和收缩。但是这到底是如何工作的呢？&lt;/p&gt;

&lt;p&gt;从技术上来说，发生的事情是边栏获取了它父元素宽度的10%。比方说是&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;元素（并且你还没有给它设置过&lt;code&gt;宽度&lt;/code&gt;）。所以问题就变成了&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;的宽度是哪个？&lt;/p&gt;

&lt;p&gt;普通情况下，所有块级元素使用它们父元素宽度的100%（这儿有一些例外，但是让我们现在先忽略它）。所以&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;元素和它的父元素&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;一样宽。&lt;/p&gt;

&lt;p&gt;那么&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;元素的宽度是多少？它的宽度和浏览器窗口宽度一样。这就是为什么你的那个拥有&lt;code&gt;width: 10%&lt;/code&gt;属性的侧边栏会占据整个浏览器窗口的10%。所有web开发者都很直观的知道并且在使用它。&lt;/p&gt;

&lt;p&gt;你可能不知道的是这个行为在理论上是如何工作的。理论上，&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;元素的宽度是被viewport的宽度所限制的。&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;元素使用viewport宽度的100%。&lt;/p&gt;

&lt;p&gt;viewport，接着，实际上等于浏览器窗口：它就是那么定义的。viewport不是一个HTML结构，所以你不能用CSS来改变它。它在桌面环境下只是拥有浏览器窗口的宽度和高度。在移动环境下它会有一些复杂。&lt;/p&gt;

&lt;h1&gt;后果　Consequences&lt;/h1&gt;

&lt;p&gt;这个状况会有产生一些异样的后果。你可以在这个站点看到这些后果中的一个。滚动到顶部，然后放大两次或者三次，之后这个站点的内容就从浏览器窗口溢出了。&lt;/p&gt;

&lt;p&gt;现在滚动到右边，然后你将会看见站点顶部的蓝色边栏不再覆盖一整行了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/viewport/desktop_htmlbehaviour.jpg&quot; alt=&quot;desktop_htmlbehaviour&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个行为是由于viewport的定义方式而产生的一个后果。我之前给顶部的蓝色边栏设置了&lt;code&gt;width: 100%&lt;/code&gt;。什么的100%？&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;元素的100%，它的宽度和viewport是一样的，viewport的宽度是和浏览器窗口一样的。&lt;/p&gt;

&lt;p&gt;问题是：在100%缩放的情况下这个工作的很好，现在我们进行了放大操作，viewport变得比我的站点的总体宽度要小。这对于viewport它本身来说没什么影响，内容现在从&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;元素中溢出了，但是那个元素拥有&lt;code&gt;overflow: visible&lt;/code&gt;，这意味着溢出的内容在任何情况下都将会被显示出来。&lt;/p&gt;

&lt;p&gt;但是蓝色边栏并没有溢出。我之前给它设置了&lt;code&gt;width: 100%&lt;/code&gt;，并且浏览器把viewport的宽度赋给了它。它们根本就不在乎现在宽度实在是太窄了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/viewport/desktop_100percent.jpg&quot; alt=&quot;desktop_100percent&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;文档宽度？&lt;/h1&gt;

&lt;p&gt;我真正需要知道的是页面中全部内容的宽度是多少，包括那些「伸出」的部分。据我所知得到这个值是不可能的（好吧，除非你去计算页面上所有元素的宽度和边距，但是委婉的说，这是容易出错的）。&lt;/p&gt;

&lt;p&gt;我开始相信我们需要一个我称其为「文档宽度」(document width，很显然用CSS像素进行度量)的JavaScript属性对。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/viewport/desktop_documentwidth.jpg&quot; alt=&quot;desktop_documentwidth&quot; /&gt;&lt;/p&gt;

&lt;p&gt;并且如果我们真的如此时髦，为什么不把这个值引入到CSS中？我将会给我的蓝色边栏设置&lt;code&gt;width: 100%&lt;/code&gt;，此值基于文档宽度，而不是&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;元素的宽度。（但是这个很复杂，并且如果不能实现我也不会感到惊讶。）&lt;/p&gt;

&lt;p&gt;浏览器厂商们，你们怎么认为的？&lt;/p&gt;

&lt;h1&gt;度量viewport&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;document.documentElement.clientWidth/Height&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;_意义：Viewport尺寸。_&lt;/li&gt;
&lt;li&gt;_度量单位：CSS像素。_&lt;/li&gt;
&lt;li&gt;_浏览器错误：无。_&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;你可能想知道viewport的尺寸。它们可以通过&lt;code&gt;document.documentElement.clientWidth&lt;/code&gt;和&lt;code&gt;-Height&lt;/code&gt;得到。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/viewport/desktop_client.jpg&quot; alt=&quot;desktop_client&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果你了解DOM，你应该知道&lt;code&gt;document.documentElement&lt;/code&gt;实际上指的是&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;元素：即任何HTML文档的根元素。可以说，viewport要比它更高一层；它是包含&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;元素的元素。如果你给&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;元素设置&lt;code&gt;width&lt;/code&gt;属性，那么这将会产生影响。（我不推荐这么做，但是那是可行的。）&lt;/p&gt;

&lt;p&gt;在那种情况下&lt;code&gt;document.documentElement.clientWidth&lt;/code&gt;和&lt;code&gt;-Height&lt;/code&gt;给出的仍然是viewport的尺寸，而不是&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;元素的。（这是一个特殊的规则，只对这个元素的这个属性对产生作用。在任何其他的情况下，使用的是元素的实际宽度。）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/viewport/desktop_client_smallpage.jpg&quot; alt=&quot;desktop_client_smallpage&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所以&lt;code&gt;document.documentElement.clientWidth&lt;/code&gt;和&lt;code&gt;-Height&lt;/code&gt;一直代表的是viewport的尺寸，不管&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;元素的尺寸是多少。&lt;/p&gt;

&lt;h1&gt;两个属性对&lt;/h1&gt;

&lt;p&gt;但是难道viewport宽度的尺寸也可以通过&lt;code&gt;window.innerWidth/Height&lt;/code&gt;来提供吗？怎么说呢，模棱两可。&lt;/p&gt;

&lt;p&gt;两个属性对之间存在着正式区别：&lt;code&gt;document.documentElement.clientWidth&lt;/code&gt;和&lt;code&gt;-Height&lt;/code&gt;并不包含滚动条，但是&lt;code&gt;window.innerWidth/Height&lt;/code&gt;包含。这像是鸡蛋里挑骨头。&lt;/p&gt;

&lt;p&gt;事实上两个属性对的存在是浏览器战争的产物。当时Netscape只支持&lt;code&gt;window.innerWidth/Height&lt;/code&gt;，IE只支持&lt;code&gt;document.documentElement.clientWidth&lt;/code&gt;和&lt;code&gt;Height&lt;/code&gt;。从那时起所有其他浏览器开始支持&lt;code&gt;clientWidth/Height&lt;/code&gt;，但是IE没有支持&lt;code&gt;window.innerWidth/Height&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在桌面环境上拥有两个属性对是有一些累赘的　－　但是就像我们将要看到的，在移动端这将会得到祝福。&lt;/p&gt;

&lt;h1&gt;度量\&amp;lt;html&gt;元素&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;document.documentElement.offsetWidth/Height&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;_意义：&lt;html&gt;元素（也就是页面）的尺寸。_&lt;/li&gt;
&lt;li&gt;_度量单位：CSS像素。_&lt;/li&gt;
&lt;li&gt;_浏览器错误：IE度量的是viewport，而不是&lt;html&gt;元素。_&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;所以&lt;code&gt;clientWidth/Height&lt;/code&gt;在所有情况下都提供viewport的尺寸。但是我们去哪里获取&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;元素本身的尺寸呢？它们存储在&lt;code&gt;document.documentElement.offsetWidth&lt;/code&gt;和&lt;code&gt;-Height&lt;/code&gt;之中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/viewport/desktop_offset.jpg&quot; alt=&quot;desktop_offset&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这些属性可以使你以块级元素的形式访问&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;元素；如果你设置&lt;code&gt;width&lt;/code&gt;，那么&lt;code&gt;offsetWidth&lt;/code&gt;将会表示它。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/viewport/desktop_offset_smallpage.jpg&quot; alt=&quot;desktop_offset_smallpage&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;事件中的坐标&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;pageX/Y, clientX/Y, screenX/Y&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;_意义：见正文。_&lt;/li&gt;
&lt;li&gt;_度量单位：见正文。_&lt;/li&gt;
&lt;li&gt;_浏览器错误：IE不支持pageX/Y。IE和Opera以CSS像素为单位计算screenX/Y。_&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;然后是事件中的坐标。当一个鼠标事件发生时，有不少于五种属性对可以给你提供关于事件位置的信息。对于我们当前的讨论来说它们当中的三种是重要的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pageX/Y&lt;/code&gt;提供了相对于&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;元素的以CSS像素度量的坐标。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/viewport/desktop_pageXY.jpg&quot; alt=&quot;desktop_pageXY&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;clientX/Y&lt;/code&gt;提供了相对于viewport的以CSS像素度量的坐标。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/viewport/desktop_clientXY.jpg&quot; alt=&quot;desktop_clientXY&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;screenX/Y&lt;/code&gt;提供了相对于屏幕的以设备像素进行度量的坐标。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/viewport/desktop_screenXY.jpg&quot; alt=&quot;desktop_screenXY&quot; /&gt;&lt;/p&gt;

&lt;p&gt;90%的时间你将会使用&lt;code&gt;pageX/Y&lt;/code&gt;；通常情况下你想知道的是相对于文档的事件坐标。其他的10%时间你将会使用&lt;code&gt;clientX/Y&lt;/code&gt;。你永远不需要知道事件相对于屏幕的坐标。&lt;/p&gt;

&lt;h1&gt;媒体查询&lt;/h1&gt;

&lt;p&gt;_媒体查询_&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;意义：见正文。&lt;/li&gt;
&lt;li&gt;度量单位：见正文。&lt;/li&gt;
&lt;li&gt;浏览器错误：IE不支持它们。

&lt;ul&gt;
&lt;li&gt;如果 &lt;code&gt;device-width/height&lt;/code&gt;是以CSS像素进行度量的，那么Firefox将会使用&lt;code&gt;screen.width/height&lt;/code&gt;的值。&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;width/height&lt;/code&gt;是以设备像素进行度量的，那么Safari和Chrome将会使用&lt;code&gt;documentElement.clientWidth/Height&lt;/code&gt;的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;最后，说说关于媒体查询的事。原理很简单：你可以声明「只在页面宽度大于，等于或者小于一个特定尺寸的时候才会被执行」的特殊的CSS规则。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;div.sidebar {
    width: 300px;
}

@media all and (max-width: 400px) {
    // styles assigned when width is smaller than 400px;
    div.sidebar {
        width: 100px;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当前sidebar是300px宽，除了当宽度小于400px的时候，在那种情况下sidebar变得100px宽。&lt;/p&gt;

&lt;p&gt;问题很显然：我们这儿度量的是哪个宽度？&lt;/p&gt;

&lt;p&gt;这儿有两个对应的媒体查询：&lt;code&gt;width/height&lt;/code&gt;和&lt;code&gt;device-width/device-height&lt;/code&gt;。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;width/height&lt;/code&gt;使用和&lt;code&gt;documentElement .clientWidth/Height&lt;/code&gt;（换句话说就是viewport宽高）一样的值。它是工作在CSS像素下的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;device-width/device-height&lt;/code&gt;使用和&lt;code&gt;screen.width/height&lt;/code&gt;（换句话说就是屏幕的宽高）一样的值。它工作在设备像素下面。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/viewport/desktop_mediaqueries.jpg&quot; alt=&quot;desktop_mediaqueries&quot; /&gt;&lt;/p&gt;

&lt;p&gt;你应该使用哪个？这还用想？当然是&lt;code&gt;width&lt;/code&gt;。Web开发者对设备宽度不感兴趣；这个是浏览器窗口的宽度。&lt;/p&gt;

&lt;p&gt;所以在桌面环境下去使用&lt;code&gt;width&lt;/code&gt;而去忘记&lt;code&gt;device-width&lt;/code&gt;吧。我们即将看到这个情况在移动端会更加麻烦。&lt;/p&gt;

&lt;h1&gt;总结&lt;/h1&gt;

&lt;p&gt;本文总结了我们对桌面浏览器行为的探寻。&lt;a href=&quot;http://www.quirksmode.org/mobile/viewports2.html&quot;&gt;这个系列的第二部分&lt;/a&gt;把这些概念指向了移动端，并显示的指出了与桌面环境上的一些重要区别。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>不是像素的像素不是像素</title>
   <link href="http://weizhifeng.net/a-pixel-is-not.html"/>
   <updated>2013-07-14T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/a-pixel-is-not</id>
   <content type="html">&lt;p&gt;原文：&lt;a href=&quot;http://www.quirksmode.org/blog/archives/2010/04/a_pixel_is_not.html&quot;&gt;http://www.quirksmode.org/blog/archives/2010/04/a_pixel_is_not.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;译者：看标题晕菜了吧？哈哈。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;昨天（译者：原文成于2010年4月）&lt;a href=&quot;http://daringfireball.net/2010/04/why_960_by_640&quot;&gt;John Gruber说了一下&lt;/a&gt;关于新iPhone提高像素密度的事情（以960x640替代480x320），并且分析了苹果为什么这么做。他也预测了这对于web开发者来说意味着是什么。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我现在刚好对移动电话上的浏览器宽度和高度进行深入研究，所以我可以很有把握的说这些变化中的99%不会对web开发者产生任何影响。&lt;/p&gt;

&lt;p&gt;剩下的1%可能会有一些诡异，但是我期望苹果将会引入一个像素中间层，以此来解决这个问题。（后来&lt;a href=&quot;http://daringfireball.net/linked/2010/04/19/android-dips&quot;&gt;John指出&lt;/a&gt;Android平台上已经存在了类似的中间层。）&lt;/p&gt;

&lt;p&gt;在我们开始之前提前声明：因为它们对于web开发者来说并不重要，所以我几乎忽略了正规的屏幕尺寸，并且我也没有真正的讨论显示器的原理，像素密度，以及其他复杂概念。
提前对我可能在这使用的错误术语表示歉意。&lt;/p&gt;

&lt;h1&gt;web开发者需要什么&lt;/h1&gt;

&lt;p&gt;我很确定web开发者到底对什么感兴趣。他们需要的是CSS像素。是的，就是在CSS的声明比如&lt;code&gt;width: 300px&lt;/code&gt;或者&lt;code&gt;font-size: 14px&lt;/code&gt;中使用的「像素」。&lt;/p&gt;

&lt;p&gt;这些像素跟设备的实际像素密度甚至是传闻中将会到来的中间层没有任何关系。它们本质上是为我们web开发者创建的一个抽象结构。&lt;/p&gt;

&lt;p&gt;解释它最简单的方式就是想想缩放。如果用户进行放大操作，一个拥有&lt;code&gt;width: 300px&lt;/code&gt;的元素将会占有屏幕越来越多的空间，以设备（物理）像素进行度量的话就会变得越来越宽。但对于CSS像素来说，无论怎样，宽度还是300px，缩放效果是通过尽可能的对CSS像素进行拉伸来实现的。&lt;/p&gt;

&lt;p&gt;当缩放比例正好为100%的时候，一个CSS像素等于一个设备像素（尽管将要到来的中间层将会替换这儿的设备像素。）下图描绘了这个情形。这儿看不到更多的像素，因为一个CSS像素完全覆盖了一个设备像素。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/a-pixel-is-not/csspixels_100.gif&quot; alt=&quot;csspixels_100&quot; /&gt;&lt;/p&gt;

&lt;p&gt;（_我应该适当告诉你们一下“zoom 100%”在web开发中几乎没有意义。缩放等级对于我们来说并不重要；我们需要知道的是屏幕上现在有多少个CSS像素。_）&lt;/p&gt;

&lt;p&gt;接下来的两幅图说明了当用户缩放的时候会发生什么。第一幅图展示的是当用户进行缩小操作的时候设备像素（深蓝色背景）和CSS像素（半透明前景）的样子。CSS像素变得小了；一个设备像素覆盖了多个CSS像素。第二幅图展示的当用户进行放大操作时候设备像素和CSS像素的样子。一个CSS像素现在覆盖了多个设备像素。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/a-pixel-is-not/csspixels_out.gif&quot; alt=&quot;csspixels_out&quot; /&gt;
&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/a-pixel-is-not/csspixels_in.gif&quot; alt=&quot;csspixels_in&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所以我们那些拥有&lt;code&gt;width: 300px&lt;/code&gt;的元素实际上一直是300个CSS像素宽，而且一个CSS像素等于多少个设备像素是根据当前的缩放比例来决定的。
（你可以在iPhone上用&lt;code&gt;screen.width&lt;/code&gt;除以&lt;code&gt;window.innerWidth&lt;/code&gt;来计算出缩放比例。在这方面浏览器普遍不兼容；期望在不远的未来会有一个完整的报告。并且，做为一个web开发者你对缩放比例没有兴趣，但是对设备屏幕上有多少个像素（设备像素或者CSS像素）感兴趣。）&lt;/p&gt;

&lt;p&gt;这个体系将不会发生变化。如果变了的话，所有针对iPhone进行过优化的站点将会立刻变得严重错乱，但这正是苹果不惜一切代价想避免的。&lt;/p&gt;

&lt;p&gt;所以，一个完全缩小的网站将会仍然以980个CSS像素的形式进行展示，一个CSS像素等于多少个设备像素对于我们来说不重要。&lt;/p&gt;

&lt;h1&gt;有点棘手&lt;/h1&gt;

&lt;p&gt;无论怎样，这儿有两个棘手的地方（tricky bits）：&lt;code&gt;device-width&lt;/code&gt;媒体查询（media query）和&lt;code&gt;&amp;lt;meta name=&quot;viewport&quot; width=&quot;device-width&quot;&amp;gt;&lt;/code&gt;标签。两个都是工作在设备像素下，而不是CSS像素，因为他们是基于web页面的环境，而不是基于设备内部的CSS运行机制。&lt;/p&gt;

&lt;h2&gt;媒体查询&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;device-width&lt;/code&gt;媒体查询以设备像素为单位对设备的宽度进行度量。&lt;code&gt;width&lt;/code&gt;媒体查询以CSS像素的形式对页面的整体宽度进行度量，iPhone上其值至少为980px，原因我接下来解释。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/a-pixel-is-not/mobile_mediaqueries.jpg&quot; alt=&quot;mobile_mediaqueries&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;device-width&lt;/code&gt;媒体查询按照如下形式工作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;div.sidebar {
    width: 300px;
}

@media all and (max-device-width: 320px) {
    // styles assigned when device width is smaller than 320px;
    div.sidebar {
        width: 100px;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在sidebar是300个CSS像素宽，除了当设备宽度等于320设备像素或者小于320设备像素，在这种情况下sidebar将会变成100个CSS像素宽。（跟的上吗？这个有点复杂。）&lt;/p&gt;

&lt;p&gt;顺便说下，理论上你可以使用以厘米或者英寸为单位的媒体查询对设备屏幕进行查询。不幸的是这个好像并没有被所有的设备所完全支持，甚至iPhone也是。问题在于物理单位比如英寸经常是被转换成（CSS）像素；因此&lt;code&gt;width: 1in&lt;/code&gt;在我所测试过的浏览器上等于96个像素（这相当多）。所以这些媒体查询不可靠。&lt;/p&gt;

&lt;h1&gt;\&amp;lt;meta&gt;标签&lt;/h1&gt;

&lt;p&gt;通常情况下&lt;code&gt;&amp;lt;meta name=&quot;viewport&quot; width=&quot;device-width&quot;&amp;gt;&lt;/code&gt;甚至更有用。这个标签，最早是苹果特有的，但同时也被更多的移动浏览器所支持，使布局视窗（layout　viewport）完全地对设备进行适配。&lt;/p&gt;

&lt;p&gt;什么是布局视窗？它是浏览器用来计算拥有百分比宽度，比如&lt;code&gt;div.sidebar {width: 20%}&lt;/code&gt;的元素尺寸的区域。通常情况它要比设备屏幕稍微大一些：iPhone上为980px，Opera上为850px，Android上为800，等等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/a-pixel-is-not/mobile_layoutviewport.jpg&quot; alt=&quot;mobile_layoutviewport&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果你添加&lt;code&gt;&amp;lt;meta name=&quot;viewport&quot; width=&quot;device-width&quot;&amp;gt;&lt;/code&gt;，那么布局视窗的宽度会被限制为以设备像素为单位的设备的宽度；在iPhone的情况下为320。&lt;/p&gt;

&lt;p&gt;如果你的页面能够在屏幕中挤下的话那么这将会产生影响。看下这个没有任何CSS&lt;code&gt;width&lt;/code&gt;语句，并且没有&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;标签的页面。它充分利用了整个布局视窗可用宽度。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/a-pixel-is-not/mq_none.jpg&quot; alt=&quot;mq_none&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这可能不是你想要的。你想要文本漂亮的显示在屏幕上。那是&lt;code&gt;&amp;lt;meta name=&quot;viewport&quot; width=&quot;device-width&quot;&amp;gt;&lt;/code&gt;的任务。当你添加它的时候，布局视窗会被收缩（为320px在iPhone的情况下），然后文字大小就合适了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/a-pixel-is-not/mq_yes.jpg&quot; alt=&quot;mq_yes&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;苹果做的改变&lt;/h1&gt;

&lt;p&gt;苹果的分辨率改变了之后对&lt;code&gt;device-width&lt;/code&gt;媒体查询和&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;标签会产生什么影响？当然我不能很确定，但是我期望对于web开发者来说什么都没有变化。&lt;/p&gt;

&lt;h2&gt;\&amp;lt;meta&gt; 标签&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;标签是最容易解释的。苹果故意发明它恰恰就是为了能使开发者在iPhone屏幕上适配他们的内容，并且已经把它推送给了开发者。这意味着现在它承受不起像读取设备宽度那样通过&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;标签去修改设备的宽度。&lt;/p&gt;

&lt;p&gt;事实上，Nexus One已经开始追随苹果了。它的官方屏幕宽度（肖像模式，即竖排模式）是480px，但是当你应用了&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;标签，它表现出的屏幕宽度是320px，即官方宽度的三分之二。&lt;/p&gt;

&lt;p&gt;如果我理解的正确，这就是当John Gruber在&lt;a href=&quot;http://daringfireball.net/linked/2010/04/19/android-dips&quot;&gt;谈论&lt;/a&gt; Nexus的显示器和它丢失的一个子像素（sub-pixel），以及因此而少了三分之一像素时候所描述的情况。那刚好与Nexus对&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;标签的解释相吻合。&lt;/p&gt;

&lt;p&gt;所以事实上Google已经插入了一个似乎叫dips；&lt;a href=&quot;http://developer.android.com/guide/practices/screens_support.html&quot;&gt;设备无关像素&lt;/a&gt;（device-independent pixels，译者注：应该为density-independent pixel，「密度无关像素」）的层。这个层位于官方屏幕尺寸与web开发者所用的CSS像素之间。&lt;/p&gt;

&lt;p&gt;我期望当新的iPhone使用&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;标签进行查询的时候，可以复制Nexus的技巧，并声明屏幕大小为320px（换句话说是正常分辨率的一半）。之所以是一半而不是三分之二是因为新iPhone的像素密度比Nexus高（或者其他）。&lt;/p&gt;

&lt;h2&gt;媒体查询&lt;/h2&gt;

&lt;p&gt;现在只留下&lt;code&gt;device-width&lt;/code&gt;媒体查询这一个唯一的问题了。Nexus使用&lt;code&gt;480px&lt;/code&gt;做为屏幕宽度，尽管事实上在这320px更合适。我们不得不看看苹果是怎么做的。&lt;/p&gt;

&lt;p&gt;更重要的问题是dips是否也将被用在媒体查询中。总的看来我想说我们需要它；正规的设备尺寸对于web开发者来说并不重要：我们想知道我们可以在屏幕上得到多少内容，从这看来dips是最合适的。&lt;/p&gt;

&lt;p&gt;不幸的是Nexus还没有这么做；所有跟媒体查询有关的&lt;code&gt;device-width&lt;/code&gt;仍然是480px，并不是&lt;code&gt;320px&lt;/code&gt;。但是也许苹果能够为web开发者解决这个问题。&lt;/p&gt;

&lt;p&gt;所以情况对于普通网站和那些使用&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;标签的网站来说很清晰；对于使用媒体查询的网站来说没那么清晰。&lt;/p&gt;

&lt;p&gt;敬请期待。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>把你的网站改造成一个iOS Web App</title>
   <link href="http://weizhifeng.net/make-web-app-more-native.html"/>
   <updated>2013-07-06T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/make-web-app-more-native</id>
   <content type="html">&lt;h1&gt;前言&lt;/h1&gt;

&lt;p&gt;iOS上的一个Web App（下图中的「念」）和Native App(原生应用)在外观上看起来基本上一样，但是其使用的技术是HTML，CSS，Javascript，而不是原生应用所使用的Objective-C。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/web-app/01.jpg&quot; title=&quot;01&quot; alt=&quot;01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;本文简单介绍一下如何把一个Web站点改造成iOS上的Web App，这里假设你的网站是响应式设计（responsive design）或者已经做过移动端的适配。&lt;/p&gt;

&lt;h1&gt;viewport&lt;/h1&gt;

&lt;p&gt;我们在HTML中加上viewport(这里假设用户已经对viewport有所了解)　meta标签：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;width=device-width&lt;/code&gt;指的是移动浏览器所显示的宽度等于设备的物理宽度，&lt;code&gt;initial-scale=1.0&lt;/code&gt;指的是初始缩放倍数为1.0(即不缩放)，&lt;code&gt;maximum-scale=1.0&lt;/code&gt;指的是最大的缩放倍数是1.0，&lt;code&gt;user-scalable=no&lt;/code&gt;指用户不可以手动进行缩放。这些参数请根据自己的情况进行调整。本站调整完成后，效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/web-app/02.jpg&quot; title=&quot;02&quot; alt=&quot;02&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;Icon&lt;/h1&gt;

&lt;p&gt;当用户通过safari访问我们网站的时候，用户是可以把网站的URL以一个快捷方式的形式添加到主屏幕的，展示形式跟原生的应用是一样，所以我们要给我们的网站添加应用Icon。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/web-app/03.jpg&quot; title=&quot;03&quot; alt=&quot;03&quot; /&gt;&lt;/p&gt;

&lt;p&gt;iOS所用的icon是&lt;code&gt;png&lt;/code&gt;格式的，其提供了&lt;code&gt;apple-touch-icon&lt;/code&gt;和&lt;code&gt;apple-touch-icon-precomposed&lt;/code&gt;两种icon，使用方式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;link rel=&quot;apple-touch-icon&quot; href=&quot;/apple-touch-icon.png&quot;/&amp;gt;
&amp;lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;/apple-touch-icon-precomposed.png&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上你只能选其一，二者的区别在于如果使用&lt;code&gt;apple-touch-icon&lt;/code&gt;，那么iOS会给icon加上一些NB的效果，包括圆角，阴影，反光。如果使用&lt;code&gt;apple-touch-icon-precomposed&lt;/code&gt;则iOS不会加这个效果。&lt;/p&gt;

&lt;p&gt;如果你的网站也要可以在Ipad上访问，那么你还要针对不同的设备准备不同尺寸的icon，你可以通过&lt;code&gt;sizes&lt;/code&gt;属性来指定icon的尺寸：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;link rel=&quot;apple-touch-icon&quot; href=&quot;touch-icon-iphone.png&quot; /&amp;gt;
&amp;lt;link rel=&quot;apple-touch-icon&quot; sizes=&quot;72x72&quot; href=&quot;touch-icon-ipad.png&quot; /&amp;gt;
&amp;lt;link rel=&quot;apple-touch-icon&quot; sizes=&quot;114x114&quot; href=&quot;touch-icon-iphone-retina.png&quot; /&amp;gt;
&amp;lt;link rel=&quot;apple-touch-icon&quot; sizes=&quot;144x144&quot; href=&quot;touch-icon-ipad-retina.png&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你不指定&lt;code&gt;size&lt;/code&gt;属性，那么默认为&lt;code&gt;57x57&lt;/code&gt;，我们可以看到&lt;code&gt;ipad&lt;/code&gt;所需icon的尺寸是&lt;code&gt;72x72&lt;/code&gt;，&lt;code&gt;retina屏幕的iphone&lt;/code&gt;所需的尺寸是&lt;code&gt;114x114&lt;/code&gt;，&lt;code&gt;retina屏幕的ipad&lt;/code&gt;所需的尺寸是&lt;code&gt;144x144&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果没有当前设备所需尺寸的icon，那么iOS将会选用icon中所有大于此设备所需尺寸的最小的一个。如果没有比设备所需尺寸大的icon，那么选用最大的那个icon。如果有多个符合条件的icon，那么iOS会选择有&lt;code&gt;precomposed&lt;/code&gt;关键词的那个。&lt;/p&gt;

&lt;p&gt;如果在HTML中没有指定icon，那么iOS会到WEB根目录下寻找对应的icon。假设设备需要&lt;code&gt;57x57&lt;/code&gt;的icon，那么iOS将以下面的顺序进行访问：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;apple-touch-icon-57x57-precomposed.png&lt;/li&gt;
&lt;li&gt;apple-touch-icon-57x57.png&lt;/li&gt;
&lt;li&gt;apple-touch-icon-precomposed.png&lt;/li&gt;
&lt;li&gt;apple-touch-icon.png&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;启动界面&lt;/h1&gt;

&lt;p&gt;像原生应用一样，你也可以给Web App加上一个启动界面，很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;link rel=&quot;apple-touch-startup-image&quot; href=&quot;/startup.png&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;iPhone&lt;/code&gt;和&lt;code&gt;iPod touch&lt;/code&gt;上，尺寸大小必须为&lt;code&gt;320 x 460&lt;/code&gt;。&lt;/p&gt;

&lt;h1&gt;隐藏Safari用户栏&lt;/h1&gt;

&lt;p&gt;为了更加像原生应用，我们还可以对Safari的用户栏和地址栏进行隐藏，这个叫作&lt;code&gt;standalone&lt;/code&gt;模式，加入以下meta进入此模式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以通过&lt;code&gt;window.navigator.standalone&lt;/code&gt;来检测当前是否是&lt;code&gt;standalone&lt;/code&gt;模式。效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/web-app/04.jpg&quot; title=&quot;04&quot; alt=&quot;04&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;链接问题&lt;/h1&gt;

&lt;p&gt;在Safari中，如果点击一个链接，那么Safari将会打开一个新的tab，显然做为一个应用这体验简直太差了，需要在HTML中加入以下JavaScript来阻止此行为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&amp;gt;
// Mobile Safari in standalone mode
if((&quot;standalone&quot; in window.navigator) &amp;amp;&amp;amp; window.navigator.standalone){

    // If you want to prevent remote links in standalone web apps opening Mobile Safari, change 'remotes' to true
    var noddy, remotes = true;

    document.addEventListener('click', function(event) {

        noddy = event.target;

        // Bubble up until we hit link or top HTML element. Warning: BODY element is not compulsory so better to stop on HTML
        while(noddy.nodeName !== &quot;A&quot; &amp;amp;&amp;amp; noddy.nodeName !== &quot;HTML&quot;) {
            noddy = noddy.parentNode;
        }

        if('href' in noddy &amp;amp;&amp;amp; noddy.href.indexOf('http') !== -1 &amp;amp;&amp;amp; (noddy.href.indexOf(document.location.host) !== -1 || remotes))
        {
            event.preventDefault();
            document.location.href = noddy.href;
        }

    },false);
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码来自&lt;a href=&quot;https://gist.github.com/kylebarrow/1042026&quot;&gt;gist&lt;/a&gt;。&lt;/p&gt;

&lt;h1&gt;最后&lt;/h1&gt;

&lt;p&gt;Have fun　：）&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://developer.apple.com/library/ios/#documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html&quot;&gt;Configuring Web Applications&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://mathiasbynens.be/notes/touch-icons&quot;&gt;Everything you always wanted to know about touch icons&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>跨浏览器的Inline-Block</title>
   <link href="http://weizhifeng.net/cross-browser-inline-block.html"/>
   <updated>2013-07-06T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/cross-browser-inline-block</id>
   <content type="html">&lt;p&gt;啊，inline-block，如此的让人难以琢磨，并且又有诱人的显示方式宣传，只是其承诺的很多，兑现的却如此少。我已经收到这样的PSD文件有很多次：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.mozilla.org/webdev/files/2009/02/gallery-view.jpg&quot; title=&quot;gallery-view&quot; alt=&quot;gallery-view&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看了之后我就开始哭了。&lt;/p&gt;

&lt;p&gt;通常情况下，这个类型的布局是小菜一碟。固定宽度，固定高度，左侧浮动（&lt;code&gt;float:left&lt;/code&gt;），然后就完成了。但但但是，这个设计需要与可变数量的内容一起工作，也就是说如果这些块中的一个比其他块拥有更多的内容，它将会破坏整个布局：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.mozilla.org/webdev/files/2009/02/float-broken.jpg&quot; title=&quot;float-broken&quot; alt=&quot;float-broken&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于第一个画廊项目比其他的高，所以第五个项目就相对于它进行左侧浮动而不是位于它下面。总体上来说我们想要一个拥有表格一样伸缩性的布局，但真正合适的应该是一个语义标记。&lt;/p&gt;

&lt;p&gt;我们以拥有一个无序列表，并且&lt;code&gt;display&lt;/code&gt;被设置为&lt;code&gt;inline-block&lt;/code&gt;的一个简单页面开始：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;
        &amp;lt;h4&amp;gt;This is awesome&amp;lt;/h4&amp;gt;
        &amp;lt;img src=&quot;http://farm4.static.flickr.com/3623/3279671785_d1f2e665b6_s.jpg&quot;
        alt=&quot;lobster&quot; width=&quot;75&quot; height=&quot;75&quot;/&amp;gt;
    &amp;lt;/li&amp;gt;
...
&amp;lt;ul&amp;gt;

&amp;lt;style&amp;gt;
    li {
        width: 200px;
        min-height: 250px;
        border: 1px solid #000;
        display: inline-block;
        margin: 5px;
    }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Firefox 3，Safari 3和Opera中看起来OK：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.mozilla.org/webdev/files/2009/02/step1.jpg&quot; title=&quot;step1&quot; alt=&quot;step1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;明显的，垂直对齐有点问题。恩，但这并不是真正的有问题，因为这是正确的行为，但这不是我们想要的。&lt;/p&gt;

&lt;p&gt;这儿发生的事情是每个&lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;的&lt;a href=&quot;http://dev.w3.org/csswg/css3-linebox/#baseline&quot;&gt;baseline&lt;/a&gt;是以父元素&lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;的baseline来对齐的。什么是baseline，你问道？一图抵千言：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.mozilla.org/webdev/files/2009/02/baseline.gif&quot; alt=&quot;baseline&quot; /&gt;&lt;/p&gt;

&lt;p&gt;baseline是那条穿过上面文字的黑线。行内（inline）或者行内块（inline-block）元素的&lt;a href=&quot;http://www.w3.org/TR/CSS21/visudet.html#propdef-vertical-align&quot;&gt;默认垂直对齐的值&lt;/a&gt;是baseline，也就是说元素的baseline将会与其父元素的baseline进行对齐。这是第一个包含基准线在内的行内块：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.mozilla.org/webdev/files/2009/02/baseline-inline-block.jpg&quot; alt=&quot;baseline-inline-block&quot; /&gt;&lt;/p&gt;

&lt;p&gt;你可以看见，每个基准线都和文本“This is the baseline”的基准线所对齐。那个文本并没有在一个&lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;之中，它只是父元素&lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;的一个简单的文本节点，用来标识父元素的基准线在哪。&lt;/p&gt;

&lt;p&gt;但是，解决这个问题的方法很简单：&lt;code&gt;vertical-align:top&lt;/code&gt;，其效果是一个好看的网格：
&lt;img src=&quot;http://blog.mozilla.org/webdev/files/2009/02/inline-block-2.jpg&quot; alt=&quot;inline-block-2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;除了它仍然不在Firefox 2，IE 6和7中工作以外。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.mozilla.org/webdev/files/2009/02/inline-block-ff2.jpg&quot; alt=&quot;inline-block-ff2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;让我们来开始处理Firefox 2。&lt;/p&gt;

&lt;p&gt;Firefox 2不支持行内块，但是它支持一个显示效果与行内块一样，Mozilla所特有的显示属性&lt;code&gt;-moz-inline-stack&lt;/code&gt;。当我们把它加到&lt;code&gt;display:inline-block&lt;/code&gt;前面，FF2将会忽略那个声明（译者注：即&lt;code&gt;display:inline-block&lt;/code&gt;）并保持&lt;code&gt;-moz-inline-stack&lt;/code&gt;，因为它不支持行内块。支持行内块的浏览器将会使用它（译者注：&lt;code&gt;display:inline-block&lt;/code&gt;），并且忽略前面的显示属性（译者注：&lt;code&gt;-moz-inline-stack&lt;/code&gt;）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style&amp;gt;
    li {
        width: 200px;
        min-height: 250px;
        border: 1px solid #000;
        display: -moz-inline-stack;
        display: inline-block;
        vertical-align: top;
        margin: 5px;
    }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不幸的是，它有一个小bug：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.mozilla.org/webdev/files/2009/02/inline-block-3.jpg&quot; alt=&quot;inline-block-3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;老实说，我不知道什么导致了这个bug。但是这儿有快速解决的方法。把&lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;中的所有内容包含在一个&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;之中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;li&amp;gt;
        &amp;lt;div&amp;gt;
            &amp;lt;h4&amp;gt;This is awesome&amp;lt;/h4&amp;gt;
            &amp;lt;img src=&quot;http://farm4.static.flickr.com/3623/3279671785_d1f2e665b6_s.jpg&quot;
            alt=&quot;lobster&quot; width=&quot;75&quot; height=&quot;75&quot;/&amp;gt;
        &amp;lt;/div&amp;gt;
&amp;lt;/li&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这好像&lt;code&gt;reset&lt;/code&gt;了&lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;中的一切，然后适当的展示它们。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.mozilla.org/webdev/files/2009/02/inline-block-2.jpg&quot; alt=&quot;inline-block-2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在，我们来看IE7。IE7不支持行内块，但是我们可以用小把戏让它来渲染&lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;，就好像它们是行内块一样。应该怎么做？&lt;a href=&quot;http://haslayout.net/haslayout&quot;&gt;hasLayout&lt;/a&gt;，一个为所有乐趣而生的IE魔法属性。你不能以&lt;code&gt;hasLayout:true;&lt;/code&gt;或者以任何类似这样的形式给一个元素明确的设置&lt;code&gt;hasLayout&lt;/code&gt;，但是你可以使用其他的声明比如&lt;code&gt;zoom:1&lt;/code&gt;来触发它。&lt;/p&gt;

&lt;p&gt;从技术上来说，&lt;code&gt;hasLayout&lt;/code&gt;意味着一个设置了&lt;code&gt;hasLayout&lt;/code&gt;的元素要对自己和其子元素的渲染负责（把它们通过&lt;code&gt;min-height&lt;/code&gt;和&lt;code&gt;width&lt;/code&gt;属性组合起来，然后你就得到了与&lt;code&gt;display:block&lt;/code&gt;很像的行为）。它就像魔法仙尘一样，你可以把它们洒在渲染问题上，然后这些问题就烟消云散了。&lt;/p&gt;

&lt;p&gt;当我们向&lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;元素中加入&lt;code&gt;zoom:1&lt;/code&gt;和&lt;code&gt;*display:inline&lt;/code&gt;（&lt;a href=&quot;http://www.ejeliot.com/blog/63&quot;&gt;star hack to target IE6 &amp;amp; 7)&lt;/a&gt;）的时候，我们就使得IE7以&lt;code&gt;inline-block&lt;/code&gt;的形式显示它们：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style&amp;gt;
    li {
        width: 200px;
        min-height: 250px;
        border: 1px solid #000;
        display: -moz-inline-stack;
        display: inline-block;
        vertical-align: top;
        margin: 5px;
        zoom: 1;
        *display: inline;
    }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.mozilla.org/webdev/files/2009/02/inline-block-ie7.jpg&quot; alt=&quot;inline-block-ie7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;呼！（译者注：松口气）基本上完成了。就剩下IE 6了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.mozilla.org/webdev/files/2009/02/inline-block-ie6.jpg&quot; alt=&quot;inline-block-ie6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;IE 6不支持&lt;code&gt;min-height&lt;/code&gt;，但是很感谢（译者注：反讽）其对&lt;code&gt;height&lt;/code&gt;属性的不正确处理，所以我们可以用它来代替。设置&lt;code&gt;_height&lt;/code&gt;（&lt;a href=&quot;http://www.ejeliot.com/blog/63&quot;&gt;IE6 underscore hack&lt;/a&gt;）的值为250px将会使所有&lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;元素的高度为250px，并且如果它们内容超过了这个值，它们将会展开来进行适配。所有其他浏览器会忽略&lt;code&gt;_height&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;那么经过所有的努力之后，这就是最终的CSS和HTML了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style&amp;gt;
    li {
        width: 200px;
        min-height: 250px;
        border: 1px solid #000;
        display: -moz-inline-stack;
        display: inline-block;
        vertical-align: top;
        margin: 5px;
        zoom: 1;
        *display: inline;
        _height: 250px;
    }
&amp;lt;/style&amp;gt;

&amp;lt;li&amp;gt;
        &amp;lt;div&amp;gt;
            &amp;lt;h4&amp;gt;This is awesome&amp;lt;/h4&amp;gt;
            &amp;lt;img src=&quot;http://farm4.static.flickr.com/3623/3279671785_d1f2e665b6_s.jpg&quot;
            alt=&quot;lobster&quot; width=&quot;75&quot; height=&quot;75&quot;/&amp;gt;
        &amp;lt;/div&amp;gt;
&amp;lt;/li&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原文：&lt;a href=&quot;http://blog.mozilla.org/webdev/2009/02/20/cross-browser-inline-block/&quot;&gt;http://blog.mozilla.org/webdev/2009/02/20/cross-browser-inline-block/&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>The Underscore Hack</title>
   <link href="http://weizhifeng.net/css-underscore-hack.html"/>
   <updated>2013-06-30T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/css-underscore-hack</id>
   <content type="html">&lt;p&gt;译者注：&lt;strong&gt;The Underscore Hack&lt;/strong&gt;是用来解决IE6，7下CSS　bug的一种方法。&lt;/p&gt;

&lt;p&gt;让我们以Petr Pisar发现的三个简单事实开始。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;下划线（“_”）在CSS2.1标准中所定义的CSS标识符中是&lt;a href=&quot;http://www.w3.org/TR/CSS21/syndata.html#tokenization&quot;&gt;允许的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;浏览器必须忽略未知的CSS属性&lt;/li&gt;
&lt;li&gt;Windows下的MSIE5以上浏览器会忽略任何CSS属性名开头的“_”&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;所以，一个CSS的定义，比如&lt;code&gt;_color:red&lt;/code&gt;是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;正确的，因为CSS2.1标准允许它（即使一些只实现了CSS2.0的软件校验器，说这是一个bug：但是它们是错的，这个用法是正确的）。&lt;/li&gt;
&lt;li&gt;被除了WinIE（译者注：Windows下的IE浏览器）之外的任何浏览器所忽略&lt;/li&gt;
&lt;li&gt;在WinIE中被当作&lt;code&gt;color:red&lt;/code&gt;处理&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;因此，这个IE的bug/特性是用来设置只有WinIE（MacIE没有这个bug/特性）才能理解的CSS属性的非常简单和清晰的方法。用来修复比如在WinIE中忘了实现的&lt;code&gt;position:fixed&lt;/code&gt;规则非常的容易（去看&lt;a href=&quot;http://wellstyled.com/files/css-underscore-hack/example-position.html&quot;&gt;例子&lt;/a&gt;）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#menu {
   position: fixed;
   _position: absolute;
   ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以用同样的方法来修复WinIE中没有实现的&lt;code&gt;min-height&lt;/code&gt;属性（去看&lt;a href=&quot;http://wellstyled.com/files/css-underscore-hack/example-minheight.html&quot;&gt;例子2&lt;/a&gt;）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#box {
   min-height: 300px;
   height: auto;
   _height: 300px;
   ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：这使用了WinIE的另一个bug，把&lt;code&gt;overflow:visible&lt;/code&gt;当作&lt;code&gt;height:auto&lt;/code&gt;来解决以上的问题。更多的细节，请看&lt;a href=&quot;http://wellstyled.com/css-minheight-hack.html&quot;&gt;The &quot;min-height&quot; Hack&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;我在Windows下的MSIE 5，5.5，6和Opera；Mac OSX下的MSIE 5，Safari，Camino；以及Mozilla和Firefox下进行了测试。（译者注：我没在现代浏览器上测试过。）&lt;/p&gt;

&lt;p&gt;原文：&lt;a href=&quot;http://wellstyled.com/css-underscore-hack.html&quot;&gt;http://wellstyled.com/css-underscore-hack.html&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>CSS 2.1选择器第三部分</title>
   <link href="http://weizhifeng.net/css-21-selectors-part-3.html"/>
   <updated>2013-06-29T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/css-21-selectors-part-3</id>
   <content type="html">&lt;h1&gt;CSS 2.1 选择器，第三部分&lt;/h1&gt;

&lt;p&gt;这是介绍CSS 2.1中可用的选择器的三篇系列文章中的第三篇也是最后一篇文章。&lt;a href=&quot;css-21-selectors-part-1.html&quot;&gt;第一篇&lt;/a&gt;是关于非常基础的内容，比如类型选择器，类和ID选择器，通配选择器，简单选择器。在&lt;a href=&quot;/css-21-selectors-part-2.html&quot;&gt;第二篇&lt;/a&gt;文章中，我介绍了组合因子（combinators），组合选择器，分组，以及属性选择器。&lt;/p&gt;

&lt;p&gt;这次我将会近距离的看下伪类（pseudo-classes）和伪元素（pseudo-elements）。像我在第二篇文章中介绍的更加高级的选择器一样，伪类和伪元素还没有被所有主流浏览器所完全支持（译者注：浏览器支持情况请见&lt;a href=&quot;http://www.quirksmode.org/css/selectors/&quot;&gt;quirksmode&lt;/a&gt;），所以请记得当浏览器不支持的时候，检查一下到底发生了什么。你不希望你的内容在不支持这儿所讨论的CSS的浏览器中不能被访问。&lt;/p&gt;

&lt;h2&gt;伪类和伪元素&lt;/h2&gt;

&lt;p&gt;伪类和伪元素能被用来格式化那些不能通过文档树中可用的信息来定位的元素。举个例子，不存在一个与一个段落中的第一行内容或者一个元素文本内容的第一个字母所关联的元素。&lt;/p&gt;

&lt;h2&gt;伪类&lt;/h2&gt;

&lt;p&gt;伪类是用比名字，属性或者内容更加独特的信息来匹配元素的。&lt;/p&gt;

&lt;h3&gt;:first-child&lt;/h3&gt;

&lt;p&gt;这个伪类会匹配一个元素的第一个子元素。让我们假设你想给一篇文章的第一个段落配一个特殊的样式。如果这篇文章被包含在一个类名为“article”的&lt;code&gt;div&lt;/code&gt;元素中，那么下面的规则将会匹配每一篇文章中的第一个&lt;code&gt;p&lt;/code&gt;元素：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;div.article p:first-child {
    font-style:italic;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;想匹配所有做为任何元素的第一个子元素而存在的&lt;code&gt;p&lt;/code&gt;元素，你可以使用这个规则的选择器：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p:first-child {
    font-style:italic;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;:link和:visited&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;link伪类&lt;/code&gt;会对未访问和访问过的链接状态产生影响。这两种状态是相互独立的－一个链接在同一时间不可能既是访问过又是未访问过。&lt;/p&gt;

&lt;p&gt;这些伪类只能应用到文档语言所决定的超链接源锚点（anchor）上。对于HTML来说，这指的是具有&lt;code&gt;href&lt;/code&gt;属性的&lt;code&gt;a&lt;/code&gt;元素。既然这不会影响其他元素，那么以下选择器是一样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a:link
:link
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;:hover, :active, and :focus&lt;/h3&gt;

&lt;p&gt;动态伪类可以用来控制特定元素在用户发起特定动作时的展现形式。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;:hover&lt;/code&gt;在当用户使用一个指针式设备指向一个元素但是并没有触发它的时候产生效果。大部分情况下这指的是使用一个鼠标，并让光标悬浮在一个元素上。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;:active&lt;/code&gt;在当一个元素被用户触发的时候生效。对于鼠标用户来说这指的是你按下鼠标的按钮，并且保持按下的状态，直到你释放它为止。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;:focus&lt;/code&gt;在当一个元素拥有焦点的时候会生效，比如当它接收键盘事件的时候。&lt;/p&gt;

&lt;p&gt;一个元素可以同时匹配多个伪类。一个元素可以拥有焦点，同时又可以被鼠标悬浮，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;input[type=text]:focus {
    color:#000;
    background:#ffe;
}
input[type=text]:focus:hover {
    background:#fff;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个规则将会匹配拥有焦点的&lt;code&gt;input&lt;/code&gt;元素，第二个规则将会匹配同样的元素当鼠标悬浮在它们上方时候。&lt;/p&gt;

&lt;h3&gt;:lang&lt;/h3&gt;

&lt;p&gt;语言伪类可以用来给内容被定义在一个指定语言（人类语言，不是标记语言）中的元素加样式。下面的规则定义了在瑞典语中一个行内引用使用哪个引号：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;q:lang(sv) { quotes: &quot;\201D&quot; &quot;\201D&quot; &quot;\2019&quot; &quot;\2019&quot;; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个文档或者元素中使用的人类语言通常在HTML中是通过&lt;code&gt;lang&lt;/code&gt;属性来指定的，在XHTML中是通过&lt;code&gt;xml:lang&lt;/code&gt;属性来指定的。&lt;/p&gt;

&lt;h2&gt;伪元素&lt;/h2&gt;

&lt;p&gt;伪元素可以让作者访问和格式化不能通过文档树中节点来访问的部分。&lt;/p&gt;

&lt;h2&gt;:first-line&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;:first-line&lt;/code&gt;伪元素会对文本段落中的第一行产生影响。它只能应用到块级元素，行内块（inline-block）元素，表格标题或者表格单元格。&lt;/p&gt;

&lt;p&gt;第一行的长度明显的取决于多种因素，包括字体大小和包含此文本元素的宽度。&lt;/p&gt;

&lt;p&gt;下面规则将会应用到一个段落中的第一行文本：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p:first-line {
    font-weight:bold;
    color;#600;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意可以应用到&lt;code&gt;:first-line&lt;/code&gt;伪元素上的属性有一些限制。请查看&lt;a href=&quot;http://www.w3.org/TR/CSS21/selector.html#first-line-pseudo&quot;&gt;:first-line伪元素&lt;/a&gt;文档来获取可以应用的属性列表。&lt;/p&gt;

&lt;h2&gt;:first-letter&lt;/h2&gt;

&lt;p&gt;这个伪元素可以让你定位一个元素的第一个字母或者数字，能够应用到块（block），列表项目，表格单元格，表格标题和行内块（inline-block）等元素上。&lt;/p&gt;

&lt;p&gt;下面的规则将会应用到类名为“preamble”的元素的第一个字符：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.preamble:first-letter {
    font-size:1.5em;
    font-weight:bold;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;像&lt;code&gt;:first-line&lt;/code&gt;伪元素一样，&lt;code&gt;:first-letter&lt;/code&gt;伪元素对于哪些属性可以应用也有一些限制。请查看&lt;a href=&quot;http://www.w3.org/TR/CSS21/selector.html#first-letter&quot;&gt;:first-letter伪元素&lt;/a&gt;的文档来获取可以应用的属性列表。&lt;/p&gt;

&lt;h2&gt;:before and :after&lt;/h2&gt;

&lt;p&gt;在更多的经过讨论的CSS特性中，&lt;code&gt;:before&lt;/code&gt;和&lt;code&gt;:after&lt;/code&gt;伪元素可以用来向一个元素内容的前面或者后面插入生成好的内容。&lt;/p&gt;

&lt;p&gt;这是&lt;code&gt;:before&lt;/code&gt;如何被使用（来自我的文章&lt;a href=&quot;http://www.456bereastreet.com/archive/200509/custom_borders_with_advanced_css/&quot;&gt;Custom borders with advanced CSS&lt;/a&gt;）的一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.cbb:before {
    content:&quot;&quot;;
    display:block;
    height:17px;
    width:18px;
    background:url(top.png) no-repeat 0 0;
    margin:0 0 0 -18px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个使用&lt;code&gt;:after&lt;/code&gt;在一个链接文本后面插入一个链接的URL的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a:link:after {
    content: &quot; (&quot; attr(href) &quot;) &quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;IE问题&lt;/h2&gt;

&lt;p&gt;在你开始把已经学到的关于选择器的所有东西付诸使用之前，注意IE浏览器直到并且包括版本6在内，对于CSS2.1选择器的支持并不完整。下面是不支持或者有问题的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;子选择器&lt;/li&gt;
&lt;li&gt;邻居兄弟选择器&lt;/li&gt;
&lt;li&gt;属性选择&lt;/li&gt;
&lt;li&gt;多个类选择器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:first-child&lt;/code&gt;伪类&lt;/li&gt;
&lt;li&gt;语言伪类&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:before&lt;/code&gt;和&lt;code&gt;:after&lt;/code&gt;伪元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:hover&lt;/code&gt;伪类只在&lt;code&gt;a&lt;/code&gt;元素中工作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:focus&lt;/code&gt;伪类不支持。对于获得焦点的&lt;code&gt;a&lt;/code&gt;元素，&lt;code&gt;:active&lt;/code&gt;伪类会被应用。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;幸运的是，看起来IE7将会对CSS2.1进行完整的支持。&lt;/p&gt;

&lt;h2&gt;你已经有能量了 - 现在开始使用它&lt;/h2&gt;

&lt;p&gt;这就是所有的内容了。现在你已经学了所有关于CSS2.1选择器的内容，你已经有了相当多的能量可以使用当你设计你的文档的时候。为了保持你的标记整洁，并且增加可访问性和可用性，请小心的使用。并且记得思考在那些不支持更高级CSS选择器的旧浏览器中将会发生什么。&lt;/p&gt;

&lt;p&gt;原文：&lt;a href=&quot;http://www.456bereastreet.com/archive/200510/css_21_selectors_part_3/&quot;&gt;http://www.456bereastreet.com/archive/200510/css_21_selectors_part_3/&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>CSS 2.1选择器第二部分</title>
   <link href="http://weizhifeng.net/css-21-selectors-part-2.html"/>
   <updated>2013-06-23T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/css-21-selectors-part-2</id>
   <content type="html">&lt;h1&gt;CSS 2.1 选择器，第二部分&lt;/h1&gt;

&lt;p&gt;这是介绍CSS2.1中可用选择器的三篇系列文章中的第二篇。&lt;a href=&quot;/css-21-selectors-part-1.html&quot;&gt;第一篇&lt;/a&gt;更多的是关于基础的东西，比如类型选择器（type selectors），类选择器和id选择器，通配选择器（universal selector），和简单选择器。&lt;/p&gt;

&lt;p&gt;在这篇文章中我将会近距离的介绍并没有被所有的主流浏览器完全支持（译者注：目前主流浏览器对以下介绍的选择器已经都支持，详见&lt;a href=&quot;http://www.quirksmode.org/css/selectors/&quot;&gt;quirksmode&lt;/a&gt;）的更高级的选择器。这些支持正一步一步的变好，所以是值得花时间学习这篇中介绍的选择器的。&lt;/p&gt;

&lt;h2&gt;组合因子（Combinators）&lt;/h2&gt;

&lt;p&gt;组合因子是用来分隔一个组合选择器（combined selector）中的两个或者多个简单选择器的。可用的组合因子是&lt;code&gt;空白&lt;/code&gt;（任意数量的tab，空格或者其他空白字符），&lt;code&gt;&amp;gt;&lt;/code&gt;，和&lt;code&gt;+&lt;/code&gt;。每个组合因子都是做什么的将会在接下来的几个部分进行介绍。&lt;/p&gt;

&lt;h2&gt;后代选择器（Descendant selectors）&lt;/h2&gt;

&lt;p&gt;一个后代选择器是由两个或者更多个的简单选择器以空格进行分隔所组成的。这个选择器会匹配第一个简单选择器所匹配元素的后代元素。举个例子，下面规则中的选择器将会匹配&lt;code&gt;div&lt;/code&gt;元素后代中的所有&lt;code&gt;p&lt;/code&gt;元素：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;div p { color:#f00; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;组成后代选择器的每个选择器可以是任何形式的简单选择器。下面规则中的选择器匹配了所有拥有&lt;code&gt;info&lt;/code&gt;类名的&lt;code&gt;p&lt;/code&gt;元素，其又被一个&lt;code&gt;li&lt;/code&gt;元素包含，&lt;code&gt;li&lt;/code&gt;元素又被一个id为&lt;code&gt;myid&lt;/code&gt;的&lt;code&gt;div&lt;/code&gt;元素所包含。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;div#myid li p.info { color:#f00; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后代选择器允许你在不需要提供一个类名或者一个id的情况下去定位元素，这相应的帮你保持你标记的简洁。让我们假设你有一个以下面标记组成的导航列表：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul id=&quot;nav&quot;&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;Link 1&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;Link 2&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;Link 3&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了只定位导航列表中的列表项目和链接，你可能使用以下CSS：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#nav li { display:inline; }
#nav a { font-weight:bold; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些规则将不会匹配文档中的任何其他列表项目或者链接。把这个做法跟给每个列表和链接添加一个类名对比一下，你将会认识到当你使用后代选择器的时候你的标记能变得有多整洁。&lt;/p&gt;

&lt;h2&gt;子选择器&lt;/h2&gt;

&lt;p&gt;一个子选择器可以定位一个特定元素的直接子元素。一个子选择器由两个或者多个以大于号“&gt;”分隔的选择器组成。父元素位于“&gt;”的左侧，同时组合因子周围的空白是允许的。&lt;/p&gt;

&lt;p&gt;这个规则将会影响一个&lt;code&gt;div&lt;/code&gt;元素的所有&lt;code&gt;strong&lt;/code&gt;子元素：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;div &amp;gt; strong { color:#f00; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只有是&lt;code&gt;div&lt;/code&gt;元素直接后代的&lt;code&gt;strong&lt;/code&gt;元素才能被这个规则所定位。如果在文档树中的&lt;code&gt;div&lt;/code&gt;和&lt;code&gt;strong&lt;/code&gt;元素之间存在任何其他元素，这个选择器将不会匹配。在下面的例子中，只有“Text one”会被以上规则所影响：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;
&amp;lt;strong&amp;gt;Text one&amp;lt;/strong&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;strong&amp;gt;Text two&amp;lt;/strong&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;相邻兄弟选择器&lt;/h2&gt;

&lt;p&gt;一个相邻兄弟选择器是由两个以加号“＋”分隔的简单选择器所组成。相邻兄弟之间的组合因子周围的空白是被允许的。这个选择器会匹配第一个元素的紧接着的兄弟元素。这些元素必须有同样的父元素，并且第一个元素必须直接位于第二个元素之前：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p + p { color:#f00; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果应用在以下例子中，上面的规则将会只影响“Paragraph two”：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;
&amp;lt;p&amp;gt;Paragraph one&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;Paragraph two&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;分组&lt;/h2&gt;

&lt;p&gt;我决定在这个时候提一下分组，因为我发现当人们在学习CSS的时候常犯的一个错误是和对组合选择器进行分组相关的。&lt;/p&gt;

&lt;p&gt;为了能够把相同的规则应用在一些不同选择器所匹配的元素上，你可以把它们分到一个以逗号分隔的列表组中，而不是为每个选择器都重复声明一遍。常犯的错误是没有列出完整的选择器。假设你有如下的标记：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&quot;news&quot;&amp;gt;
&amp;lt;h3&amp;gt;News&amp;lt;/h3&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;Item 1&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Item 2&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，假设你想对第三级标题（h3）和无序列表（ul）应用同样长的margin，但是只有当它们位于&lt;code&gt;id&lt;/code&gt;为“news”的&lt;code&gt;div&lt;/code&gt;元素之中的时候。这是错误的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;div#news h3, ul {
    margin:0 2em;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这将会对&lt;code&gt;div#news&lt;/code&gt;中的&lt;code&gt;h3&lt;/code&gt;和&lt;code&gt;ul&lt;/code&gt;元素都产生影响。问题是它将会把&lt;strong&gt;文档中所有&lt;/strong&gt;的&lt;code&gt;ul&lt;/code&gt;元素做为目标元素，而不仅仅是&lt;code&gt;div#news&lt;/code&gt;中的。&lt;/p&gt;

&lt;p&gt;这是这个例子中对选择器进行分组的正确方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;div#news h3,
div#news ul {
    margin:0 2em;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以，当对选择器进行分组的时候，记住要对每个选择器进行完整指定。&lt;/p&gt;

&lt;h2&gt;属性选择器&lt;/h2&gt;

&lt;p&gt;属性选择器是基于属性存在与否或者属性的值来进行元素匹配的。一个属性选择器有四种方法进行匹配：&lt;/p&gt;

&lt;p&gt;[att]
匹配拥有一个&lt;code&gt;att&lt;/code&gt;属性的元素，不管属性值是什么。&lt;/p&gt;

&lt;p&gt;[att=val]
匹配拥有一个值为“val”的&lt;code&gt;att&lt;/code&gt;属性的元素。&lt;/p&gt;

&lt;p&gt;[att~=val]
匹配其&lt;code&gt;att&lt;/code&gt;属性值是一个以空格分隔的列表，并且列表中包含“val”值的元素。在这个情况下“val”不能包含空格。&lt;/p&gt;

&lt;p&gt;[att|=val]
匹配&lt;code&gt;att&lt;/code&gt;属性值是一个以“val”开始的以中划线（-）分隔的列表的元素。这个选择器主要用来匹配&lt;code&gt;lang&lt;/code&gt;属性（XHTML中的xml:lang）指定的语言子码，比如“en”，“en-us”，“en-gb”，等等。&lt;/p&gt;

&lt;p&gt;看一些例子。下面规则中的选择器匹配了所有拥有&lt;code&gt;title&lt;/code&gt;属性的&lt;code&gt;p&lt;/code&gt;元素，而不管属性值是什么：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p[title] { color:#f00; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在下面的例子中，选择器匹配了&lt;code&gt;class&lt;/code&gt;属性值为&lt;code&gt;error&lt;/code&gt;的所有&lt;code&gt;div&lt;/code&gt;元素：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;div[class=error] { color:#f00; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了匹配所有&lt;code&gt;headers&lt;/code&gt;属性值包含“col1”的&lt;code&gt;td&lt;/code&gt;元素，下面的选择器可以被使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;td[headers~=col1] { color:#f00; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，下面例子中的选择器会匹配所有&lt;code&gt;lang&lt;/code&gt;属性以&lt;code&gt;en&lt;/code&gt;开始的&lt;code&gt;p&lt;/code&gt;元素：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p[lang|=en] { color:#f00; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多属性选择器可以在同样的选择器中使用。这使得匹配相同元素的一些不同属性成为可能。下面的规则将会应用到所有&lt;code&gt;class&lt;/code&gt;属性值为“quote”，并且拥有一个&lt;code&gt;cite&lt;/code&gt;属性（不管其值为什么）的&lt;code&gt;blockquote&lt;/code&gt;元素：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;blockquote[class=quote][cite] { color:#f00; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;待续&lt;/h2&gt;

&lt;p&gt;到了第二篇文章的结尾处了。在&lt;a href=&quot;/css-21-selectors-part-3.html&quot;&gt;第三篇&lt;/a&gt;文章中，即这个系列最后的部分，我将会介绍伪类和伪元素选择器。当你在等第三篇的时候，你可以重新看一下第一篇文章。复习对学习是有益的。&lt;/p&gt;

&lt;p&gt;原文：&lt;a href=&quot;http://www.456bereastreet.com/archive/200510/css_21_selectors_part_2/&quot;&gt;http://www.456bereastreet.com/archive/200510/css_21_selectors_part_2/&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>蔣中正遺囑</title>
   <link href="http://weizhifeng.net/letters.html"/>
   <updated>2013-06-22T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/letters</id>
   <content type="html">&lt;p&gt;一九七五年四月五日是清明掃墓節最後一晚。全臺灣、全中國都相信祖先的鬼魂四處遊走，準備在當晚回到打掃得幹幹凈凈的住所。當天晚上，蔣的醫師熊丸在士林官邸庭院散步，擡頭可見滿天星鬥。他回到室內就寢後不久，值班醫師便緊急召喚他。蔣總統心跳停止了。熊丸披上袍子，沖到樓下蔣的寢室。打了強心針後，他的心臟恢復跳動。蔣夫人趕到病榻之側，總統心跳又停了。醫生再打了一針。&lt;/p&gt;

&lt;p&gt;救護車趕緊把委員長送到離官邸不願的榮總。不久，蔣經國也聞訊趕到加護病房，此時老先生又停止心跳。熊丸準備打第三針，夫人卻輕碰他的手，嘆了一口氣說：「停了吧！」距午夜還有幾分鐘。此時，從臺北到高雄，全島突然風雨大作、雷電交加。即使從哈佛學成歸國的官員也認為，這不只是純屬巧合。&lt;/p&gt;

&lt;p&gt;委員長過世後兩個小時，政府發表了一份號稱是一星期前寫下的遺囑。內容如下：&lt;/p&gt;

&lt;p&gt;自余束發以來，即追隨總理革命，無時不以耶穌基督與總理信徒自居，無日不為掃除三民主義之障礙、建設民主憲政之國家，艱苦奮鬥。&lt;/p&gt;

&lt;p&gt;近二十余年來，自由基地日益精實壯大，並不斷對大陸共產邪惡展開政治作戰，反共復國大業方期日新月盛。全國軍民、全黨同誌，絕不可因余之不起而懷憂喪誌！務望一致精誠團結，服膺本黨與政府領導，奉主義為無形之總理，以復國為共同之目標，而中正之精神自必與我同誌同胞，長相左右。&lt;/p&gt;

&lt;p&gt;實踐三民主義、光復大陸國土、復興民族文化、堅守民主陣容，為余畢生之誌事，實亦即海內外軍民同胞一致的革命職誌與戰鬥決心。&lt;/p&gt;

&lt;p&gt;惟願堅此百忍，奮力自強，非達成國民革命之責任絕不中止！矢勤矢勇，毋怠毋忽。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>CSS 2.1选择器第一部分</title>
   <link href="http://weizhifeng.net/css-21-selectors-part-1.html"/>
   <updated>2013-06-22T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/css-21-selectors-part-1</id>
   <content type="html">&lt;h1&gt;CSS 2.1 选择器，第一部分&lt;/h1&gt;

&lt;p&gt;当你开始使用CSS的时候，最先接触的东西是选择器。选择器显然是CSS的基础内容，但是很少有开发者能发挥其全部的潜力。当然你只使用类型（type）, ID, 类（class）就可以完成大量的工作，但是选择器还有更多的内容。&lt;/p&gt;

&lt;p&gt;学习如何正确使用CSS 2.1中所有可用的选择器能够真正的帮助你保持你的HTML更加整洁。它将最小化不必要的class属性以及额外添加到标记中的div和span元素。听起来不错，是吧？&lt;/p&gt;

&lt;p&gt;那为什么所有的选择器没有被广泛的使用呢？最重要的原因是包括IE6在内的IE浏览器对其的支持不足。其他现在的浏览器都支持大部分或者所有的CSS 2.1选择器。在使用这系列文章介绍的一切内容之前，请注意一下这个问题。（译者注：浏览器支持情况请见&lt;a href=&quot;http://www.quirksmode.org/css/selectors/&quot;&gt;quirksmode&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;好消息是Internet Explorer 7将会对选择器有更好的支持。你将来可以使用它们了，现在正好是学习所有可用选择器的最佳时间。&lt;/p&gt;

&lt;p&gt;因为有如此多的CSS选择器，用一篇文章来解释它们会变的非常的冗长。为了使信息更容易的被消化，我把它们分成了三个部分：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一部分，也就是这篇文章，解释选择器的基础加上通配（universal）, 类型（type）, id和类（class）选择器。&lt;/li&gt;
&lt;li&gt;第二部分是关于组合因子（combinators），合并选择器（ combined selectors），分组（grouping），以及属性选择器。&lt;/li&gt;
&lt;li&gt;第三部分将会是关于伪类（pseudo-classes）和伪元素（pseudo-elements）。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;我将会在几周内发表这些文章，并且在它们发表的时候挨个更新其指向其他部分的链接。&lt;/p&gt;

&lt;p&gt;好了。我们开始了。&lt;/p&gt;

&lt;h2&gt;选择器基础&lt;/h2&gt;

&lt;p&gt;先看看最基础的。一个CSS选择器是由一个用来匹配文档树中所有元素的模式组成的。当模式中的所有条件都为true的时候，这个选择器就完成了匹配，然后其定义的规则将会被应用在匹配的一个或多个匹配元素上。看下这个非常简单的CSS规则：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p { color:#f00; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;选择器是CSS规则中大括号开始之前（&quot;{&quot;）的部分。这儿的选择器是&lt;code&gt;p&lt;/code&gt;，其将会匹配文档中的所有&lt;code&gt;p&lt;/code&gt;元素，并且使其包含的所有文本变成红色。非常基础。&lt;/p&gt;

&lt;h2&gt;选择器概览&lt;/h2&gt;

&lt;p&gt;好了，刚才是一个非常简单的例子。接下来我将会描述其他的选择器，事情显然将会变得有些复杂。在开始之前，看下CSS 2.1所有选择器语法的一个概览（基于CSS 2.1, 5.1 Pattern matching中的表格内容）：&lt;/p&gt;

&lt;table&gt;
    &lt;caption&gt;CSS 2.1选择器语法概览&lt;/caption&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th scope=&quot;col&quot;&gt;选择器类型&lt;/th&gt;
            &lt;th scope=&quot;col&quot;&gt;模式&lt;/th&gt;
            &lt;th scope=&quot;col&quot;&gt;描述&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;通用（Universal）&lt;/td&gt;
            &lt;td&gt;*&lt;/td&gt;
            &lt;td&gt;匹配任何元素。&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;类型（Type）&lt;/td&gt;
            &lt;td&gt;E&lt;/td&gt;
            &lt;td&gt;匹配任意E元素。&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;类（Class）&lt;/td&gt;
            &lt;td&gt;.info&lt;/td&gt;
            &lt;td&gt;匹配任何&lt;code&gt;class&lt;/code&gt;属性中包含&lt;code&gt;info&lt;/code&gt;值的元素。&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;ID&lt;/td&gt;
            &lt;td&gt;#footer&lt;/td&gt;
            &lt;td&gt;匹配任何 &lt;code&gt;id&lt;/code&gt;等于&lt;code&gt;footer&lt;/code&gt;的元素。&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;后代（Descendant）&lt;/td&gt;
            &lt;td&gt;E F&lt;/td&gt;
            &lt;td&gt;匹配任何是E元素后代的F元素。&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;孩子（Child）&lt;/td&gt;
            &lt;td&gt;E &amp;gt; F&lt;/td&gt;
            &lt;td&gt;匹配任何是E元素孩子的F元素。&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;邻居（Adjacent）&lt;/td&gt;
            &lt;td&gt;E + F&lt;/td&gt;
            &lt;td&gt;匹配任何前面是兄弟元素E的F元素。&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;属性（Attribute）&lt;/td&gt;
            &lt;td&gt;E[att]&lt;/td&gt;
            &lt;td&gt;匹配任何拥有&lt;code&gt;att&lt;/code&gt;属性的E元素，无论属性的值是什么。&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;属性（Attribute）&lt;/td&gt;
            &lt;td&gt;E[att=val]&lt;/td&gt;
            &lt;td&gt;匹配任何&lt;code&gt;att&lt;/code&gt;属性值等于&lt;code&gt;val&lt;/code&gt;的E元素。&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;属性（Attribute）&lt;/td&gt;
            &lt;td&gt;E[att~=val]&lt;/td&gt; &lt;td&gt;匹配任何E元素，其&lt;code&gt;att&lt;/code&gt;属性值是一个以空格分割的列表，其中之一的值等于&lt;code&gt;val&lt;/code&gt;。&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;属性（Attribute）&lt;/td&gt;
            &lt;td&gt;E[att|=val]&lt;/td&gt; &lt;td&gt;匹配任何E元素，其&lt;code&gt;att&lt;/code&gt;属性值是以连字符（&quot;-&quot;）分割的列表，其中的值以&lt;code&gt;val&lt;/code&gt;开头。&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;:first-child伪类&lt;/td&gt;
            &lt;td&gt;E:first-child&lt;/td&gt;
            &lt;td&gt;匹配任何E元素，当E是其父元素的第一个孩子元素。&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;链接（link）伪类&lt;/td&gt;
            &lt;td&gt;E:link&lt;br&gt;E:visited&lt;/td&gt;
            &lt;td&gt;匹配没有访问过（:link）的或者已经访问过（:visited）的链接。&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;动态伪类&lt;/td&gt;
            &lt;td&gt;E:active&lt;br&gt;E:hover&lt;br&gt;E:focus &lt;/td&gt;
            &lt;td&gt;匹配特定用户行为的E元素。&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;:language伪类&lt;/td&gt;
            &lt;td&gt;E:lang(c)&lt;/td&gt;
            &lt;td&gt;匹配使用语言c的E元素。&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;:first-line伪元素&lt;/td&gt;
            &lt;td&gt;E:first-line&lt;/td&gt;
            &lt;td&gt;匹配E元素第一行的内容。&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;:first-letter伪元素&lt;/td&gt;
            &lt;td&gt;E:first-letter&lt;/td&gt;
            &lt;td&gt;匹配E元素的第一个字母。&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;:before和:after伪元素&lt;/td&gt;
            &lt;td&gt;E:before&lt;br&gt;E:after&lt;/td&gt;
            &lt;td&gt;用来向元素内容前面或者后面插入创建的内容。&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;我将会在这两部分文章中更加详细的介绍这些选择器类型的每一个，所以请继续阅读。表格中和这篇文章之后使用的一些术语可能需要一些说明：&lt;/p&gt;

&lt;h4&gt;后代&lt;/h4&gt;

&lt;p&gt;文档树中一个元素的孩子，孙子或者后代元素。&lt;/p&gt;

&lt;h4&gt;祖先&lt;/h4&gt;

&lt;p&gt;文档树中一个元素的父亲，祖父或者祖先元素。&lt;/p&gt;

&lt;h4&gt;孩子&lt;/h4&gt;

&lt;p&gt;一个元素的直接后代。文档树中此二者之间没有其他元素。&lt;/p&gt;

&lt;h4&gt;父亲&lt;/h4&gt;

&lt;p&gt;一个元素的直接祖先。文档树中此二者之间没有其他元素。&lt;/p&gt;

&lt;h4&gt;兄弟&lt;/h4&gt;

&lt;p&gt;拥有同样父亲元素的元素。&lt;/p&gt;

&lt;h2&gt;简单选择器和组合选择器（Simple and combined selectors）&lt;/h2&gt;

&lt;p&gt;选择器有两个基本的分类：简单（simple）和组合（combined）。&lt;/p&gt;

&lt;p&gt;一个简单选择器（simple selector）由一个类型选择器（type selector）或者通配选择器（universal selector）开头，后面跟着零个或多个属性选择器（attribute selectors），ID选择器（ID selectors），或者伪类（pseudo-classes）。下面的规则包含一个简单选择器的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p.info { background:#ff0; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个组合选择器（combined selector，有时候叫上下文选择器）由两个或者多个以连接符分割的简单选择器构成。这是一个非常简单的组合选择器的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;div p { font-weight:bold; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上规则将会对应用到所有是div元素的后代的p元素上。&lt;/p&gt;

&lt;p&gt;一个伪元素可以加在一个选择器后面。在一个组合选择器中，一个伪元素只能加在最后一个简单选择器后面。
组合选择器，连接符，以及伪类的细节可以在此系列的第二部分和第三部分找到。&lt;/p&gt;

&lt;h2&gt;通配选择器&lt;/h2&gt;

&lt;p&gt;通配选择器以星号，“*”来展现，其可以匹配文档中的所有元素。在样式表中很难看见通配选择器，但是它实际上经常是和类选择器与ID选择器合用。如果通配选择器不是一个简单选择器中的唯一组件，“*”将会被忽略：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.myclass&lt;/code&gt;等于&lt;code&gt;*.myclass&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#myid&lt;/code&gt;等于&lt;code&gt;*#myid&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;通配选择器中的一个用法已经变得非常流行，那就是用它来把所有元素的外边距（margin）和内边距（padding）都设置为0：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* { margin:0; padding:0; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个情况有时候会以&lt;a href=&quot;http://leftjustified.net/journal/2004/10/19/global-ws-reset/&quot;&gt;Global White Space Reset&lt;/a&gt;被提及到。&lt;/p&gt;

&lt;h2&gt;类型选择器&lt;/h2&gt;

&lt;p&gt;一个类型选择器会匹配特定元素类型的所有实例。下面的规则会匹配文档中所有的段落元素并且设置它们的字体大小为&lt;code&gt;2em&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p { font-size:2em; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;类选择器&lt;/h2&gt;

&lt;p&gt;类选择器是以一个句号“.”来表示的，并且用&lt;code&gt;class&lt;/code&gt;属性来定位目标元素。下面的规则将会应用到所有拥有“info”类名的&lt;code&gt;p&lt;/code&gt;元素：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p.info { background:#ff0; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以把多个类名赋给一个元素 - &lt;code&gt;class&lt;/code&gt;属性可以拥有以空格分割的类名列表。类选择器可以用来定位只拥有多个类名的元素。下面的规则将会匹配其类名列表中同时包含“info”和“error”的&lt;code&gt;p&lt;/code&gt;元素：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p.info.error { color:#900; font-weight:bold; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：多类选择器在当前版本的IE浏览器（译者注：IE6及以下版本）中不工作，但是在IE7中会被支持。&lt;/p&gt;

&lt;p&gt;元素类型没有必要必须指定。如果留空，那么其效果和使用通配选择器来代替类型选择器是一样的。下面的规则将会匹配任何拥有“info”类名的元素，不管它们的类型：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.info { background:#ff0; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;ID选择器&lt;/h2&gt;

&lt;p&gt;ID选择器是以hash符号“#”来表示的，并且用&lt;code&gt;id&lt;/code&gt;属性的值来定位目标元素。下面的规则将会应用到一个&lt;code&gt;id&lt;/code&gt;为“info”的元素，不管它们的类型是什么：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#info { background:#ff0; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你同时指定了一个元素类型，这个规则将会只应用到那个类型的元素上：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p#info { background:#ff0; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很重要的是请记住ID选择器比类选择器优先级更高，并且一个文档中的一个id值必须是唯一的。因此一个ID选择器只能应用到一个文档中的一个元素上。&lt;/p&gt;

&lt;h2&gt;待续&lt;/h2&gt;

&lt;p&gt;好了，以上就是这个系列文章的第一部分。在&lt;a href=&quot;/css-21-selectors-part-2.html&quot;&gt;第二部分&lt;/a&gt;中我将要带你们看看组合因子（combinators）, 组合选择器，分组，和属性选择器，然后第三部分我将会近距离的看一下伪类和伪元素。&lt;/p&gt;

&lt;p&gt;原文：&lt;a href=&quot;http://www.456bereastreet.com/archive/200509/css_21_selectors_part_1/&quot;&gt;http://www.456bereastreet.com/archive/200509/css_21_selectors_part_1/&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Node.js中exports与module.exports的区别</title>
   <link href="http://weizhifeng.net/node-js-exports-vs-module-exports.html"/>
   <updated>2013-05-18T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/node-js-exports-vs-module-exports</id>
   <content type="html">&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/tech/nodejs.jpg&quot; title=&quot;Node.js&quot; alt=&quot;Node.js&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;Node.js中exports和module.exports有什么不同？&lt;/h1&gt;

&lt;p&gt;你肯定对&lt;code&gt;Node.js&lt;/code&gt;模块中用来创建函数的&lt;code&gt;exports&lt;/code&gt;对象很熟悉（假设一个名为&lt;code&gt;rocker.js&lt;/code&gt;的文件）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exports.name = function() {
    console.log('My name is Lemmy Kilmister');
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后你在另一个文件中调用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var rocker = require('./rocker.js');
rocker.name(); // 'My name is Lemmy Kilmister'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是&lt;code&gt;module.exports&lt;/code&gt;到底是个什么玩意儿? 它合法吗？&lt;/p&gt;

&lt;p&gt;令人吃惊的是-&lt;code&gt;module.exports&lt;/code&gt;是真实存在的东西。&lt;code&gt;exports&lt;/code&gt;只是&lt;code&gt;module.exports&lt;/code&gt;的辅助方法。你的模块最终返回&lt;code&gt;module.exports&lt;/code&gt;给调用者，而不是&lt;code&gt;exports&lt;/code&gt;。&lt;code&gt;exports&lt;/code&gt;所做的事情是收集属性，如果&lt;code&gt;module.exports&lt;/code&gt;当前没有任何属性的话，&lt;code&gt;exports&lt;/code&gt;会把这些属性赋予&lt;code&gt;module.exports&lt;/code&gt;。如果&lt;code&gt;module.exports&lt;/code&gt;已经存在一些属性的话，那么&lt;code&gt;exports&lt;/code&gt;中所用的东西都会被忽略。&lt;/p&gt;

&lt;p&gt;把下面的内容放到&lt;code&gt;rocker.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports = 'ROCK IT!';
exports.name = function() {
    console.log('My name is Lemmy Kilmister');
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后把下面的内容放到另一个文件中，执行它：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var rocker = require('./rocker.js');
rocker.name(); // TypeError: Object ROCK IT! has no method 'name'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;rocker模块完全忽略了&lt;code&gt;exports.name&lt;/code&gt;，然后返回了一个字符串'ROCK IT!'。通过上面的例子，你可能认识到你的模块不一定非得是模块实例（module instances）。你的模块可以是任何合法的JavaScript对象 - boolean，number，date，JSON， string，function，array和其他。你的模块可以是任何你赋予&lt;code&gt;module.exports&lt;/code&gt;的值。如果你没有明确的给&lt;code&gt;module.exports&lt;/code&gt;设置任何值，那么&lt;code&gt;exports&lt;/code&gt;中的属性会被赋给&lt;code&gt;module.exports&lt;/code&gt;中，然后并返回它。&lt;/p&gt;

&lt;p&gt;在下面的情况下，你的模块是一个类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports = function(name, age) {
    this.name = name;
    this.age = age;
    this.about = function() {
        console.log(this.name +' is '+ this.age +' years old');
    };
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后你应该这样使用它：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Rocker = require('./rocker.js');
var r = new Rocker('Ozzy', 62);
r.about(); // Ozzy is 62 years old
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在下面的情况下，你的模块是一个数组：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports = ['Lemmy Kilmister', 'Ozzy Osbourne', 'Ronnie James Dio', 'Steven Tyler', 'Mick Jagger'];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后你应该这样使用它：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var rocker = require('./rocker.js');
console.log('Rockin in heaven: ' + rocker[2]); //Rockin in heaven: Ronnie James Dio
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在你应该找到要点了 - 如果你想要你的模块成为一个特别的对象类型，那么使用&lt;code&gt;module.exports&lt;/code&gt;；如果你希望你的模块成为一个传统的&lt;code&gt;模块实例&lt;/code&gt;（module instance），使用&lt;code&gt;exports&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;把属性赋予&lt;code&gt;module.exports&lt;/code&gt;的结果与把属性赋予给&lt;code&gt;exports&lt;/code&gt;是一样的。看下面这个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports.name = function() {
    console.log('My name is Lemmy Kilmister');
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面这个做的是一样的事情：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exports.name = function() {
    console.log('My name is Lemmy Kilmister');
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是请注意，它们并不是一样的东西。就像我之前说的&lt;code&gt;module.exports&lt;/code&gt;是真实存在的东西，&lt;code&gt;exports&lt;/code&gt;只是它的辅助方法。话虽如此，&lt;code&gt;exports&lt;/code&gt;还是推荐的对象，除非你想把你模块
的对象类型从传统的&lt;code&gt;模块实例&lt;/code&gt;（module instance）修改为其他的。&lt;/p&gt;

&lt;p&gt;我希望这篇文章能帮助你理解&lt;code&gt;exports&lt;/code&gt;和&lt;code&gt;module.exports&lt;/code&gt;之间的不同，并且能进一步的理解模块在&lt;code&gt;Node.js&lt;/code&gt;中是怎么工作的。如果有任何问题，请在回复里边留言。&lt;/p&gt;

&lt;p&gt;原文：&lt;a href=&quot;http://www.hacksparrow.com/node-js-exports-vs-module-exports.html&quot;&gt;http://www.hacksparrow.com/node-js-exports-vs-module-exports.html&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>過後湖</title>
   <link href="http://weizhifeng.net/guohouhu.html"/>
   <updated>2013-05-09T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/guohouhu</id>
   <content type="html">&lt;p&gt;雨落舊城濕&lt;br/&gt;
風起動蓮池&lt;br/&gt;
只身過後湖&lt;br/&gt;
煙雨不相知&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/poem/houhu-large.jpg&quot;&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/poem/houhu.jpg&quot; title=&quot;过后湖&quot; alt=&quot;过后湖&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>在越狱iPhone上进行Xcode调试</title>
   <link href="http://weizhifeng.net/xcode-debug-on-jailbreak-iphone.html"/>
   <updated>2013-04-30T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/xcode-debug-on-jailbreak-iphone</id>
   <content type="html">&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/tech/xcode.jpg&quot; title=&quot;Xcode&quot; alt=&quot;Xcode&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;说明&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/programs/ios/&quot;&gt;苹果开发者认证&lt;/a&gt;每年&lt;code&gt;$99&lt;/code&gt;，对于一个初学者和票友来说暂时没必要买，但是又想在真机上进行调试，那么只能hack了，网上相关中文资料很多，但是都有些过时，版本太老，遂总结一篇。&lt;/p&gt;

&lt;p&gt;本文在以下环境下测试通过：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;XCode：Version 4.6.1 (4H512)&lt;/li&gt;
&lt;li&gt;IOS SDK：6.1&lt;/li&gt;
&lt;li&gt;iPhone：IOS 6.1(Jail Break)&lt;/li&gt;
&lt;li&gt;Mac OS X：10.8.3 Mountain Lion&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;修改SDKSettings.plist&lt;/h1&gt;

&lt;p&gt;首先进入以下目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS6.1.sdk
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在修改之前，先备份一下SDKSettings.plist：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo cp SDKSettings.plist SDKSettings.plist.bak
$ sudo vi SDKSettings.plist
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改&lt;code&gt;CODE_SIGNING_REQUIRED&lt;/code&gt;和&lt;code&gt;ENTITLEMENTS_REQUIRED&lt;/code&gt;这两个配置的值从&lt;code&gt;YES&lt;/code&gt;修改为&lt;code&gt;NO&lt;/code&gt;。&lt;/p&gt;

&lt;h1&gt;创建签名证书&lt;/h1&gt;

&lt;p&gt;首先打开&lt;code&gt;钥匙串访问&lt;/code&gt;应用，然后打开&lt;code&gt;钥匙串访问-&amp;gt;证书助理-&amp;gt;创建证书&lt;/code&gt;开始创建证书，
注意要保证证书名称为&lt;code&gt;iPhone Developer&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/xcode/01.png&quot; title=&quot;01&quot; alt=&quot;01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击继续：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/xcode/02.png&quot; title=&quot;02&quot; alt=&quot;02&quot; /&gt;&lt;/p&gt;

&lt;p&gt;添加邮箱：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/xcode/03.png&quot; title=&quot;03&quot; alt=&quot;03&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击继续，勾选&lt;code&gt;签名&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/xcode/04.png&quot; title=&quot;04&quot; alt=&quot;04&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击继续，勾选&lt;code&gt;代码签名&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/xcode/05.png&quot; title=&quot;05&quot; alt=&quot;05&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后一路点击「继续」就可以了。&lt;/p&gt;

&lt;h1&gt;Xcode&lt;/h1&gt;

&lt;p&gt;打开&lt;code&gt;Xcode&lt;/code&gt;，选择&lt;code&gt;TARGETS&lt;/code&gt;中的&lt;code&gt;Build Settings&lt;/code&gt;选项卡，然后在&lt;code&gt;Code Signing&lt;/code&gt;中选择我们刚创建的证书&lt;code&gt;iPhone Developer&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/xcode/06.png&quot; title=&quot;06&quot; alt=&quot;06&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后选择&lt;code&gt;Summary&lt;/code&gt;选项卡，勾选&lt;code&gt;Use Entitlements File&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/xcode/07.png&quot; title=&quot;07&quot; alt=&quot;07&quot; /&gt;&lt;/p&gt;

&lt;p&gt;选中刚生成的&lt;code&gt;.entitlements&lt;/code&gt;文件（不同的项目名称，生成的文件名不一样）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/xcode/08.png&quot; title=&quot;08&quot; alt=&quot;08&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在文件中添加一个名为&lt;code&gt;get-task-allow&lt;/code&gt;的配置项，类型为&lt;code&gt;Boolean&lt;/code&gt;，值为&lt;code&gt;YES&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/xcode/09.png&quot; title=&quot;09&quot; alt=&quot;09&quot; /&gt;&lt;/p&gt;

&lt;p&gt;重启&lt;code&gt;Xcode&lt;/code&gt;&lt;/p&gt;

&lt;h1&gt;安装Appsync&lt;/h1&gt;

&lt;p&gt;首先确保你的iPhone已经越狱，打开&lt;code&gt;Cydia&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/xcode/10.png&quot; title=&quot;10&quot; alt=&quot;10&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后打开&lt;code&gt;管理-&amp;gt;编辑-&amp;gt;添加&lt;/code&gt;，添加源&lt;code&gt;http://repo.hackyouriphone.org/&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/xcode/11.png&quot; title=&quot;11&quot; alt=&quot;11&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可能会提示源有问题，点击&lt;code&gt;仍然添加&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/xcode/12.png&quot; title=&quot;12&quot; alt=&quot;12&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后搜索&lt;code&gt;appsync&lt;/code&gt;，安装&lt;code&gt;AppSync fo IOS 6&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/xcode/13.png&quot; title=&quot;13&quot; alt=&quot;13&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;调试&lt;/h1&gt;

&lt;p&gt;选择&lt;code&gt;IOS Device&lt;/code&gt;进行调试：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/xcode/14.png&quot; title=&quot;14&quot; alt=&quot;14&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后你就可以在自己的真机上调试了，Enjoy Coding　：）&lt;/p&gt;

&lt;h1&gt;参考&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/15354719/code-sign-error-with-xcode4-6-on-jailbroken-device&quot;&gt;http://stackoverflow.com/questions/15354719/code-sign-error-with-xcode4-6-on-jailbroken-device&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/10842595/developing-with-jailbroken-iphone-xcode&quot;&gt;http://stackoverflow.com/questions/10842595/developing-with-jailbroken-iphone-xcode&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>微信API For Node.js</title>
   <link href="http://weizhifeng.net/weixin-with-node.js.html"/>
   <updated>2013-04-14T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/weixin-with-node.js</id>
   <content type="html">&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/tech/nodejs.jpg&quot; title=&quot;Node.js&quot; alt=&quot;Node.js&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;介绍&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;weixin-api&lt;/code&gt;是对微信公众平台&lt;a href=&quot;http://mp.weixin.qq.com/wiki/index.php?title=%E6%B6%88%E6%81%AF%E6%8E%A5%E5%8F%A3%E6%8C%87%E5%8D%97&quot;&gt;消息接口&lt;/a&gt;的Node.js实现。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;NPM：&lt;a href=&quot;https://npmjs.org/package/weixin-api&quot;&gt;https://npmjs.org/package/weixin-api&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Github：&lt;a href=&quot;https://github.com/JeremyWei/weixin_api&quot;&gt;https://github.com/JeremyWei/weixin_api&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;安装&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ npm install weixin-api
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;功能&lt;/h1&gt;

&lt;h3&gt;消息监听&lt;/h3&gt;

&lt;p&gt;根据微信公众平台的API规范，对四种消息进行监听，通过传递&lt;code&gt;callback&lt;/code&gt;来对消息进行处理，其中callback只有一个参数&lt;code&gt;msg&lt;/code&gt;，不同消息其&lt;code&gt;msg&lt;/code&gt;内容不同，各属性代表的含义请对照微信公众平台的API规范。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;textMsg(function(msg) {})&lt;/code&gt;&lt;br/&gt;
说明：监听文本消息&lt;br/&gt;
msg结构：&lt;br/&gt;
    {&lt;br/&gt;
        toUserName : '',
        fromUserName : '',
        createTime : '',
        msgType : 'text',
        content : '',
        msgId : ''
    }&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;imageMsg(function(msg) {})&lt;/code&gt;&lt;br/&gt;
说明：监听图片消息&lt;br/&gt;
msg结构：&lt;br/&gt;
    {&lt;br/&gt;
        toUserName : '',
        fromUserName : '',
        createTime : '',
        msgType : 'image',
        picUrl : '',
        msgId : ''
    }&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;locationMsg(function(msg) {})&lt;/code&gt;&lt;br/&gt;
说明：监听位置信息&lt;br/&gt;
msg结构：&lt;br/&gt;
    {&lt;br/&gt;
        toUserName : '',
        fromUserName : '',
        createTime : '',
        msgType : 'location',
        locationX : '',
        locationY : '',
        scale : '',
        label : '',
        msgId : ''
    }&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;urlMsg(function(msg) {})&lt;/code&gt;&lt;br/&gt;
 说明：监听链接信息&lt;br/&gt;
 msg结构：&lt;br/&gt;
     {&lt;br/&gt;
         toUserName : &quot;&quot;,
         fromUserName : &quot;&quot;,
         createTime : &quot;&quot;,
         msgType : &quot;link&quot;,
         title : &quot;&quot;,
         description : &quot;&quot;
         url : &quot;&quot;
         msgId : &quot;&quot;
     }&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;eventMsg(function(msg) {})&lt;/code&gt;&lt;br/&gt;
 说明：监听事件信息&lt;br/&gt;
 msg结构：&lt;br/&gt;
     {&lt;br/&gt;
         toUserName : &quot;&quot;,
         fromUserName : &quot;&quot;,
         createTime : &quot;&quot;,
         msgType : &quot;event&quot;,
         event : &quot;&quot;,
         eventKey : &quot;&quot;
     }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;消息回复&lt;/h3&gt;

&lt;p&gt;消息的回复统一使用&lt;code&gt;sendMsg(msg)&lt;/code&gt;方法，其中&lt;code&gt;msg&lt;/code&gt;可以为以下内容：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;回复文本消息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  var msg = {
      fromUserName : &quot;&quot;,
      toUserName : &quot;&quot;,
      msgType : &quot;text&quot;,
      content : &quot;(╯°□°）╯︵ ┻━┻&quot;,
      funcFlag : 0
  };
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;回复音乐消息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  var msg = {
      fromUserName : &quot;&quot;,
      toUserName : &quot;&quot;,
      msgType : &quot;music&quot;,
      title : &quot;向往&quot;,
      description : &quot;李健《向往》&quot;,
      musicUrl : &quot;&quot;,
      HQMusicUrl : &quot;&quot;,
      funcFlag : 0
  };
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;回复图文消息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  var articles = [];
  articles[0] = {
      title : &quot;PHP依赖管理工具Composer入门&quot;,
      description : &quot;PHP依赖管理工具Composer入门&quot;,
      picUrl : &quot;http://weizhifeng.net/images/tech/composer.png&quot;,
      url : &quot;http://weizhifeng.net/manage-php-dependency-with-composer.html&quot;
  };

  articles[1] = {
      title : &quot;八月西湖&quot;,
      description : &quot;八月西湖&quot;,
      picUrl : &quot;http://weizhifeng.net/images/poem/bayuexihu.jpg&quot;,
      url : &quot;http://weizhifeng.net/bayuexihu.html&quot;
  };

  articles[2] = {
      title : &quot;「翻译」Redis协议&quot;,
      description : &quot;「翻译」Redis协议&quot;,
      picUrl : &quot;http://weizhifeng.net/images/tech/redis.png&quot;,
      url : &quot;http://weizhifeng.net/redis-protocol.html&quot;
  };

  // 返回图文消息
  var msg = {
      fromUserName : &quot;&quot;,
      toUserName : &quot;&quot;,
      msgType : &quot;news&quot;,
      articles : articles,
      funcFlag : 0
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;示例&lt;/h1&gt;

&lt;p&gt;我们使用&lt;a href=&quot;http://expressjs.com/&quot;&gt;express&lt;/a&gt;来创建一个简单的微信应用&lt;/p&gt;

&lt;h2&gt;安装express&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ npm install express -g
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;创建应用&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ express myweixin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;cd myweixin&lt;/code&gt;修改&lt;code&gt;package.json&lt;/code&gt;，添加对weixin-api的依赖：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &quot;name&quot;: &quot;application-name&quot;,
  &quot;version&quot;: &quot;0.0.1&quot;,
  &quot;private&quot;: true,
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;node app.js&quot;
  },
  &quot;dependencies&quot;: {
    &quot;express&quot;: &quot;3.1.1&quot;,
    &quot;jade&quot;: &quot;*&quot;,
    &quot;xml2js&quot; : &quot;0.2.6&quot;,
    &quot;weixin-api&quot; : &quot;*&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后执行&lt;code&gt;npm install&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;app.js&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var express = require('express'),
    weixin = require('weixin-api'),
    app = express();

// 解析器
app.use(express.bodyParser());

// 接入验证
app.get('/', function(req, res) {

    // 签名成功
    if (weixin.checkSignature(req)) {
        res.send(200, req.query.echostr);
    } else {
        res.send(200, 'fail');
    }
});

// config
weixin.token = '你的token';

// 监听文本消息
weixin.textMsg(function(msg) {
    console.log(&quot;textMsg received&quot;);
    console.log(JSON.stringify(msg));

    var resMsg = {};

    switch (msg.content) {
        case &quot;文本&quot; :
            resMsg = {
                fromUserName : msg.toUserName,
                toUserName : msg.fromUserName,
                msgType : &quot;text&quot;,
                content : &quot;(╯°□°）╯︵ ┻━┻&quot;,
                funcFlag : 0
            };
            break;

        case &quot;音乐&quot; :
            resMsg = {
                fromUserName : msg.toUserName,
                toUserName : msg.fromUserName,
                msgType : &quot;music&quot;,
                title : &quot;向往&quot;,
                description : &quot;李健《向往》&quot;,
                musicUrl : &quot;&quot;,
                HQMusicUrl : &quot;&quot;,
                funcFlag : 0
            };
            break;

        case &quot;图文&quot; :

            var articles = [];
            articles[0] = {
                title : &quot;PHP依赖管理工具Composer入门&quot;,
                description : &quot;PHP依赖管理工具Composer入门&quot;,
                picUrl : &quot;http://weizhifeng.net/images/tech/composer.png&quot;,
                url : &quot;http://weizhifeng.net/manage-php-dependency-with-composer.html&quot;
            };

            articles[1] = {
                title : &quot;八月西湖&quot;,
                description : &quot;八月西湖&quot;,
                picUrl : &quot;http://weizhifeng.net/images/poem/bayuexihu.jpg&quot;,
                url : &quot;http://weizhifeng.net/bayuexihu.html&quot;
            };

            articles[2] = {
                title : &quot;「翻译」Redis协议&quot;,
                description : &quot;「翻译」Redis协议&quot;,
                picUrl : &quot;http://weizhifeng.net/images/tech/redis.png&quot;,
                url : &quot;http://weizhifeng.net/redis-protocol.html&quot;
            };

            // 返回图文消息
            resMsg = {
                fromUserName : msg.toUserName,
                toUserName : msg.fromUserName,
                msgType : &quot;news&quot;,
                articles : articles,
                funcFlag : 0
            }
    }

    weixin.sendMsg(resMsg);
});

// 监听图片消息
weixin.imageMsg(function(msg) {
    //
    console.log(&quot;imageMsg received&quot;);
    console.log(JSON.stringify(msg));
});

// 监听位置消息
weixin.locationMsg(function(msg) {
    //
    console.log(&quot;locationMsg received&quot;);
    console.log(JSON.stringify(msg));
});

// 监听链接消息
weixin.urlMsg(function(msg) {
    //
    console.log(&quot;urlMsg received&quot;);
    console.log(JSON.stringify(msg));
});

// Start
app.post('/', function(req, res) {

    // loop
    weixin.loop(req, res);

});

app.listen(3000);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;启动&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ cd myweixin 
$ node app.js
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;结尾&lt;/h1&gt;

&lt;p&gt;这个package还有很多不完善的地方，欢迎fork，：）&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PHP依赖管理工具Composer入门</title>
   <link href="http://weizhifeng.net/manage-php-dependency-with-composer.html"/>
   <updated>2013-04-05T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/manage-php-dependency-with-composer</id>
   <content type="html">&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/tech/composer.png&quot; title=&quot;Composer&quot; alt=&quot;Composer&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;介绍&lt;/h1&gt;

&lt;p&gt;Composer是PHP中的一个依赖管理工具. 它可以让你声明自己项目所依赖的库，然后它将会在项目中为你安装这些库。&lt;/p&gt;

&lt;h2&gt;依赖管理&lt;/h2&gt;

&lt;p&gt;Composer不是包管理器。是的，它实际上和&quot;包&quot;或者库打交道，但是它是以项目为单位进行管理，把它们安装到你项目中的一个目录（例如&lt;code&gt;vendor&lt;/code&gt;）。默认情况下它不会以全局的方式安装任何东西。因此，它是一个依赖管理器。&lt;/p&gt;

&lt;p&gt;这个想法并不新鲜，Composer的灵感是来自于node的&lt;a href=&quot;http://npmjs.org/&quot;&gt;npm&lt;/a&gt;和ruby的&lt;a href=&quot;http://gembundler.com/&quot;&gt;bundler&lt;/a&gt;。但是目前PHP还没有一个这样的工具。&lt;/p&gt;

&lt;p&gt;Composer解决的问题是：&lt;/p&gt;

&lt;p&gt;a) 你有一个依赖N多库的项目。&lt;/p&gt;

&lt;p&gt;b) 这些库中一些又依赖于其他的库。&lt;/p&gt;

&lt;p&gt;c) 你声明你所依赖的库。&lt;/p&gt;

&lt;p&gt;d) Composer找出哪些包的哪个版本将会被安装，然后安装它们（也就是把它们下载到你的项目中）。&lt;/p&gt;

&lt;h2&gt;声明依赖关系&lt;/h2&gt;

&lt;p&gt;假设你正在创建一个项目，然后你需要一个日志操作的库。你决定使用&lt;a href=&quot;https://github.com/Seldaek/monolog&quot;&gt;monolog&lt;/a&gt;。为了把它加入到你的项目中，你需要做的就是创建一个名为&lt;code&gt;composer.json&lt;/code&gt;的文件，其描述这个项目的依赖关系。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &quot;require&quot;: {
        &quot;monolog/monolog&quot;: &quot;1.2.*&quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们简单的描述说我们的项目依赖某个&lt;code&gt;monolog/monolog&lt;/code&gt;包，版本只要是以&lt;code&gt;1.2&lt;/code&gt;开头的就行。&lt;/p&gt;

&lt;h2&gt;系统要求&lt;/h2&gt;

&lt;p&gt;Composer需要PHP 5.3.2+才能运行。一些灵敏的PHP设置和编译选项也是必须的，不过安装程序（installer）会警告你任何不兼容的地方。&lt;/p&gt;

&lt;p&gt;如果想要从源码而不是简单的从zip压缩包中安装软件包的话，你将需要git，svn或者hg，这依赖于软件包是通过什么进行版本控制的。&lt;/p&gt;

&lt;p&gt;Composer是兼容多平台的，并且我们力争使其在Windows，Linux和OSX上的运行无差异。&lt;/p&gt;

&lt;h2&gt;安装 - *nix&lt;/h2&gt;

&lt;h3&gt;下载Composer可执行程序&lt;/h3&gt;

&lt;h4&gt;局部安装&lt;/h4&gt;

&lt;p&gt;为了获取Composer，我们需要做两件事。第一个是安装Composer（前面说过了，这意味下载它到你的项目中）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -sS https://getcomposer.org/installer | php
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这只会检查一些PHP设置，然后下载&lt;code&gt;composer.phar&lt;/code&gt;到你的工作目录中。这个文件是Composer二进制文件。它是一个PHAR (PHP
archive)，PHP的归档格式，也可以像其他命令一样在命令行上运行。&lt;/p&gt;

&lt;p&gt;你可以使用&lt;code&gt;--install-dir&lt;/code&gt;选项，并且提供一个目标目录（可以是绝对或者相对路径）从而把Composer安装到一个指定的目录：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -sS https://getcomposer.org/installer | php -- --install-dir=bin
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;全局安装&lt;/h4&gt;

&lt;p&gt;你可以把这个文件放到任何你想放的地方。如果你把它放到你的&lt;code&gt;PATH&lt;/code&gt;中，你就可以全局访问它了。在类unix系统中你甚至可以使它可执行，并且调用的时候不需要&lt;code&gt;php&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;你可以执行这些命令从而能够在你的系统上简单的访问&lt;code&gt;composer&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -sS https://getcomposer.org/installer | php
$ sudo mv composer.phar /usr/local/bin/composer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，只需要执行&lt;code&gt;composer&lt;/code&gt;命令来运行Composer，而不是&lt;code&gt;php composer.phar&lt;/code&gt;。&lt;/p&gt;

&lt;h2&gt;安装 - Windows&lt;/h2&gt;

&lt;h3&gt;使用安装程序&lt;/h3&gt;

&lt;p&gt;这是在你的机器上安装Composer最简单的方法。&lt;/p&gt;

&lt;p&gt;下载并运行&lt;a href=&quot;https://getcomposer.org/Composer-Setup.exe&quot;&gt;Composer-Setup.exe&lt;/a&gt;，它将会安装最新的Composer版本并且设置好PATH，然后你就可以在命令中的任何目录下调用&lt;code&gt;composer&lt;/code&gt;了。&lt;/p&gt;

&lt;h3&gt;手动安装&lt;/h3&gt;

&lt;p&gt;切换到一个存在于&lt;code&gt;PATH&lt;/code&gt;环境变量中的目录，然后执行安装代码片段来下载composer.phar：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\Users\username&amp;gt;cd C:\bin
C:\bin&amp;gt;php -r &quot;eval('?&amp;gt;'.file_get_contents('https://getcomposer.org/installer'));&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建一个新的以&lt;code&gt;.bat&lt;/code&gt;结尾的composer文件:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\bin&amp;gt;echo @php &quot;%~dp0composer.phar&quot; %*&amp;gt;composer.bat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关闭你当前的终端。打开一个新的终端测试一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\Users\username&amp;gt;composer -V
Composer version 27d8904

C:\Users\username&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;使用Composer&lt;/h2&gt;

&lt;p&gt;我们接下来要使用Composer来安装项目的依赖。如果你在当前目录下没有一个叫作&lt;code&gt;composer.json&lt;/code&gt;的文件，请跳到&lt;a href=&quot;http://getcomposer.org/doc/01-basic-usage.md&quot;&gt;基本使用&lt;/a&gt;章节。&lt;/p&gt;

&lt;p&gt;为了解决并下载依赖，运行&lt;code&gt;install&lt;/code&gt;命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ php composer.phar install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你是全局安装，并且目录下没有phar文件，那么运行这个：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ composer install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是&lt;a href=&quot;#declaring-dependencies&quot;&gt;上面的例子&lt;/a&gt;，这个操作将会下载monolog到&lt;code&gt;vendor/monolog/monolog&lt;/code&gt;目录。&lt;/p&gt;

&lt;h2&gt;自动加载&lt;/h2&gt;

&lt;p&gt;除了下载库之外，Composer也会创建一个自动加载文件，这个文件能够自动加载Composer下载的库中所有的类。如果想使用它，只需要在你代码启动的地方加上如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require 'vendor/autoload.php';
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;哇哦！现在开始使用monolog吧! 如果想进一步学习Composer，继续阅读「基本使用」章节。
如果想要找需要的package，到&lt;a href=&quot;https://packagist.org/&quot;&gt;Packagist&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;英文原文：&lt;a href=&quot;http://getcomposer.org/doc/00-intro.md&quot;&gt;http://getcomposer.org/doc/00-intro.md&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>JavaScript Prototype</title>
   <link href="http://weizhifeng.net/javascript-prototype.html"/>
   <updated>2013-02-03T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/javascript-prototype</id>
   <content type="html">&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;JavaScript做为一门前端开发语言越来越受到关注，对于后端开发者（JAVA，C++，PHP等）来说想要掌握JavaScript，其中最容易出现问题的地方就是对象模型以及原型链继承模型，本文作者根据自身的经验和理解，对JavaScript的对象和&lt;strong&gt;prototype&lt;/strong&gt;（原型）进行介绍。&lt;/p&gt;

&lt;h2&gt;对象&lt;/h2&gt;

&lt;p&gt;在JavaScript中数据类型分为原生数据类型（Primitive type 其中包括数字，字符串，布尔，undefined，null）和对象（Object）。注意不要把&lt;strong&gt;String&lt;/strong&gt;，&lt;strong&gt;Number&lt;/strong&gt;，&lt;strong&gt;Boolean&lt;/strong&gt;等包装对象与原生类型混淆，看下面的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var string = &quot;string&quot;;
console.log(typeof string); //string

string = new String(&quot;string&quot;);
console.log(typeof string); //object
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在JavaScript中不存在类的概念，所有的东西都是对象，这对于初次接触JavaScript的开发者来说会有些难理解，但是等你熟悉了这个模型之后就会发觉这么设计的简单与优雅。如果你想要快速创建一个对象，那么如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var book = {name: &quot;JavaScript Good Parts&quot;}
console.log(book.name); // JavaScript Good Parts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要在JavaScript中创建一个自定义对象，那么首先需要创建构造函数（Constructor，与JAVA类中的构造函数不是一个概念），一个构造函数就是一个函数对象（在里边定义对象的属性），你可以通过function关键词来创建构造函数，也可以使用全局对象Function（注意Function是运行环境中预定义的对象）来创建。构造函数创建之后，就可以使用new操作符后面紧跟构造函数的形式（new functionName()）来创建对象，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 使用function关键词
function Book() {
    this.name = &quot;JavaScript Good Parts&quot;;
}

// 效果与上面一样
var Book = function() {
    this.name = &quot;JavaScript Good Parts&quot;;
}

var book = new Book();  // create Object
console.log(book.name); // JavaScript Good Parts

// 使用Function全局对象
var Book = new Function(&quot;this.name = 'JavaScript Good Parts 2';&quot;);

var book = new Book();  // create Object
console.log(book.name); // JavaScript Good Parts2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaScript环境中预先定义了很多&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Predefined_Core_Objects&quot;&gt;全局对象&lt;/a&gt;，其中包括：&lt;strong&gt;Function&lt;/strong&gt;，&lt;strong&gt;Object&lt;/strong&gt;，
&lt;strong&gt;Array&lt;/strong&gt;，&lt;strong&gt;Boolean&lt;/strong&gt;，&lt;strong&gt;Date&lt;/strong&gt;，&lt;strong&gt;Number&lt;/strong&gt;，&lt;strong&gt;String&lt;/strong&gt;，&lt;strong&gt;RegExp&lt;/strong&gt;，&lt;strong&gt;Math&lt;/strong&gt;。&lt;/p&gt;

&lt;h2&gt;原型&lt;/h2&gt;

&lt;p&gt;有了对象，那么我们就需要继承，这也是OOP的精华所在，在JAVA,C++等OO的语言中继承是在定义类的时候进行指定的，既然JavaScript中没有类的概念，那么其实现继承的方式需要与众不同了，对，这就是接下来的重点内容：&lt;strong&gt;Prototype&lt;/strong&gt;（原型）。&lt;/p&gt;

&lt;p&gt;根据我们上面的介绍，知道JavaScript中没有类，只有对象，那么怎么进行继承呢？在JavaScript中，为了实现继承，其在全局对象（除了Math）中加入了&lt;strong&gt;prototype&lt;/strong&gt;对象属性，用户可以把能够复用的行为放在&lt;strong&gt;prototype&lt;/strong&gt;对象之中，可以把&lt;strong&gt;prototype&lt;/strong&gt;看成是一个对象的模板，看如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// constructor
function Book(name, price) {
    this.name = name;
    this.price = price;
}

// 在prototype中添加print函数
Book.prototype.print = function(){
    console.log(&quot;name: &quot; + this.name + &quot;    price: &quot; + this.price);
};

// 创建对象
var book = new Book(&quot;JavaScript Good Parts&quot;, &quot;35.00元&quot;);
var book2 = new Book(&quot;JavaScript权威指南 第6版&quot;, &quot;128.00元&quot;);

// 输出书籍信息
book.print();  //name: JavaScript Good Parts    price: 35.00元
book2.print(); //name: JavaScript权威指南 第6版    price: 128.00元
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在以上的例子中book，book2两个对象并没有print函数，但是却输出了书籍信息，这是因为其连接到了&lt;strong&gt;Book.prototype&lt;/strong&gt;对象，从而继承了其中的print函数，这就是JavaScript中实现继承的方式。&lt;/p&gt;

&lt;p&gt;如果我们需要为Book对象添加一个通用属性（type，用以标识书籍种类），那么添加如下代码（prototype对象是运行时绑定，所以如下代码可以正常运行）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Book.prototype.type = &quot;JavaScript&quot;;

console.log(book.type); // JavaScript
console.log(book2.type); // JavaScript
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看过以上的例子之后，我们在看下JavaScript的原型链是如何工作的，看如下的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// constructor
function Book(name, price) {
    this.name = name;
    this.price = price;
}

// prototype对象
Book.prototype = {
    type: &quot;JavaScript (defined in prototype)&quot;
};

// 创建对象
var book = new Book(&quot;JavaScript Good Parts&quot;, &quot;35.00元&quot;);
console.log(book.type) // JavaScript (defined in prototype)

var book2 = new Book(&quot;JavaScript权威指南 第6版&quot;, &quot;128.00元&quot;);
book2.type = &quot;JavaScript (defined by self)&quot;;
console.log(book2.type) // JavaScript (defined by self)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;book对象并没有定义type属性，所以其输出是来自prototype对象，book2对象显示定义了type属性，其输出的是自身信息。&lt;/p&gt;

&lt;p&gt;在&lt;strong&gt;prototype&lt;/strong&gt;模型中，如果一个对象试图访问一个属性，那么JavaScript先去对象本身中查找，如果存在则返回；如果不存在，那么去对象连接到的&lt;strong&gt;prototype&lt;/strong&gt;对象中查找，如果存在返回属性值，不存在则返回&lt;strong&gt;undefined&lt;/strong&gt;。逻辑如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (对象拥有此属性) {
    // 返回属性值
} else {
    // 去Book.prototype查找
    if (Book.prototype中存在此属性) {
        // 返回属性值  
    } else {
        // 返回undefined
    }
}

+--------------+
|Book.prototype|
+--------------+
   ^        ^
   |        |
+-----+  +------+
| book|  | book2|
+-----+  +------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaScript中提供了一个函数&lt;strong&gt;hasOwnProperty&lt;/strong&gt;来检测属性是来自对象本身还是从prototype中继承来的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var book = new Book(&quot;JavaScript Good Parts&quot;, &quot;35.00元&quot;);
console.log(book.hasOwnProperty(&quot;type&quot;)) // false

var book2 = new Book(&quot;JavaScript权威指南 第6版&quot;, &quot;128.00元&quot;);
book2.type = &quot;JavaScript (defined by self)&quot;;
console.log(book2.hasOwnProperty(&quot;type&quot;)) // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来我们来看下在JavaScript中整个原型链是如何工作的。JavaScript的每个对象都会有一个&lt;strong&gt;__proto__&lt;/strong&gt;属性，用来指定对象连接到的原型对象，看个简单的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// constructor
function Book(name, price) {
    this.name = name;
    this.price = price;
}

// 创建对象
var book = new Book(&quot;JavaScript Good Parts&quot;, &quot;35.00元&quot;);

// 因为book是通过构造函数Book创建的，其连接到的原型是Book.prototype，
// 所以以下输出为true
console.log(book.__proto__ === Book.prototype) //true

// Book.prototype.__proto__的值指向Object.prototype
console.log(Book.prototype.__proto__ === Object.prototype) // true
console.log(book.__proto__.__proto__ === Object.prototype); // true

// Object.prototype是原型链的终点
console.log(Object.prototype.__proto__); //null
console.log(book.__proto__.__proto__.__proto__); // null
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下是原型链示意图：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        book              Book.prototype      Object.prototype
  +---------------+     +---------------+     +---------------+
  | +-----------+ |     | +-----------+ |     | +-----------+ |
  | | __proto__ |-----&amp;gt; | | __proto__ |-----&amp;gt; | | __proto__ |-----&amp;gt; null
  | +-----------+ |     | +-----------+ |     | +-----------+ |
  +---------------+     +---------------+     +---------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上文字，随感而发，如有纰漏，敬请见谅。&lt;/p&gt;

&lt;h2&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/&quot;&gt;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>把Dropbox改造为Git私有仓库</title>
   <link href="http://weizhifeng.net/git-with-dropbox.html"/>
   <updated>2012-11-24T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/git-with-dropbox</id>
   <content type="html">&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/tech/git.jpg&quot; title=&quot;Git&quot; alt=&quot;Git&quot; /&gt; &lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/tech/dropbox.jpg&quot; title=&quot;Dropbox&quot; alt=&quot;Dropbox&quot; /&gt;　&lt;/p&gt;

&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://git-scm.com/&quot; title=&quot;Git&quot;&gt;Git&lt;/a&gt;作为强大的分布式版本控制工具，越来越受欢迎。大量的开源项目可以在&lt;a href=&quot;https://github.com&quot; title=&quot;Github&quot;&gt;Github&lt;/a&gt;上发布，不过项目是公共可见的，即人人可以fork。
对于一些用户，他们也有自己的项目，但是还不太想立刻就把项目开源出来，有可能是因为还没有完成，所以他们需要通过Git临时性地管理他们的「私有项目」，Github上虽然有私有项目托管服务，不过性价比不高。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.dropbox.com/&quot; title=&quot;Dropbox&quot;&gt;Dropbox&lt;/a&gt;（墙）是最流行的云存储服务，通过Dropbox我们可以实现对Git私有项目的托管。&lt;/p&gt;

&lt;h2&gt;思路&lt;/h2&gt;

&lt;p&gt;我们的思路是在Dropbox客户端的目录中建立Git仓库，然后我们clone此仓库到本地仓库，然后我们进行提交操作，完成提交之后，我们执行push操作，
那么本地的数据会被push到Dropbox客户端目录的仓库中，之后Dropbox客户端会把仓库文件的更改同步到Dropbox服务器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+------------+            +-----------+              +---------+
|  Dropbox   |  --Sync-&amp;gt;  |  Dropbox  |   --Clone-&amp;gt;  | Working |
|   Server   |  &amp;lt;-Sync--  |   Client  |   &amp;lt;-Push---  |  Space  |
+------------+            +-----------+              +---------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;实现&lt;/h2&gt;

&lt;p&gt;我们现在Dropbox的目录中创建一个裸git仓库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd ~/Dropbox
$ git init --bare project.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完成之后，我们clone这个仓库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd ~
$ git clone ~/Dropbox/project.git project
$ cd project
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;提交并且push&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ touch README
$ git add .
$ git commit -m &quot;init commit&quot;
$ git push origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完成之后，Dropbox会把你push的内容同步到服务器，你通过&lt;a href=&quot;https://www.dropbox.com/&quot;&gt;https://www.dropbox.com/&lt;/a&gt;可以查看到仓库的内容。&lt;/p&gt;

&lt;h2&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/1960799/using-gitdropbox-together-effectively&quot;&gt;http://stackoverflow.com/questions/1960799/using-gitdropbox-together-effectively&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Ruby On Rails环境搭建</title>
   <link href="http://weizhifeng.net/ruby-on-rails.html"/>
   <updated>2012-09-23T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/ruby-on-rails</id>
   <content type="html">&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/tech/rails.png&quot; title=&quot;Ruby On Rails&quot; alt=&quot;Ruby On Rails&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://rubyonrails.org/&quot; title=&quot;Ruby On Rails&quot;&gt;Ruby On Rails&lt;/a&gt;是最流行和体验最好的敏捷开发WEB框架（没有之一），介绍性的内容这里就不赘述了。本文介绍下Ruby On Rails环境的搭建流程。&lt;/p&gt;

&lt;p&gt;环境如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;操作系统采用&lt;a href=&quot;http://releases.ubuntu.com/12.04/&quot; title=&quot;Ubuntu 12.04.1 LTS (Precise Pangolin)&quot;&gt;Ubuntu 12.04.1 LTS (Precise Pangolin)&lt;/a&gt; Server Editon&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruby-lang.org/en/&quot; title=&quot;Ruby&quot;&gt;Ruby&lt;/a&gt;版本为1.9.3-p0&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://rubyonrails.org/&quot; title=&quot;Ruby On Rails&quot;&gt;Rails&lt;/a&gt;为3.2.8&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;默认情况下Ubuntu有很多库和软件没有安装，我们首先安装一下所需要的库：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get upgrade
$ sudo apt-get install build-essential libssl-dev libreadline-gplv2-dev \
  lib64readline-gplv2-dev zlib1g zlib1g-dev libyaml-dev libsqlite3-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;安装Ruby&lt;/h2&gt;

&lt;p&gt;由于系统自带的Ruby版本较低，所以这里我们先安装Ruby：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wget http://ftp.ruby-lang.org/pub/ruby/1.9/ruby-1.9.3-p0.tar.gz
$ tar xzvf ruby-1.9.3-p0.tar.gz
$ cd ruby-1.9.3-p0
$ ./configure
$ make
$ sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成之后，查看下Ruby信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ruby -v
ruby 1.9.3p0 (2011-10-30 revision 33570) [i686-linux]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;安装Gem&lt;/h2&gt;

&lt;p&gt;Rails需要通过&lt;a href=&quot;https://rubygems.org/&quot; title=&quot;Gem&quot;&gt;Gem&lt;/a&gt;来安装，下面安装Gem：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wget http://production.cf.rubygems.org/rubygems/rubygems-1.8.24.tgz
$ tar -zxvf rubygems-1.8.24.tgz
$ cd rubygems-1.8.24
$ ruby setup.rb
RubyGems 1.8.24 installed
== 1.8.24 / 2012-04-27

* 1 bug fix:

  * Install the .pem files properly. Fixes #320
  * Remove OpenSSL dependency from the http code path

---------------------------------------------------------------------

RubyGems installed the following executables:
    /usr/local/bin/gem
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更新Gem：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem update --system 
Latest version currently installed. Aborting.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;安装Rails&lt;/h2&gt;

&lt;p&gt;接下来安装Rails:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo gem install rails
Successfully installed i18n-0.6.1
Successfully installed multi_json-1.3.6
Successfully installed activesupport-3.2.8
Successfully installed builder-3.0.3
...
...
Successfully installed rack-ssl-1.3.2
Successfully installed thor-0.16.0
Successfully installed railties-3.2.8
Successfully installed bundler-1.2.1
Successfully installed rails-3.2.8
28 gems installed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果出现以下的错误信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ERROR:  Loading command: update (LoadError)
    no such file to load -- zlib
ERROR:  While executing gem ... (NameError)
    uninitialized constant Gem::Commands::UpdateCommand
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是因为Ruby的zlib模块没有安装，安装zlib模块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install zlib1g-dev
cd /ruby-source-files/ext/zlib
ruby extconf.rb
make
sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果出现以下错误信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Installing ri documentation for rails-3.2.8...
file 'lib' not found
Installing RDoc documentation for rails-3.2.8...
file 'lib' not found
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是因为rdoc没有安装，安装rdoc：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo gem install rdoc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装&lt;a href=&quot;https://github.com/jweslley/rails_completion&quot;&gt;Rails Completion&lt;/a&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wget -O ~/.rails.bash https://raw.github.com/jweslley/rails_completion/master/rails.bash
$ echo source ~/.rails.bash &amp;gt;&amp;gt; ~/.bashrc
$ source ~/.bashrc
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;第一个应用&lt;/h2&gt;

&lt;p&gt;Rails安装完成之后，你可以创建自己的Rails应用了：
    $ cd /srv
    $ rails new myapp
    create&lt;br/&gt;
    create  README.rdoc
    create  Rakefile
    create  config.ru
    create  .gitignore
    create  Gemfile
    ...
    ...
    Using rails (3.2.8)
    Using sass (3.2.1)
    Using sass-rails (3.2.5)
    Using sqlite3 (1.3.6)
    Installing uglifier (1.3.0)
    Your bundle is complete! Use &lt;code&gt;bundle show [gemname]&lt;/code&gt; to see where a
    bundled gem is installed.&lt;/p&gt;

&lt;p&gt;Rails应用创建成功之后，你可以测试下这个应用是否可以运行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd myapp
$ rails server
rails server
=&amp;gt; Booting WEBrick
=&amp;gt; Rails 3.2.8 application starting in development on http://0.0.0.0:3000
=&amp;gt; Call with -d to detach
=&amp;gt; Ctrl-C to shutdown server
[2012-09-23 15:02:22] INFO  WEBrick 1.3.1
[2012-09-23 15:02:22] INFO  ruby 1.9.3 (2012-04-20) [x86_64-darwin12.0.0]
[2012-09-23 15:02:22] INFO  WEBrick::HTTPServer#start: pid=9907 port=3000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行以上的操作后，系统会启动WEBrick服务器，你可以通过&lt;code&gt;http://127.0.0.1:3000&lt;/code&gt;来访问应用的内容了。不过WEBrick只可以作为测试用，
不能应用在大规模的生产环境中，所以我们需要一个高性能的服务器，这就是下面将要介绍的&lt;a href=&quot;http://unicorn.bogomips.org/&quot; title=&quot;Unicorn&quot;&gt;Unicorn&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;安装Unicorn&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://unicorn.bogomips.org/&quot; title=&quot;Unicorn&quot;&gt;Unicorn（独角兽）&lt;/a&gt;是一个高性能的&lt;a href=&quot;http://rack.github.com/&quot; title=&quot;Rack&quot;&gt;Rack&lt;/a&gt; HTTP server，更多介绍参见&lt;a href=&quot;https://github.com/blog/517-unicorn&quot; title=&quot;Github Unicorn&quot;&gt;Github的介绍&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Unicorn依赖于&lt;a href=&quot;https://github.com/sstephenson/execjs&quot;&gt;JavaScript Runtime&lt;/a&gt;，首先我们安装Node.js：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install nodejs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来我们通过Gem来安装Unicorn：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem install unicorn
Fetching: kgio-2.7.4.gem (100%)
Building native extensions.  This could take a while...
Fetching: raindrops-0.10.0.gem (100%)
Building native extensions.  This could take a while...
Fetching: unicorn-4.3.1.gem (100%)
Building native extensions.  This could take a while...
Successfully installed kgio-2.7.4
Successfully installed raindrops-0.10.0
Successfully installed unicorn-4.3.1
3 gems installed
Installing ri documentation for kgio-2.7.4...
Installing ri documentation for raindrops-0.10.0...
Installing ri documentation for unicorn-4.3.1...
Installing RDoc documentation for kgio-2.7.4...
Installing RDoc documentation for raindrops-0.10.0...
Installing RDoc documentation for unicorn-4.3.1...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成之后，启动Unicorn：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /srv/myapp
$ unicorn -l 127.0.0.1:8080 -E development
I, [2012-09-23T15:22:39.793852 #12107]  INFO -- : listening on addr=0.0.0.0:8080 fd=5
I, [2012-09-23T15:22:39.794149 #12107]  INFO -- : worker=0 spawning...
I, [2012-09-23T15:22:39.795973 #12107]  INFO -- : master process ready
I, [2012-09-23T15:22:39.797613 #12108]  INFO -- : worker=0 spawned pid=12108
I, [2012-09-23T15:22:39.797927 #12108]  INFO -- : Refreshing Gem list
I, [2012-09-23T15:22:41.245205 #12108]  INFO -- : worker=0 ready
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;-l 127.0.0.1:8080&lt;/code&gt;指定Unicorn监听8080端口，&lt;code&gt;-E development&lt;/code&gt;指定运行环境为开发环境，更多内容参见&lt;code&gt;unicorn -h&lt;/code&gt;。Unicorn启动成功之后，可以通过&lt;code&gt;http://127.0.0.1:8080&lt;/code&gt;来访问Rails应用。&lt;/p&gt;

&lt;h2&gt;环境配置&lt;/h2&gt;

&lt;p&gt;以上只是一个快速使用Unicorn的例子，我们还需要进行设置，使其可以自动化的启动。我们采用&lt;a href=&quot;http://nginx.org/&quot; title=&quot;Nginx&quot;&gt;Nginx&lt;/a&gt;作为我们的Web服务器，并使用反向代理的方式对外提供服务：&lt;/p&gt;

&lt;p&gt;首先，在myapp下创建配置文件&lt;code&gt;/srv/myapp/config/unicorn.rb&lt;/code&gt;，内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;worker_processes 4
working_directory &quot;/srv/myapp&quot; # available in 0.94.0+

listen &quot;/tmp/unicorn.sock&quot;, :backlog =&amp;gt; 64
listen 8080, :tcp_nopush =&amp;gt; true

timeout 30

pid &quot;/srv/myapp/tmp/unicorn.pid&quot;
stderr_path &quot;/srv/myapp/log/unicorn.stderr.log&quot;
stdout_path &quot;/srv/myapp/log/unicorn.stdout.log&quot;

# combine Ruby 2.0.0dev or REE with &quot;preload_app true&quot; for memory savings
# http://rubyenterpriseedition.com/faq.html#adapt_apps_for_cow
preload_app true
GC.respond_to?(:copy_on_write_friendly=) and
  GC.copy_on_write_friendly = true

before_fork do |server, worker|
  # the following is highly recomended for Rails + &quot;preload_app true&quot;
  # as there's no need for the master process to hold a connection
  defined?(ActiveRecord::Base) and
    ActiveRecord::Base.connection.disconnect!

  # The following is only recommended for memory/DB-constrained
  # installations.  It is not needed if your system can house
  # twice as many worker_processes as you have configured.
  #
  # # This allows a new master process to incrementally
  # # phase out the old master process with SIGTTOU to avoid a
  # # thundering herd (especially in the &quot;preload_app false&quot; case)
  # # when doing a transparent upgrade.  The last worker spawned
  # # will then kill off the old master process with a SIGQUIT.
  # old_pid = &quot;#{server.config[:pid]}.oldbin&quot;
  # if old_pid != server.pid
  #   begin
  #     sig = (worker.nr + 1) &amp;gt;= server.worker_processes ? :QUIT : :TTOU
  #     Process.kill(sig, File.read(old_pid).to_i)
  #   rescue Errno::ENOENT, Errno::ESRCH
  #   end
  # end
  #
  # Throttle the master from forking too quickly by sleeping.  Due
  # to the implementation of standard Unix signal handlers, this
  # helps (but does not completely) prevent identical, repeated signals
  # from being lost when the receiving process is busy.
  # sleep 1
end

after_fork do |server, worker|
  # per-process listener ports for debugging/admin/migrations
  # addr = &quot;127.0.0.1:#{9293 + worker.nr}&quot;
  # server.listen(addr, :tries =&amp;gt; -1, :delay =&amp;gt; 5, :tcp_nopush =&amp;gt; true)

  # the following is *required* for Rails + &quot;preload_app true&quot;,
  defined?(ActiveRecord::Base) and
    ActiveRecord::Base.establish_connection

  # if preload_app is true, then you may also want to check and
  # restart any other shared sockets/descriptors such as Memcached,
  # and Redis.  TokyoCabinet file handles are safe to reuse
  # between any number of forked children (assuming your kernel
  # correctly implements pread()/pwrite() system calls)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，在Nginx中添加如下配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;upstream app_server {
    # fail_timeout=0 means we always retry an upstream even if it failed
    # to return a good HTTP response (in case the Unicorn master nukes a
    # single worker for timing out).

    # for UNIX domain socket setups:
    server unix:/tmp/unicorn.sock fail_timeout=0;
}

server {
    listen       8888;
    server_name  _;

    #access_log  logs/host.access.log  main;

    location / {
        # an HTTP header important enough to have its own Wikipedia entry:
        #   http://en.wikipedia.org/wiki/X-Forwarded-For
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

        # enable this if you forward HTTPS traffic to unicorn,
        # this helps Rack set the proper URL scheme for doing redirects:
        # proxy_set_header X-Forwarded-Proto $scheme;

        # pass the Host: header from the client right along so redirects
        # can be set properly within the Rack application
        proxy_set_header Host $http_host;
        # we don't want nginx trying to do something clever with
        # redirects, we set the Host: header above already.
        proxy_redirect off;

        # set &quot;proxy_buffering off&quot; *only* for Rainbows! when doing
        # Comet/long-poll/streaming.  It's also safe to set if you're using
        # only serving fast clients with Unicorn + nginx, but not slow
        # clients.  You normally want nginx to buffer responses to slow
        # clients, even with Rails 3.1 streaming because otherwise a slow
        # client can become a bottleneck of Unicorn.
        #
        # The Rack application may also set &quot;X-Accel-Buffering (yes|no)&quot;
        # in the response headers do disable/enable buffering on a
        # per-response basis.
        # proxy_buffering off;

      proxy_pass http://app_server;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后，添加配置文件&lt;code&gt;/etc/unicorn/myapp.conf&lt;/code&gt;，内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RAILS_ENV=development  #environment 
RAILS_ROOT=/srv/myapp #
UNICORN=/usr/local/bin/unicorn
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，创建启动脚本：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wget -O unicornd https://raw.github.com/gist/3769241/293df374dd7946ac44ac5575feccbfe80f6aa18d/unicornd
$ sudo cp unicornd /etc/init.d/
$ sudo chmod +x /etc/init.d/unicornd
$ echo /etc/init.d/unicornd start &amp;gt;&amp;gt; /etc/rc.local
$ sudo /etc/init.d/unicornd start
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/blog/517-unicorn&quot;&gt;https://github.com/blog/517-unicorn&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>八月西湖</title>
   <link href="http://weizhifeng.net/bayuexihu.html"/>
   <updated>2012-09-13T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/bayuexihu</id>
   <content type="html">&lt;p&gt;瀟瀟西湖雨   &lt;br/&gt;
斜風落蘇堤   &lt;br/&gt;
傘下青山外   &lt;br/&gt;
舟行煙波裏&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/poem/bayuexihu.jpg&quot; title=&quot;八月西湖&quot; alt=&quot;八月西湖&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Redis协议</title>
   <link href="http://weizhifeng.net/redis-protocol.html"/>
   <updated>2012-09-05T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/redis-protocol</id>
   <content type="html">&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/tech/redis.png&quot; title=&quot;Redis&quot; alt=&quot;Redis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Redis协议是从以下几个方面做的一个折中方案：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;容易实现&lt;/li&gt;
&lt;li&gt;机器解析要快&lt;/li&gt;
&lt;li&gt;容易被人理解&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;网络层&lt;/h3&gt;

&lt;p&gt;客户端通过创建到6379端口的TCP连接来连接到一个Redis服务器。每个Redis命令或者客户端和服务器之间传输的数据都以\r\n (CRLF)结束。&lt;/p&gt;

&lt;h3&gt;请求&lt;/h3&gt;

&lt;p&gt;Redis可以接受由不同参数组成的命令。只要接收到一个命令，这个命令就会被执行，然后一个答复会被返回给客户端。&lt;/p&gt;

&lt;h3&gt;新的统一请求协议&lt;/h3&gt;

&lt;p&gt;新的统一协议是在Redis1.2中引入的，但是在Redis2.0中成为了与Redis服务器交互的标准方式。在统一协议中所有发送到Redis服务器的参数都是二进制安全的。这是总体格式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*&amp;lt;number of arguments&amp;gt; CR LF
$&amp;lt;number of bytes of argument 1&amp;gt; CR LF
&amp;lt;argument data&amp;gt; CR LF
...
$&amp;lt;number of bytes of argument N&amp;gt; CR LF
&amp;lt;argument data&amp;gt; CR LF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看下这个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*3
$3
SET
$5
mykey
$7
myvalue
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是以上命令以带引号的字符串展现的样子，这样就可以看到这个请求中每个字节的准确内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;*3\r\n$3\r\nSET\r\n$5\r\nmykey\r\n$7\r\nmyvalue\r\n&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就像你一会将会看到的，这个格式还会被用在Redis回复中。这个被用于每个参数中的格式$6\r\nmydata\r\n叫做Bulk 回复。Redis实际上使用的统一请求协议会返回内容列表，叫做&lt;a href=&quot;#multi-bulk-reply&quot;&gt;Multi-bulk回复&lt;/a&gt;。它是由N个不同的Bulk 回复合在一起，并且有一个字符串前缀*&amp;lt;argc&amp;gt;\r\n其中&amp;lt;argc&amp;gt;是后面参数（Bulk回复）的数量。&lt;/p&gt;

&lt;h3&gt;回复&lt;/h3&gt;

&lt;p&gt;Redis会以不同类型的回复对命令进行响应。可以通过服务器发送的第一个字节来判定回复的类型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果是单行回复，那么第一个字节是「+」&lt;/li&gt;
&lt;li&gt;如果回复的内容是错误信息，那么第一个字节是「_」&lt;/li&gt;
&lt;li&gt;如果回复的内容是一个整型数字，那么第一个字节是「:」&lt;/li&gt;
&lt;li&gt;如果是bulk回复，那么第一个字节是「$」&lt;/li&gt;
&lt;li&gt;如果是multi-bulk回复，那么第一个字节是「*」&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;状态回复&lt;/h3&gt;

&lt;p&gt;一个状态回复（或者：单行回复）的格式是以「+」开头，以「\r\n」结束的单行字符串。举个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;客户端库要返回「+」后面的所有内容，这个例子里边是字符串「OK」。&lt;/p&gt;

&lt;h3&gt;错误回复&lt;/h3&gt;

&lt;p&gt;错误的发送方式和状态回复很像。唯一的不同是第一个字节用「-」替代了「+」。
错误回复只有当一些奇怪的事情发生时才会被发送，例如如果你想要用错误的数据类型执行一个操作，或者这个命令不存在等等。所以客户端库应该在接收到一个错误回复的时候抛出一个异常。&lt;/p&gt;

&lt;h3&gt;整形回复&lt;/h3&gt;

&lt;p&gt;这个类型的回复就是一个代表整数以CRLF结束的字符串，并且用一个字节的字符「:」作为前缀。例如「:0\r\n」，或者「:1000\r\n」都是整形回复。
像INCR或者LASTSAVE命令使用整型回复来返回一个没有特别含义的整型数字。对于INCR来说返回的是增加后的数字，对于LASTSAVE来说是一个UNIX时间等等。
像EXISTS这样的命令会返回1表示true，返回0表示false。
其他命令像SADD，SREM和SETNX在操作实际完成的时候会返回1，否则返回0。
以下命令将会返回整型回复：SETNX, DEL, EXISTS, INCR, INCRBY, DECR, DECRBY, DBSIZE, LASTSAVE, RENAMENX, MOVE, LLEN, SADD, SREM, SISMEMBER, SCARD&lt;/p&gt;

&lt;h3&gt;Bulk回复&lt;/h3&gt;

&lt;p&gt;Bulk回复被服务器用来返回一个二进制安全的字符串。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C: GET mykey
S: $6\r\nfoobar\r\n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务器以这种方式来发送数据：第一行是一个字节的内容「$」，之后跟着具体内容的字节数，接下来是CRLF，然后具体数据内容被发送，接下来是额外的两个字节的CRLF。服务器实际发送的序列是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;$6\r\nfoobar\r\n&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果请求的内容不存在，那么bulk回复将会使用特殊值-1作为数据长度，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C: GET nonexistingkey
S: $-1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当请求对象不存在，客户端库API不要返回一个空字符串，应该是一个nil对象。举个例子一个Ruby库应该返回「nil」，一个C库应该返回NULL（或者在回复对象中设置一个特殊标记），等等。&lt;/p&gt;

&lt;h3&gt;Multi-bulk回复&lt;/h3&gt;

&lt;div id=&quot;multi-bulk-reply&quot;&gt;&lt;/div&gt;


&lt;p&gt;像LRANGE这类的命令需要返回多个值（列表中的每个元素是一个值，LRANGE需要返回多个元素）。这通过multiple bulk write来实现，其第一行指明后面有多少个bulk　write。一个multi bulk回复的第一个字节一直是*。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C: LRANGE mylist 0 3
s: *4
s: $3
s: foo
s: $3
s: bar
s: $5
s: Hello
s: $5
s: World
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就像你看到的，multi bulk 回复和使用统一协议发送命令到Redis服务器使用的是同样的格式。
服务器发送的第一行是*4\r\n，用来指出下面将会有四个bulk回复。然后每个bulk write将会被传送。
如果指定的key不存在，那么这个key被认为拥有一个空列表，然后0会做为multi bulk的数量被发送。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C: LRANGE nokey 0 1
S: *0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当&lt;a href=&quot;http://redis.io/commands/blpop&quot; title=&quot;BLPOP&quot;&gt;BLPOP&lt;/a&gt;命令超时，它将返回值为nil的multi bulk回复。这个类型的multi bulk的数量为-1并且应该被解释为nil值。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C: BLPOP key 1
S: *-1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当这个发生的时候，一个客户端库API应该返回一个nil对象而不是一个空列表。区分一个空的列表和一个错误条件（比如&lt;a href=&quot;http://redis.io/commands/blpop&quot; title=&quot;BLPOP&quot;&gt;BLPOP&lt;/a&gt;命令的超时条件）是必要的。&lt;/p&gt;

&lt;h3&gt;Multi-Bulk回复中的Nil元素&lt;/h3&gt;

&lt;p&gt;一个multi bulk　回复的单个元素可能会存在-1的长度，用来指明这个元素不存在并且不是空字符串。这个可能发生在启用了GET模式选项的SORT命令，并且指定的key不存在。包含一个空元素的multi bulk回复的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;S: *3
S: $3
S: foo
S: $-1
S: $3
S: bar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二个元素是nil。客户端库需要返回如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&quot;foo&quot;,nil,&quot;bar&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;多个命令和管道&lt;/h3&gt;

&lt;p&gt;一个客户端可以使用相同的连接来发送多个命令。Redis是支持管道的，所以客户端可以通过一次写操作发送多个命令，不需要读取服务器的回复才能发送下一个命令。所有的回复可以在最后读取。
通常情况下Redis服务器和客户端之间会有非常快的连接，所以客户端支持这个特性不是那么重要，但如果一个应用需要在很短的时间里发送大量的命令那么使用管道将会非常快。&lt;/p&gt;

&lt;h3&gt;发送命令的旧协议&lt;/h3&gt;

&lt;p&gt;在统一请求协议之前，Redis使用一个不同的协议来发送命令，这个协议仍然被支持因为通过telnet它很容易手写。在这个协议中存在两种命令：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;inline 命令: 命令很简单，就是用空格把参数分隔开来的字符串。二进制安全是不可能的。&lt;/li&gt;
&lt;li&gt;Bulk   命令: bulk命令和inline命令几乎是一样的，但是最后一个参数为了能够接受二进制安全的内容，所以需要以特殊的方式进行处理。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;Inline命令&lt;/h3&gt;

&lt;p&gt;向Redis发送命令最简单的方法是使用inline命令。以下是一个服务器/客户端之间使用inline命令进行交互的例子（服务器以S:作为开始，客户端以C:作为开始）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C: PING
S: +PONG
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下是另一个例子，一个返回整数的inline命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C: EXISTS somekey
S: :0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于「somekey」不存在，所以服务器返回「:0」。
注意EXISTS命令只带有一个参数。多个参数以空格进行分隔。&lt;/p&gt;

&lt;h3&gt;Bulk命令&lt;/h3&gt;

&lt;p&gt;当一些命令以inline命令发送的时候为了使最后一个参数支持二进制安全，需要以一个特殊的格式发送。这些命令将会把最后一个参数作为「字节计数器」，然后大量的数据会被发送（这些数据可以为二进制安全，因为服务器知道有多少字节需要读取）。
看下面这个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C: SET mykey 6
C: foobar
S: +OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个命令的最后一个参数是「6」。这个指明了后面数据，字符串「foobar」的字节数。注意即使这些数据被额外的二个字节大小的CRLF所截断。所有bulk命令的准确格式是：把最后一个参数替换成后面数据的字节数，接下来是数据本身和CRLF。为了能够让程序员更加清晰的理解，这是上面例子中客户端发送的字符串：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;SET mykey 6\r\nfoobar\r\n&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Redis有一个内部的列表，记录了什么命令是inline，什么命令是bulk，所以你需要参考这个来发送命令。强烈推荐使用新的统一请求协议来替代旧的协议。&lt;/p&gt;

&lt;p&gt;原文：&lt;a href=&quot;http://redis.io/topics/protocol&quot; title=&quot;Redis protocol&quot;&gt;Protocol specification&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>秋夜行</title>
   <link href="http://weizhifeng.net/september-walk.html"/>
   <updated>2012-08-26T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/september-walk</id>
   <content type="html">&lt;p&gt;秋風起夜闌    &lt;br/&gt;
水月籠江南    &lt;br/&gt;
浮華一城中   &lt;br/&gt;
何處訪幽蘭&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>利用Jekyll在Github上写博客</title>
   <link href="http://weizhifeng.net/blog-with-jekyll-on-github.html"/>
   <updated>2012-08-25T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/blog-with-jekyll-on-github</id>
   <content type="html">&lt;p&gt;之前个人博客是托管在&lt;a href=&quot;http://www.tumblr.com&quot; title=&quot;Tumblr&quot;&gt;Tumblr&lt;/a&gt;上的，不过最近Tumblr被墙了，除了问候方校长之外，一个随之而来的事情就是要迁移博客。WordPress肯定不会再用了，太臃肿，这也是我放弃WordPress使用Tumblr的原因，所以选择下一个博客平台一定要轻量级。偶然之间看到BeiYuu的这篇&lt;a href=&quot;http://beiyuu.com/github-pages/&quot; title=&quot;github pages&quot;&gt;文章&lt;/a&gt;，发现了&lt;a href=&quot;https://github.com/mojombo/jekyll&quot; title=&quot;jekyll&quot;&gt;Jekyll&lt;/a&gt;这个静态模板系统，并且可以把博客内容托管在&lt;a href=&quot;http://github.com&quot; title=&quot;github&quot;&gt;Github&lt;/a&gt;上，这对于程序员来说是太适合不过的了，闲言少叙，开始动手！&lt;/p&gt;

&lt;p&gt;首先在本地上安装Jekyll，本人使用的系统是Mac OS X Mountain Lion，并且已经安装好Ruby，Python，请读者根据自身情况自行安装。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem install jekyll
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装RDiscount&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem install rdiscount
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装pygments&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ easy_install pip
$ pip install --upgrade distribute
$ pip install pygments
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成之后，clone &lt;a href=&quot;https://github.com/mojombo/mojombo.github.com&quot; title=&quot;Tom Preston-Werner&quot;&gt;Tom Preston-Werner&lt;/a&gt;做的模板，并删除_posts，_images两个目录中的内容，因为里边的内容是有版权的。完成之后，在_posts中添加自己的文章，格式可以markdown或者Textile。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone git://github.com/mojombo/mojombo.github.com.git myblog
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动jekyll创建网站静态内容，然后你可以通过127.0.0.1:4000来访问自己的博客&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ jekyll --server
[2012-08-25 15:37:04] INFO  WEBrick 1.3.1
[2012-08-25 15:37:04] INFO  ruby 1.9.3 (2012-04-20) [x86_64-darwin12.0.0]
[2012-08-25 15:37:04] INFO  WEBrick::HTTPServer#start: pid=2687 port=4000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果以上没有问题，接下来就要进行数据&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Blog-Migrations&quot; title=&quot;migrations&quot;&gt;迁移&lt;/a&gt;，支持WordPress，Drupal，Movable Type，Typo 4+，TextPattern，Mephisto，Blogspot，Posterous，Tumblr，我之前使用的是Tumblr，所以进行如下操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem install sequel mysqlplus json
$ pip install html2text
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在项目下创建_import目录，然后执行迁移操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd  /Users/weizhifeng/dev/jekyll/jeremywei.github.com &amp;amp;&amp;amp; mkdir _import
$ ruby -rubygems -e 'require &quot;jekyll/migrators/tumblr&quot;; Jekyll::Tumblr.process(&quot;http://www.your_blog_url.com&quot;, format=&quot;md&quot;)'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数据迁移完成之后，需要在&lt;a href=&quot;http://github.com&quot; title=&quot;github&quot;&gt;Github&lt;/a&gt;上创建项目username.github.com「username是你的Github用户名」，然后把博客的origin替换为新建的项目，并且push到Github，十分钟后就可以通过http://username.github.com来访问了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd myblog
$ git remote rm origin
$ git remote add origin git@github.com:username/username.github.com.git
$ git push origin 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你有独立域名，那么你可以把域名&lt;a href=&quot;https://help.github.com/articles/setting-up-a-custom-domain-with-pages&quot; title=&quot;custom domain&quot;&gt;指向&lt;/a&gt;到Github，首先创建名为CNAME的文本文件，内容为域名&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ touch CNAME &amp;amp;&amp;amp; echo &quot;example.com&quot; &amp;gt; CNAME
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来在域名example.com中添加A记录指向204.232.175.78&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>盛世帝都</title>
   <link href="http://weizhifeng.net/28019936326.html"/>
   <updated>2012-07-26T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/28019936326</id>
   <content type="html">&lt;p&gt;七月暴雨襲帝都 &lt;br/&gt;
有女跪請救其夫 &lt;br/&gt;
衙門只道水無人 &lt;br/&gt;
再見已是生死殊&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>为什么还不快使用git-flow？</title>
   <link href="http://weizhifeng.net/why-not-using-git-flow.html"/>
   <updated>2012-06-23T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/why-not-using-git-flow</id>
   <content type="html">&lt;p&gt;今年一月份的时候，&lt;a href=&quot;http://twitter.com/nvie&quot; title=&quot;@nvie&quot;&gt;@nvie&lt;/a&gt;发表了「&lt;a href=&quot;http://nvie.com/posts/a-successful-git-branching-model/&quot; title=&quot;model&quot;&gt;A successful Git branching model&lt;/a&gt;」，在这篇文章里他介绍了如何保持自己的Git仓库优雅并且整洁。除此之外，他还放出了&lt;a href=&quot;http://github.com/nvie/gitflow&quot; title=&quot;gitflow&quot;&gt;git-flow&lt;/a&gt;：一组Git扩展，可以异常容易地使用这个模型。&lt;/p&gt;

&lt;p&gt;我非常吃惊许多人之前根本没有听说过它，所以在这篇文章里我将要告诉你为什么它可以让你整天都心情愉悦。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/tech/gitflow.png&quot; title=&quot;Redis&quot; alt=&quot;Redis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;安装好git-flow之后，你可以在当前目录里开始一个新的仓库或者把一个已经存在的仓库转换成新的分支结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git flow init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它会问你一组问题，但是你最好接受默认值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;No branches exist yet. Base branches must be created now.
Branch name for production releases: [master] 
Branch name for &quot;next release&quot; development: [develop] 
How to name your supporting branch prefixes?

Feature branches? [feature/] 
Release branches? [release/] 
Hotfix branches? [hotfix/] 
Support branches? [support/] 
Version tag prefix? []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在你回答这些问题之后，git flow会自动把你的默认分支设置为&lt;em&gt;develop&lt;/em&gt;（或者任何你自己命名的），这是你将要开始工作的地方。&lt;/p&gt;

&lt;p&gt;现在，像之前一样简单得去使用Git，但是只在&lt;em&gt;develop&lt;/em&gt;分支上开发一些小功能。如果你需要开发一个大一些的功能，那么就得以&lt;em&gt;develop&lt;/em&gt;分支为基础创建一个特性分支（feature branch）。这里假设你想要添加一个登录页面：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git flow feature start login
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这会以我们的&lt;em&gt;develop&lt;/em&gt;分支为基础创建一个名叫&lt;em&gt;feature/login&lt;/em&gt;的新分支，然后并切换到这个分支上。提交代码并且当你完成了登录页面上的工作之后，简单的完成它：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git flow feature finish login
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这将会把&lt;em&gt;feature/login&lt;/em&gt;合并回&lt;em&gt;develop&lt;/em&gt;，并且删除特性分支。&lt;/p&gt;

&lt;p&gt;当你的特性完成的时候，简单地开始一个release分支 - 当然，也是基于&lt;em&gt;develop&lt;/em&gt;分支 - 来提升版本号并且修复release之前的最后几个bug：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git flow release start v0.1.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当你完成了一个release分支，它将会把你的修改合并到&lt;em&gt;master&lt;/em&gt;和&lt;em&gt;develop&lt;/em&gt;，所以你不用担心你的&lt;em&gt;master&lt;/em&gt;会比&lt;em&gt;develop&lt;/em&gt;提前。&lt;/p&gt;

&lt;p&gt;最后一件使git-flow如此厉害的事情是其处理hotfixes的能力。你开始和完成一个hotfix分支就像处理其他分支一样，但是这个分支是基于&lt;em&gt;master&lt;/em&gt;的，所以当生产环境上出现bug之后你可以迅速的修复它并且使用&lt;em&gt;finish&lt;/em&gt;把分支合并回&lt;em&gt;master&lt;/em&gt;和&lt;em&gt;develop&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;Awesome, right? Now, what are you waiting for?&lt;/p&gt;

&lt;p&gt;英文原文: &lt;a href=&quot;http://jeffkreeftmeijer.com/2010/why-arent-you-using-git-flow/&quot; title=&quot;why-arent-you-using-git-flow&quot;&gt;http://jeffkreeftmeijer.com/2010/why-arent-you-using-git-flow/&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>憶李後主</title>
   <link href="http://weizhifeng.net/25627960985.html"/>
   <updated>2012-06-22T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/25627960985</id>
   <content type="html">&lt;p&gt;月華掛玉枝  &lt;br/&gt;
花落無人拾  &lt;br/&gt;
南望金陵城  &lt;br/&gt;
無詞也無詩&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>使用Gitosis搭建Git服务器</title>
   <link href="http://weizhifeng.net/build-git-server-with-gitosis.html"/>
   <updated>2012-06-16T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/build-git-server-with-gitosis</id>
   <content type="html">&lt;p&gt;&lt;img src=&quot;http://s0-weizhifeng-net.b0.upaiyun.com/images/tech/git.jpg&quot; title=&quot;Git&quot; alt=&quot;Git&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;1.安装gitosis&lt;/h3&gt;

&lt;p&gt;首先是获取gitosis（这里假设你已经安装过git）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone git://github.com/res0nat0r/gitosis.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来安装gitosis：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo python setup.py install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果出现以下错误：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Traceback (most recent call last):
 File &quot;setup.py&quot;, line 2, in ?
 from setuptools import setup, find_packages
 ImportError: No module named setuptools
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者
    -bash: python: command not found&lt;/p&gt;

&lt;p&gt;那么你还需要安装python-setuptools：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum install python-setuptools
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来添加用来管理仓库的用户，用户名任意，我们这里使用git：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;useradd git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mac用户在「系统偏好设置　»　用户与群组 」中添加。&lt;/p&gt;

&lt;p&gt;修改PATH，使git用户可以调用git：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi /home/git/.bashrc
PATH=/usr/local/bin:/usr/local/git/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建key pair，并拷贝public key到/tmp下，这样可以确保gitosis-init命令对其有读取权限：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh-keygen -t rsa
cp ~/.ssh/id_rsa.pub /tmp/id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以git用户来执行gitosis-init命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo -H -u git gitosis-init &amp;amp;lt; /tmp/id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时/home/git下增加了两个目录：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gitosis
repositories
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中gitosis是gitosis的根目录，repositories是仓库存放目录。&lt;/p&gt;

&lt;p&gt;如果出现以下错误：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if install git from source, otherwise:
raise child_exception
OSError: [Errno 2] No such file or directory
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么做个symlink：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ln -s /usr/local/bin/git /usr/bin/git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给脚本post-update赋予可执行权限：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo chmod 755 /home/git/repositories/gitosis-admin.git/hooks/post-update
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2. 添加新仓库&lt;/h3&gt;

&lt;p&gt;gitosis的管理是通过git来管理的，clone一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone git@localhost:gitosis-admin.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果出现以下错误：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Cloning into gitosis-admin...
ssh: connect to host 192.168.1.30 port 22: Connection refused
fatal: The remote end hung up unexpectedly 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么确认当前机器openssh是否已经启动，Mac用户通过&amp;#8221;系统偏好　-&amp;gt;　共享　-&amp;gt;　远程登录&amp;#8221;进行设置。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd gitosis-admin
ls -l
-rw-r--r--  1 weizhifeng  staff  124  6 14 13:45 gitosis.conf
drwxr-xr-x  3 weizhifeng  staff  102  6 14 13:46 keydir
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;keydir目录用来存放用户的public key(.pub文件)，gitosis.conf为配置文件。&lt;/p&gt;

&lt;p&gt;看一下配置文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat gitosis.conf
[gitosis]

[group gitosis-admin]
    members = Mac
    writable = gitosis-admin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中group代表一个组，writable是仓库名，members是此仓库的成员，可以有多个成员，用空格进行分割。&lt;/p&gt;

&lt;p&gt;添加一个新仓库：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[group test]
    members = Mac
    writable = test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把更改提交并push到git@localhost:gitosis-admin.git：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git commit -a -m &quot;添加新仓库test&quot;
git push
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在本地创建一个仓库，并push到git@localhost:test.git，gitosis会在/home/git/repositories自动创建test.git这个仓库：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir test
cd test 
touch README
git init
git remote add origin git@localhost:test.git
git push origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;3. 添加用户&lt;/h3&gt;

&lt;p&gt;假设我们要添加的用户为jeremy，那么需要创建key pair：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh-keygen -t rsa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假设生成的public key为~/.ssh/jeremy.pub&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd gitosis-admin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改gitosis.conf，修改后为如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[group test]
members = Mac jeremy
writable = test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意.pub文件名和你要在members中添加的用户名要完全一样。&lt;/p&gt;

&lt;p&gt;拷贝jeremy.pub到keydir中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp　~/.ssh/jeremy.pub keydir/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把更改push到gitosis-admin.git：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git commit -a -m &quot;添加jeremy到test仓库&quot;
git push
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来把private key分发给jeremy，然后他就可以从自己的机器上进行clone了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone git@SERVER_HOSTNAME:test.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果出现以下错误：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ERROR:gitosis.serve.main:Repository read access denied
fatal: The remote end hung up unexpectedly
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是因为使用了内容相同，名字不同的public key(.pub)。&lt;/p&gt;

&lt;h3&gt;4.其他&lt;/h3&gt;

&lt;p&gt;如果SSH使用的不是22端口，那么请如下修改：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi ~/.ssh/config
Host myserver.com
Port 2345      
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;5. 参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://scie.nti.st/2007/11/14/hosting-git-repositories-the-easy-and-secure-way/%22&quot;&gt;http://scie.nti.st/2007/11/14/hosting-git-repositories-the-easy-and-secure-way/&lt;/a&gt;  &lt;br/&gt;
&lt;a href=&quot;http://lukhnos.org/blog/en/archives/162/&quot;&gt;http://lukhnos.org/blog/en/archives/162/&lt;/a&gt; &lt;br/&gt;
&lt;a href=&quot;http://blog.longwin.com.tw/2011/03/linux-gitosis-git-server-2011/&quot;&gt;http://blog.longwin.com.tw/2011/03/linux-gitosis-git-server-2011/&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PHP安全函数</title>
   <link href="http://weizhifeng.net/php-security-functions.html"/>
   <updated>2012-05-17T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/php-security-functions</id>
   <content type="html">&lt;p&gt;最近读完了&lt;a href=&quot;http://book.douban.com/subject/10546925/&quot; title=&quot;白帽子讲Web安全&quot;&gt;《白帽子讲Web安全》&lt;/a&gt;一书，觉得在WEB开发中安全是个非常重要的事情，但实际上工程师常抱有侥幸心理，认为这是小概率事件，但是不出事则已，一出事则非常严重，闲话少续，说说PHP中的几个跟安全相关的函数以及可用的方案。&lt;/p&gt;

&lt;h3&gt;1. addslashes&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://cn2.php.net/manual/en/function.addslashes.php&quot; title=&quot;addslashes&quot;&gt;addslashes&lt;/a&gt;对SQL语句中的特殊字符进行转义操作，包括(‘), (“), (), (NUL)四个字符，此函数在DBMS没有自己的转义函数时候使用，但是如果DBMS有自己的转义函数，那么推荐使用原装函数，比如MySQL有&lt;a href=&quot;http://cn2.php.net/manual/en/function.mysql-real-escape-string.php&quot; title=&quot;mysql-real-escape-string&quot;&gt;mysql_real_escape_string&lt;/a&gt;函数用来转义SQL。
注意在PHP5.3之前，&lt;a href=&quot;http://cn2.php.net/manual/en/security.magicquotes.php&quot; title=&quot;magicquotes&quot;&gt;magic_quotes_gpc&lt;/a&gt;是默认开启的，其主要是在$GET, $POST, $COOKIE上执行addslashes操作，所以不需要在这些变量上重复调用addslashes，否则会double escaping的。不过magic_quotes_gpc在PHP5.3就已经被废弃，从PHP5.4开始就已经被移除了，如果使用PHP最新版本可以不用担心这个问题。&lt;a href=&quot;http://cn2.php.net/manual/en/function.strip-tags.php&quot; title=&quot;strip-tags&quot;&gt;stripslashes&lt;/a&gt;为addslashes的unescape函数。&lt;/p&gt;

&lt;h3&gt;2. htmlspecialchars&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://cn2.php.net/manual/en/function.htmlspecialchars.php&quot; title=&quot;htmlspecialchars&quot;&gt;htmlspecialchars&lt;/a&gt;把HTML中的几个特殊字符转义成HTML Entity(格式：&amp;amp;xxxx;)形式，包括(&amp;amp;),('),(&quot;),(&amp;lt;),(&amp;gt;)五个字符。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;amp; (AND) =&amp;gt; &amp;amp;amp;
” (双引号) =&amp;gt; &amp;amp;quot; (当ENT_NOQUOTES没有设置的时候)
‘ (单引号) =&amp;gt; &amp;amp;#039; (当ENT_QUOTES设置)
&amp;lt; (小于号) =&amp;gt; &amp;amp;lt;
&amp;gt; (大于号) =&amp;gt; &amp;amp;gt;   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;htmlspecialchars可以用来过滤$GET，$POST，$COOKIE数据，预防&lt;a href=&quot;http://en.wikipedia.org/wiki/Cross-site_scripting&quot; title=&quot;Cross site scripting&quot;&gt;XSS&lt;/a&gt;。注意htmlspecialchars函数只是把认为有安全隐患的HTML字符进行转义，如果想要把HTML所有可以转义的字符都进行转义的话请使用htmlentities。&lt;a href=&quot;http://cn2.php.net/manual/en/function.htmlspecialchars-decode.php&quot; title=&quot;htmlspecialchars_decode&quot;&gt;htmlspecialchars_decode&lt;/a&gt;为htmlspecialchars的decode函数。&lt;/p&gt;

&lt;h3&gt;3. htmlentities&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://cn2.php.net/manual/en/function.htmlentities.php&quot; title=&quot;htmlentities&quot;&gt;htmlentities&lt;/a&gt;把HTML中可以转义的内容转义成HTML Entity。&lt;a href=&quot;http://cn2.php.net/manual/en/function.html-entity-decode.php&quot; title=&quot;html_entity_decode&quot;&gt;html_entity_decode&lt;/a&gt;为htmlentities的decode函数。&lt;/p&gt;

&lt;h3&gt;4. mysql_real_escape_string&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://cn2.php.net/manual/en/function.mysql-real-escape-string.php&quot; title=&quot;mysql-real-escape-string&quot;&gt;mysql_real_escape_string&lt;/a&gt;会调用MySQL的库函数mysql_real_escape_string，对(\x00), (\n), (\r), (), (‘), (\x1a)进行转义，即在前面添加反斜杠()，预防SQL注入。注意你不需要在读取数据库数据的时候调用stripslashes来进行unescape，因为这些反斜杠是在数据库执行SQL的时候添加的，当把数据写入到数据库的时候反斜杠会被移除，所以写入到数据库的内容就是原始数据，并不会在前面多了反斜杠。&lt;/p&gt;

&lt;h3&gt;5. strip_tags&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://cn2.php.net/manual/en/function.strip-tags.php&quot; title=&quot;strip-tags&quot;&gt;strip_tags&lt;/a&gt;会过滤掉NUL，HTML和PHP的标签。&lt;/p&gt;

&lt;h3&gt;6. 结语&lt;/h3&gt;

&lt;p&gt;PHP自带的安全函数并不能完全避免XSS，推荐使用&lt;a href=&quot;http://htmlpurifier.org/&quot; title=&quot;HTML Purifier&quot;&gt;HTML Purifier&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>三月金陵閑走</title>
   <link href="http://weizhifeng.net/23230343929.html"/>
   <updated>2012-03-27T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/23230343929</id>
   <content type="html">&lt;p&gt;三月春次還 &lt;br/&gt;
南國又花煙  &lt;br/&gt;
路旁喧雜處  &lt;br/&gt;
有人柳下眠&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PHP –with-curlwrappers 导致的问题</title>
   <link href="http://weizhifeng.net/wrong-with-curlwrappers.html"/>
   <updated>2012-03-18T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/wrong-with-curlwrappers</id>
   <content type="html">&lt;p&gt;有如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$opts = array(
  'http' =&amp;gt; array(
    'method' =&amp;gt; &quot;GET&quot;,
    'header' =&amp;gt; &quot;Accept-language: en\r\n&quot; . 
                &quot;Cookie: foo=bar\r\n&quot; . 
                &quot;User-Agent: MyAgent/1.0\r\n&quot;
  )
);

$context = stream_context_create($opts);
$result = file_get_contents('http://www.example.com/', false, $context);
var_dump($result);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正常情况下以上应该输出www.example.com返回的内容，但是实际上得到的结果是空字符串，遂进行如下测试：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$file = fopen('http://www.example.com/', 'rb');
var_dump(stream_get_meta_data($file));

/*
输出结果：
array(10) {
  [&quot;wrapper_data&quot;]=&amp;gt;
  array(2) {
    [&quot;headers&quot;]=&amp;gt;
    array(0) {
    }
    [&quot;readbuf&quot;]=&amp;gt;
    resource(38) of type (stream)
  }

  [&quot;wrapper_type&quot;]=&amp;gt;
  string(4) &quot;cURL&quot;

  [&quot;stream_type&quot;]=&amp;gt;
  string(4) &quot;cURL&quot;

  [&quot;mode&quot;]=&amp;gt;
  string(2) &quot;rb&quot;

  [&quot;unread_bytes&quot;]=&amp;gt;
  int(0)

  [&quot;seekable&quot;]=&amp;gt;
  bool(false)

  [&quot;uri&quot;]=&amp;gt;
  string(23) &quot;http://www.example.com/&quot;

  [&quot;timed_out&quot;]=&amp;gt;
  bool(false)

  [&quot;blocked&quot;]=&amp;gt;
  bool(true)

  [&quot;eof&quot;]=&amp;gt;
  bool(false)

}*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出的结果中，wrapper_type为cURL，而且wrapper_data为空，这是不正常的，正常情况下wrapper_type应为http，wrapper_data数组中应该包含响应头信息。google之，发现这个现象与&lt;code&gt;--with-curlwrappers&lt;/code&gt;这个编译选项有关，遂查看PHP编译参数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ php -i | grep configure

Configure Command =&amp;gt;  './configure' '--prefix=/usr/local/php' '--with-config-file-path=/usr/local/php/etc' '--with-mysql=/usr/local/mysql' '--with-mysqli=/usr/local/mysql/bin/mysql_config' '--with-iconv-dir=/usr/local' '--with-zlib' '--with-libxml-dir=/usr' '--enable-xml' '--enable-bcmath' '--enable-shmop' '--enable-sysvsem' '--enable-inline-optimization' '--with-curl' '--with-curlwrappers' '--enable-mbregex' '--enable-fpm' '--enable-mbstring' '--with-mcrypt' '--with-openssl' '--with-mhash' '--enable-pcntl' '--enable-sockets' '--with-xmlrpc' '--enable-zip' '--enable-soap' '--enable-bcmath'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;--with-curlwrappers&lt;/code&gt;被启用了，问题应该出在这里，查看一下这个编译选项的用处：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./configure --help | grep curlwrappers
  --with-curlwrappers     EXPERIMENTAL: Use cURL for url streams
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看来&lt;code&gt;--with-curlwrappers&lt;/code&gt;这个编译选项是用来处理url stream的，不过前面有个硕大的&lt;code&gt;EXPERIMENTAL&lt;/code&gt;字样，还在试验中。 现有的解决方法是重新编译PHP，去掉「--with-curlwrappers」：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /path/to/php-5.3.6
$ make clean
$ ./configure --prefix=/usr/local/php --with-config-file-path=/usr/local/php/etc --with-mysql=/usr/local/mysql \
--with-mysqli=/usr/local/mysql/bin/mysql_config --with-iconv-dir=/usr/local --with-zlib \
--with-libxml-dir=/usr --enable-xml --enable-bcmath --enable-shmop --enable-sysvsem \
--enable-inline-optimization --with-curl --enable-mbregex --enable-fpm  --enable-mbstring --with-mcrypt \
--with-openssl --with-mhash --enable-pcntl --enable-sockets --with-xmlrpc --enable-zip \
--enable-soap --enable-bcmath -with-gd --with-jpeg-dir=/usr --with-png-dir=/usr --enable-gd-native-ttf

$ make &amp;amp;&amp;amp; make install
$ cd /usr/local/php/bin
# 删除旧的PHP binary文件，并用新的进行替换，Mac下重新编译后会产生php.dSYM文件，其他Linux系统请自行处理
$ rm php &amp;amp;&amp;amp; mv php.dSYM php 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完成后，再做个测试：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$file = fopen('http://www.example.com/', 'rb');
var_dump(stream_get_meta_data($file));

/*
结果如下：
array(10) {
  [&quot;wrapper_data&quot;]=&amp;gt;
  array(12) {
    [0]=&amp;gt;
    string(18) &quot;HTTP/1.0 302 Found&quot;

    [1]=&amp;gt;
    string(46) &quot;Location: http://www.iana.org/domains/example/&quot;

    [2]=&amp;gt;
    string(13) &quot;Server: BigIP&quot;

    [3]=&amp;gt;
    string(17) &quot;Connection: close&quot;

    [4]=&amp;gt;
    string(17) &quot;Content-Length: 0&quot;

    [5]=&amp;gt;
    string(15) &quot;HTTP/1.1 200 OK&quot;

    [6]=&amp;gt;
    string(35) &quot;Date: Sun, 18 Mar 2012 06:12:27 GMT&quot;

    [7]=&amp;gt;
    string(29) &quot;Server: Apache/2.2.3 (CentOS)&quot;

    [8]=&amp;gt;
    string(44) &quot;Last-Modified: Wed, 09 Feb 2011 17:13:15 GMT&quot;

    [9]=&amp;gt;
    string(21) &quot;Vary: Accept-Encoding&quot;

    [10]=&amp;gt;
    string(17) &quot;Connection: close&quot;

    [11]=&amp;gt;
    string(38) &quot;Content-Type: text/html; charset=UTF-8&quot;

  }

  [&quot;wrapper_type&quot;]=&amp;gt;
  string(4) &quot;http&quot;

  [&quot;stream_type&quot;]=&amp;gt;
  string(14) &quot;tcp_socket/ssl&quot;

  [&quot;mode&quot;]=&amp;gt;
  string(2) &quot;rb&quot;

  [&quot;unread_bytes&quot;]=&amp;gt;
  int(1225)

  [&quot;seekable&quot;]=&amp;gt;
  bool(false)

  [&quot;uri&quot;]=&amp;gt;
  string(23) &quot;http://www.example.com/&quot;

  [&quot;timed_out&quot;]=&amp;gt;
  bool(false)

  [&quot;blocked&quot;]=&amp;gt;
  bool(true)

  [&quot;eof&quot;]=&amp;gt;
  bool(false)
}
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;wrapper_type变成了http，wrapper_data也被填充了，一切恢复正常。所以一条结论：慎用&lt;code&gt;--with-curlwrappers&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://cn.php.net/manual/en/function.stream-context-create.php#99353&quot;&gt;http://cn.php.net/manual/en/function.stream-context-create.php#99353&lt;/a&gt;
&lt;a href=&quot;https://www.facebook.com/note.php?note_id=290180466652&quot;&gt;https://www.facebook.com/note.php?note_id=290180466652&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PHP引用以及误区</title>
   <link href="http://weizhifeng.net/php-reference.html"/>
   <updated>2012-03-13T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/php-reference</id>
   <content type="html">&lt;h3&gt;什么是引用&lt;/h3&gt;

&lt;p&gt;PHP中的引用可以理解成变量的别名。由于PHP的变量名是存储在符号表(symbol table)中的，变量内容是存储在堆中，引用就是用符号表中的不同符号(symbol)名称来访问同一存储内容，和Unix文件系统中的&lt;a href=&quot;http://en.wikipedia.org/wiki/Hard_link&quot; title=&quot;Hard link&quot;&gt;hardlink&lt;/a&gt;是同一个概念，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
$a = 1;
$b = &amp;amp;$a; //$a与$b指向同一内容
$b = 2;
echo $b; //2
echo $a; //2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;传递引用&lt;/h3&gt;

&lt;p&gt;引用传递很简单，就是一个「&amp;amp;」符号，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
function foo(&amp;amp;$a) {
  $a = 2;
}

$b = 1;
foo($b);
echo $b; //2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;返回引用&lt;/h3&gt;

&lt;p&gt;大多数情况下并不需要返回引用来提高性能，zend引擎会自己进行优化，但是如果你非得返回引用得话，可以按照以下方式来返回引用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
class foo {
    public $value = 42;

    public function &amp;amp;getValue() { // 需要一个&quot;&amp;amp;&quot;
        return $this-&amp;gt;value;
    }
}

$obj = new foo;
$myValue = &amp;amp;$obj-&amp;gt;getValue(); // 还需要一个&quot;&amp;amp;&quot;，$myValue是对class foo中的$value的引用
$obj-&amp;gt;value = 2;              // 修改对象的$value属性
echo $myValue;                // 输出2，$myValue与class foo中的$value值相同
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;与指针的区别&lt;/h3&gt;

&lt;p&gt;引用与指针很像，但是其并不是指针，看如下的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
    $a = 0;
    $b = &amp;amp;a;
    echo $a; //0
    unset($b);
    echo $a; //0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于$b只是$a的别名，所以即使$b被释放了，$a没有任何影响，但是指针可不是这样的，看如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
int main(int argc, char const *argv[]) {
    int a = 0;
    int* b = &amp;amp;a;

    printf(&quot;%i\n&quot;, a); //0
    free(b);
    printf(&quot;%i\n&quot;, a); //*** error for object 0x7fff6350da08: pointer being freed was not allocated
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于b是指向a的指针，所以释放了b的内存之后，再访问a就会出现错误，比较明显的说明了PHP引用与C指针的区别。&lt;/p&gt;

&lt;h3&gt;对象与引用&lt;/h3&gt;

&lt;p&gt;在PHP中使用对象的时候，大家总是被告知“对象是按照引用传递的”，其实这是个误区。PHP的对象变量存储的是此对象的一个标示符，在传递对象的时候，其实传递的就是这个标示符，而并不是引用，看如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
$a = new A;
$b = $a;    
$b-&amp;gt;testA = 2;

/*
 * 此时$a,$b的关系：
 *        +-----------+      +-----------------+
 * $a --&amp;gt; | object id | ---&amp;gt; | object(Class A) |
 *        +-----------+      +-----------------+
 *                               ^
 *        +-----------+          |
 * $b --&amp;gt; | object id | ---------+
 *        +-----------+    
 *
 *
 */

$c = new B;
$a = $c;
$a-&amp;gt;testB = &quot;Changed Class B&quot;;

/*
 * 此时$a,$b,$c的关系：
 *        +-----------+      +-----------------+
 * $b --&amp;gt; | object id | ---&amp;gt; | object(Class A) |
 *        +-----------+      +-----------------+
 *                               
 *        +------------+          
 * $a --&amp;gt; | object id2 | -------------+
 *        +------------+              |
 *                                    v
 *        +------------+      +-----------------+
 * $c --&amp;gt; | object id2 | ---&amp;gt; | object(Class B) |
 *        +------------+      +-----------------+
 */

echo &quot;object a: &quot;; var_dump($a); //[&quot;testB&quot;]=&amp;gt; string(15) &quot;Changed Class B&quot;
echo &quot;object b: &quot;; var_dump($b); //[&quot;testA&quot;] =&amp;gt; int(2)
echo &quot;object c: &quot;; var_dump($c); //[&quot;testB&quot;]=&amp;gt; string(15) &quot;Changed Class B&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果对象是按照引用传递的，那么$a, $b, $c输出的内容应该一样，事实上结果并非如此。 看下面通过引用传递对象的列子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
$aa = new A;
$bb = &amp;amp;$aa;  // 引用 
$bb-&amp;gt;testA = 2;

/*
 * 此时$aa, $bb的关系：
 *
 *         +-----------+      +-----------------+
 * $bb --&amp;gt; | object id | ---&amp;gt; | object(Class A) |
 *         +-----------+      +-----------------+
 *              ^                  
 *              |
 * $aa ---------+ 
 *
 *
 */

$cc = new B;
$aa = $cc;
$aa-&amp;gt;testB = &quot;Changed Class B&quot;;

/*
 * 此时$aa, $bb, $cc的关系：
 *
 *         +-----------+      +-----------------+
 *         | object id | ---&amp;gt; | object(Class A) |
 *         +-----------+      +-----------------+
 *              
 * $bb ----&amp;gt;-----+      
 *               |
 * $aa ----&amp;gt;-----+
 *               |  
 *               v   
 *         +------------+      
 *         | object id2 | --------------+ 
 *         +------------+               |
 *                                      v
 *         +------------+      +-----------------+
 * $cc --&amp;gt; | object id2 | ---&amp;gt; | object(Class B) |
 *         +------------+      +-----------------+
 */

echo &quot;object aa: &quot;; var_dump($aa); //[&quot;testB&quot;]=&amp;gt;string(15) &quot;Changed Class B&quot;
echo &quot;object bb: &quot;; var_dump($bb); //[&quot;testB&quot;]=&amp;gt;string(15) &quot;Changed Class B&quot;
echo &quot;object cc: &quot;; var_dump($cc); //[&quot;testB&quot;]=&amp;gt;string(15) &quot;Changed Class B&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时$aa，$bb，$cc三者内容完全一样，所以可以看出对象并不是按照引用传递，要尽快走出这个误区。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.php.net/manual/en/language.references.php&quot;&gt;http://www.php.net/manual/en/language.references.php&lt;/a&gt;
&lt;a href=&quot;http://www.php.net/manual/en/language.oop5.references.php&quot;&gt;http://www.php.net/manual/en/language.oop5.references.php&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PHP克隆</title>
   <link href="http://weizhifeng.net/php-clone.html"/>
   <updated>2012-03-11T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/php-clone</id>
   <content type="html">&lt;h3&gt;什么是克隆&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Clone_(computing)&quot; title=&quot;clone&quot;&gt;克隆&lt;/a&gt;就是完全复制另一个对象，二者独立，互不影响。你可能说直接用变量赋值不就完了吗？但是对于对象来说，简单的赋值并不能实现克隆了，因为对象是通过&lt;a href=&quot;http://weizhifeng.net/php-reference.html&quot; title=&quot;PHP引用误区&quot;&gt;伪引用&lt;/a&gt;传递的，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
class Sample {
    private $a = 1;

    public function plus() {
        $this-&amp;gt;a ++;
    }

    public function foo() {
        echo &quot;a={$this-&amp;gt;a}&quot;;
    }
}

$obj = new Sample();
$obj-&amp;gt;foo(); // 输出a=1

$obj2 = $obj;
$obj2-&amp;gt;plus(); // +1
$obj2-&amp;gt;foo(); // 输出a=2
$obj-&amp;gt;foo(); // 输出a=2，说明$obj也发生了变化，显然这不是我们想看到的
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;克隆&lt;/h3&gt;

&lt;p&gt;PHP提供了&lt;strong&gt;clone&lt;/strong&gt;关键字来实现对象的克隆，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
$obj = new Sample();
$obj2 = clone $obj; // 克隆一个$obj，赋值给$obj2

$obj-&amp;gt;foo(); // 输出a=1

$obj2-&amp;gt;plus(); //+1
$obj2-&amp;gt;foo(); // 输出a=2

$obj-&amp;gt;foo(); // 输出a=1，$obj没有发生变化，即$obj与$obj2没有任何联系
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当复制完成时, 如果定义了&lt;strong&gt;__clone()&lt;/strong&gt;方法， 则新创建的对象（复制生成的对象）中的&lt;strong&gt;__clone()&lt;/strong&gt;方法会被调用， 可用于修改属性的值（如果有必要的话），比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
class Sample {    
    private $a = 1;
    private $instance_no; // instance编号
    static public $all = 0;    // instance总数

    public function foo() {
        echo &quot;a={$this-&amp;gt;a}&quot;;
    }

    public function bar() {
        echo &quot;instance={$this-&amp;gt;instance_no}&quot;;
    }

    public function __construct() {
        // 实例号＋1
        $this-&amp;gt;instance_no = ++self::$all;
    }

    public function __clone() {
        // 实例号＋1
        $this-&amp;gt;instance_no = ++self::$all;
    }
}

$obj = new Sample();
$obj-&amp;gt;foo(); // 输出a=1
$obj-&amp;gt;bar(); // 输出instance=1 实例编号为1

$obj2 = clone $obj;
$obj2-&amp;gt;foo(); // 输出a=1 没变
$obj2-&amp;gt;bar(); // 输出instance=2 实例编号为2
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;深浅复制&lt;/h3&gt;

&lt;p&gt;在PHP中，克隆会把对象的所有属性进行复制，但是如果一个对象中包含引用属性，那么克隆之后，在新生成的对象中这个属性仍然是指向原来变量的引用，这个称为浅复制(shallow copy)。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
class Sample {
    private $a = 1;

    public function plus() {
        $this-&amp;gt;a ++;
    }

    public function foo() {
        echo &quot;a={$this-&amp;gt;a}&quot;;
    }
}

class Sample2 {
    public $b = 1;
    public $obj;

    public function plus() {
        $this-&amp;gt;b ++;
    }

    public function foo() {
        echo &quot;b={$this-&amp;gt;b}&quot;;
    }
}

$obj = new Sample2();
$obj-&amp;gt;obj = new Sample();
$obj2 = clone $obj; // clone 

// 修改对象的普通属性
$obj-&amp;gt;plus(); // $b + 1
$obj-&amp;gt;foo(); // 输出b=2
$obj2-&amp;gt;foo(); // 输出b=1，克隆的对象没有发生变化，因此普通属性克隆没有问题

// 修改对象的引用属性
$obj-&amp;gt;obj-&amp;gt;plus(); // $a+1
$obj-&amp;gt;obj-&amp;gt;foo(); // 输出a=2
$obj2-&amp;gt;obj-&amp;gt;foo(); // 输出a=2 克隆对象中的引用属性也发生了变化，这个不是我们想要的结果
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上的列子说明了浅复制导致的问题，我们要自己实现对引用属性的完全复制，术语叫作深复制(deep copy)，示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
class Sample {
    private $a = 1;

    public function plus() {
        $this-&amp;gt;a ++;
    }

    public function foo() {
        echo &quot;a={$this-&amp;gt;a}&quot;;
    }
}

class Sample2 {
    public $b = 1;
    public $obj;

    public function plus() {
        $this-&amp;gt;b ++;
    }

    public function foo() {
        echo &quot;b={$this-&amp;gt;b}&quot;;
    }

    function __clone() {
        $this-&amp;gt;obj = clone $this-&amp;gt;obj;

        // 当存在对象数组的时候，可以使用以下代码实现深复制
        /*foreach ($this as $key =&amp;gt; $val) {
            if (is_object($val) || (is_array($val))) {
                $this-&amp;gt;{$key} = unserialize(serialize($val));
            }
        }*/
    }
}

$obj = new Sample2();
$obj-&amp;gt;obj = new Sample();
$obj2 = clone $obj; // clone 

// 修改对象的引用属性
$obj-&amp;gt;obj-&amp;gt;plus(); // $a+1
$obj-&amp;gt;obj-&amp;gt;foo(); // 输出a=2
$obj2-&amp;gt;obj-&amp;gt;foo(); // 输出a=1 克隆对象中的引用属性没有发生变化，bingo.
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.php.net/manual/zh/language.oop5.cloning.php&quot;&gt;http://www.php.net/manual/zh/language.oop5.cloning.php&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>初春多雨</title>
   <link href="http://weizhifeng.net/23230308843.html"/>
   <updated>2012-03-10T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/23230308843</id>
   <content type="html">&lt;p&gt;今雨昨日煙  &lt;br/&gt;
秦淮誰憑欄  &lt;br/&gt;
展卷知千秋 &lt;br/&gt;
觀雨識江南&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>祭三七</title>
   <link href="http://weizhifeng.net/23230260090.html"/>
   <updated>2011-12-13T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/23230260090</id>
   <content type="html">&lt;p&gt;秦淮水冷殘柳稀   &lt;br/&gt;
古都警鳴祭三七  &lt;br/&gt;
當年城破怎堪憶 &lt;br/&gt;
今日國強奴敢欺&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>用HAProxy和KeepAlived构建高可用的反向代理系统</title>
   <link href="http://weizhifeng.net/HA-with-HAProxy-and-KeepAlived.html"/>
   <updated>2011-11-06T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/HA-with-HAProxy-and-KeepAlived</id>
   <content type="html">&lt;h3&gt;前言&lt;/h3&gt;

&lt;p&gt;对于访问量较大的网站来说，随着流量的增加单台服务器已经无法处理所有的请求，这时候需要多台服务器对大量的请求进行分流处理，即负载均衡。而如果实现负载均衡，必须在网站的入口部署服务器（不只是一台）对这些请求进行分发，这台服务器即反向代理。由于反向代理服务器是网站的入口，其负载压力大且易遭到攻击，存在单点故障的风险，所以我们需要一个高可用的方案来实现当一台反向代理服务器宕机的时候，另一台服务器会自动接管服务。基于以上要求，我们使用HAProxy，KeepAlived来构建高可用的反向代理系统。&lt;/p&gt;

&lt;h3&gt;介绍&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://haproxy.1wt.eu/&quot; title=&quot;HAProxy&quot;&gt;HAProxy&lt;/a&gt;是高性能的代理服务器，其可以提供7层和4层代理，具有healthcheck，负载均衡等多种特性，性能卓越，包括Twitter，Reddit，StackOverflow，GitHub在内的多家知名互联网公司在&lt;a href=&quot;http://haproxy.1wt.eu/they-use-it.html&quot; title=&quot;they use haproxy&quot;&gt;使用&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.keepalived.org/&quot; title=&quot;keepalived&quot;&gt;KeepAlived&lt;/a&gt;是一个高可用方案，通过VIP(即虚拟IP)和心跳检测来实现高可用。其原理是存在一组（两台）服务器，分别赋予Master,Backup两个角色，默认情况下Master会绑定VIP到自己的网卡上，对外提供服务。Master,Backup会在一定的时间间隔向对方发送心跳数据包来检测对方的状态，这个时间间隔一般为2秒钟，如果Backup发现Master宕机，那么Backup会发送ARP包到网关，把VIP绑定到自己的网卡，此时Backup对外提供服务，实现自动化的故障转移，当Master恢复的时候会重新接管服务。&lt;/p&gt;

&lt;h3&gt;环境&lt;/h3&gt;

&lt;p&gt;OS: CentOS Linux release 6.0 (Final) 2.6.32-71.29.1.el6.x86_64  &lt;br/&gt;
HAProxy: 1.4.18 &lt;br/&gt;
KeepAlived: 1.2.2 &lt;br/&gt;
VIP: 192.168.1.99 &lt;br/&gt;
M: 192.168.1.222 &lt;br/&gt;
S: 192.168.1.189&lt;/p&gt;

&lt;h3&gt;架构&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;                    192.168.1.99
             +-----------VIP----------+   
             |                        |
             |                        |
           Master                   Backup
        192.168.1.189            192.168.1.222
        +----------+             +----------+
        | HAProxy  |             | HAProxy  |
        |keepalived|             |keepalived|
        +----------+             +----------+
             |  
             v  
    +--------+---------+ 
    |        |         |
    |        |         |
    v        v         v
+------+  +------+  +------+
| WEB1 |  | WEB2 |  | WEB3 |
+------+  +------+  +------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;安装HAProxy&lt;/h3&gt;

&lt;p&gt;安装pcre&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ yum install pcre
$ wget http://haproxy.1wt.eu/download/1.4/src/haproxy-1.4.18.tar.gz
$ tar -zxvf haproxy-1.4.18.tar.gz
$ cd haproxy-1.4.18
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意编译参数：   &lt;br/&gt;
TARGET是指自己系统的内核版本 ARCH指定系统是32位还是64位   &lt;br/&gt;
CPU=native: use the build machine's specific processor optimizations  &lt;br/&gt;
更多编译参数内容见源码中的README  &lt;br/&gt;
    $ make TARGET=linux26 ARCH=x86_64 USE_PCRE=1 CPU=native
    $ make install&lt;/p&gt;

&lt;p&gt;配置文件 /etc/haproxy.cfg&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;global
    log 127.0.0.1   local3
    maxconn 20000   
    uid 535  #uid和gid按照实际情况进行配置
    gid 520  
    chroot /var/chroot/haproxy
    daemon 
    nbproc 1 

defaults
   log     127.0.0.1       local3
   mode    http            
   option  httplog
   option  httpclose
   option  dontlognull
   option  forwardfor
   retries 2
   balance roundrobin 
   stats   uri     /haproxy-stats
   contimeout      5000
   clitimeout      50000
   srvtimeout      50000

frontend http-in
        bind *:80 
        default_backend pool1

backend pool1
        option httpchk HEAD / HTTP/1.0
        stats refresh 2
        server WEB1 192.168.1.189:81 weight 3 maxconn 10000 check 
        server WEB2 192.168.1.222:81 weight 3 maxconn 10000 check
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看HAProxy的状态：http://192.168.1.99/haproxy-stats，这个页面会显示HAProxy本身以及后端服务器的状态。&lt;/p&gt;

&lt;h3&gt;日志&lt;/h3&gt;

&lt;p&gt;haproxy会把日志记录发送到syslog server(CentOS6下是rsyslogd，UDP514端口)， 编辑/etc/rsyslog.conf文件，添加如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ModLoad imudp
$UDPServerRun 514
$UDPServerAddress 127.0.0.1
local3.*                /var/log/haproxy.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启rsyslog&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ /etc/init.d/rsyslog restart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自动轮转日志，编辑/etc/logrotate.d/haproxy.cfg，添加如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/var/log/haproxy.log
{
    rotate 4
    daily
    missingok
    notifempty
    compress
    delaycompress
    sharedscripts
    postrotate
    reload rsyslog &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 || true
    endscript
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动脚本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wget -O haproxy https://raw.github.com/gist/3665034/4125bd5b81977a72e5eec30650fb21f3034782a0/haproxy-init.d 
$ cp haproxy /etc/init.d/haproxy
$ chmod +x /etc/init.d/haproxy
#使用方式
$ /etc/init.d/haproxy start|stop|restart
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;安装KeepAlived&lt;/h3&gt;

&lt;p&gt;安装依赖库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ yum install popt popt-devel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装KeepAlived&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wget http://www.keepalived.org/software/keepalived-1.2.2.tar.gz
$ tar -zxvf keepalived-1.2.2.tar.gz
$ cd keepalived-1.2.2
$ ./configure --prefix=/usr/local/keepalived
$ make &amp;amp;&amp;amp; make install

$ cp /usr/local/keepalived/etc/rc.d/init.d/keepalived /etc/init.d/keepalived
$ cp /usr/local/keepalived/sbin/keepalived /usr/sbin/
$ cp /usr/local/keepalived/etc/sysconfig/keepalived /etc/sysconfig/
$ mkdir -p /etc/keepalived/
$ cp /usr/local/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/keepalived.conf 
$ chmod +x /etc/init.d/keepalived
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用方式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ /etc/init.d/keepalived start|stop|restart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Master服务器上的配置 /etc/keepalived/keepalived.conf&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;global_defs {

   notification_email {
       user@example.com
   }

   notification_email_from mail@example.org
   smtp_server 192.168.x.x
   smtp_connect_timeout 30
   router_id LVS_DEVEL
}

#监测haproxy进程状态，每2秒执行一次
vrrp_script chk_haproxy {
    script &quot;/usr/local/keepalived/chk_haproxy.sh&quot;
    interval 2
    weight 2
}

vrrp_instance VI_1 {
    state MASTER #标示状态为MASTER
    interface eth0
    virtual_router_id 51
    priority 101   #MASTER权重要高于BACKUP
    advert_int 1
    mcast_src_ip 192.168.1.189 #Master服务器IP

    authentication {
        auth_type PASS #主从服务器验证方式
        auth_pass 1111
    }

    track_script {
        chk_haproxy #监测haproxy进程状态
    }

    #VIP
    virtual_ipaddress {
        192.168.1.99 #虚拟IP
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bakcup服务器上的配置 /etc/keepalived/keepalived.conf&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;global_defs {
   notification_email {
   user@example.com
   }

   notification_email_from mail@example.org
   smtp_server 192.168.x.x
   smtp_connect_timeout 30
   router_id LVS_DEVEL
}

#监测haproxy进程状态，每2秒执行一次
vrrp_script chk_haproxy {
    script &quot;/usr/local/keepalived/chk_haproxy.sh&quot;
    interval 2
    weight 2
}

vrrp_instance VI_1 {
    state BACKUP #状态为BACKUP
    interface eth0
    virtual_router_id 51
    priority 100  #权重要低于MASTER
    advert_int 1
    mcast_src_ip 192.168.1.222 #Backup服务器的IP

    authentication {
        auth_type PASS
        auth_pass 1111
    }

    track_script {
        chk_haproxy #监测haproxy进程状态
    }

    #VIP
    virtual_ipaddress {
        192.168.1.99 #虚拟IP
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;chk_haproxy.sh内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
#
# author: weizhifeng
# description: 
# 定时查看haproxy是否存在，如果不存在则启动haproxy，
# 如果启动失败，则停止keepalived
# 
status=$(ps aux|grep haproxy | grep -v grep | grep -v bash | wc -l)
if [ &quot;${status}&quot; = &quot;0&quot; ]; then
    /etc/init.d/haproxy start

    status2=$(ps aux|grep haproxy | grep -v grep | grep -v bash |wc -l)

    if [ &quot;${status2}&quot; = &quot;0&quot;  ]; then
            /etc/init.d/keepalived stop
    fi
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;高可用测试&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在Master上停止keepalived，查看系统日志，发现MASTER释放了VIP&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $ /etc/init.d/keepalived stop
 $ tail -f /var/log/message
 Keepalived: Terminating on signal Keepalived: Stopping Keepalived v1.2.2 (11/03,2011) 
 Keepalived_vrrp: Terminating VRRP child process on signal 
 Keepalived_vrrp: VRRP_Instance(VI_1) removing protocol VIPs.
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在Backup上查看系统日志，发现Backup已经进入MASTER角色，并且绑定了VIP 192.168.1.99&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $ tail -f /var/log/message
 Keepalived_vrrp: VRRP_Instance(VI_1) Entering MASTER STATE
 Keepalived_vrrp: VRRP_Instance(VI_1) setting protocol VIPs
 Keepalived_vrrp: VRRP_Instance(VI_1) Sending gratuitous ARPs on eth0 for 192.168.1.99 #在Backup上查看VIP是否已经绑定
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在Master上重新启动keepalived，查看系统日志，发现重新获得MASTER角色，并且绑定VIP 192.168.1.99&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $ /etc/init.d/keepalived start
 $ tail -f /var/log/message
 Keepalived_vrrp: VRRP_Instance(VI_1) Transition to MASTER STATE
 Keepalived_vrrp: VRRP_Instance(VI_1) Entering MASTER STATE
 Keepalived_vrrp: VRRP_Instance(VI_1) setting protocol VIPs.
 Keepalived_vrrp: VRRP_Instance(VI_1) Sending gratuitous ARPs on eth0 for 192.168.1.99
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在Backup上查看系统日志，发现其重新回到BACKUP角色，并且释放VIP&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $ tail -f /var/log/message
 Keepalived_vrrp: VRRP_Instance(VI_1) Received higher prio advert
 Keepalived_vrrp: VRRP_Instance(VI_1) Entering BACKUP STATE
 Keepalived_vrrp: VRRP_Instance(VI_1) removing protocol VIPs.
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;并发测试&lt;/h3&gt;

&lt;p&gt;我们使用webbench来对HAProxy进行并发测试&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ yum install ctags
$ wget http://home.tiscali.cz/~cz210552/distfiles/webbench-1.5.tar.gz
$ tar -zxvf webbench-1.5.tar.gz
$ cd webbench-1.5
$ make 
$ mkdir -p /usr/local/man &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试环境：  &lt;br/&gt;
CPU：Intel 双核 x86_64 主频3191MHZ &lt;br/&gt;
Mem：2G&lt;br/&gt;
修改php-fpm.conf，设置PHP-FPM spawn的进程数量为100：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pm.start_servers = 100
pm.max_spare_servers = 100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ webbench -c 100 -t 3000 http://192.168.1.99/check.txt
$ webbench -c 100 -t 3000 http://192.168.1.99/test.php
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试结果：&lt;/p&gt;

&lt;p&gt;并发访问txt文件，HAProxy的session数量为10000左右，这说明HAProxy能够hold住10000个并发连接；并发访问php文件，HAProxy的session峰值为200左右，接近于后端PHP的并发处理能力(100x2)。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://haproxy.1wt.eu/download/1.4/doc/configuration.txt&quot;&gt;http://haproxy.1wt.eu/download/1.4/doc/configuration.txt&lt;/a&gt;
&lt;a href=&quot;http://kevin.vanzonneveld.net/techblog/article/haproxy_logging/&quot;&gt;http://kevin.vanzonneveld.net/techblog/article/haproxy_logging/&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>中秋夜於蘇州</title>
   <link href="http://weizhifeng.net/23230184594.html"/>
   <updated>2011-10-23T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/23230184594</id>
   <content type="html">&lt;p&gt;秋露凝桂香   &lt;br/&gt;
月下望故鄉  &lt;br/&gt;
窗外地白處  &lt;br/&gt;
明月還是霜&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PHP的Realpath Cache</title>
   <link href="http://weizhifeng.net/php-realpath-cache.html"/>
   <updated>2011-10-22T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/php-realpath-cache</id>
   <content type="html">&lt;h3&gt;前言&lt;/h3&gt;

&lt;p&gt;PHP的缓存有很多种，包括输出缓冲(&lt;a href=&quot;http://cn.php.net/manual/en/ref.outcontrol.php&quot; title=&quot;outcontrol&quot;&gt;ob系列函数&lt;/a&gt;)，opcode缓存(&lt;a href=&quot;http://php.net/manual/en/book.apc.php&quot; title=&quot;apc&quot;&gt;APC&lt;/a&gt;，&lt;a href=&quot;http://sourceforge.net/projects/eaccelerator/&quot; title=&quot;eaccelerator&quot;&gt;eAccelerator&lt;/a&gt;，&lt;a href=&quot;http://xcache.lighttpd.net/&quot; title=&quot;xcache&quot;&gt;XCache&lt;/a&gt;等扩展实现)，这些大家已经很熟悉了，接下来介绍一下一个不太被人注意的PHP缓存机制：Realpath Cache。&lt;/p&gt;

&lt;h3&gt;介绍&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;require&lt;/strong&gt;，&lt;strong&gt;require_once&lt;/strong&gt;，&lt;strong&gt;include&lt;/strong&gt;，&lt;strong&gt;include_once&lt;/strong&gt;这四个语句(并非函数)大家经常会用到，如果用这类语句去包含文件(相对路径)的话，那么PHP会去&lt;a href=&quot;http://cn2.php.net/manual/zh/ini.core.php#ini.include-path&quot; title=&quot;include path&quot;&gt;include_path&lt;/a&gt;所指定的路径中去查找相关文件。一个应用中会存在大量的require_once语句调用，如果每次调用都去include_path中查找相应的文件，势必会对应用的性能产生负面影响。为了避免这种负面效应产生的影响，PHPER们会使用文件的绝对路径来包含所需的文件，这样就减少了查询include_path的次数。 其实，PHP自5.1.0起，就引入了&lt;a href=&quot;http://php.net/manual/en/ini.core.php#ini.sect.performance&quot; title=&quot;Real path Cache&quot;&gt;RealpathCache&lt;/a&gt;。RealpathCache可以把PHP所用到文件的&lt;a href=&quot;http://cn2.php.net/manual/en/function.realpath.php&quot; title=&quot;realpath&quot;&gt;realpath&lt;/a&gt;进行缓存，以便PHP再使用这些文件的时候不需要再去include_path中查找，加快PHP的执行速度。&lt;/p&gt;

&lt;h3&gt;配置&lt;/h3&gt;

&lt;p&gt;realpath cache的&lt;a href=&quot;http://us2.php.net/manual/en/ini.core.php#ini.realpath-cache-size&quot; title=&quot;realpath cache 配置&quot;&gt;配置项&lt;/a&gt;有两个，分别为&lt;strong&gt;realpath_cache_size&lt;/strong&gt;和&lt;strong&gt;realpath_cache_ttl&lt;/strong&gt;，可以在php.ini中进行修改：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;; Determines the size of the realpath cache to be used by PHP. This value should
; be increased on systems where PHP opens many files to reflect the quantity of
; the file operations performed.
; http://php.net/realpath-cache-size
;realpath_cache_size = 16k

; Duration of time, in seconds for which to cache realpath information for a given
; file or directory. For systems with rarely changing files, consider increasing this
; value.
; http://php.net/realpath-cache-ttl
;realpath_cache_ttl = 120
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中realpath_cache_size指定了realpath cache的大小，默认为16k，如果你觉得这个容量太小，可以适当增加；realpath_cache_ttl指定了缓存的过期时间，默认为120秒，对于不经常修改的生产环境来说，这个数字可以调整的更大些。&lt;/p&gt;

&lt;h3&gt;问题&lt;/h3&gt;

&lt;p&gt;由于realpath会展开symlink(即软连接)，所以如果你使用修改symlink目标这种方式发布应用的新版本的话，realpath cache会导致一些问题的出现：当你修改symlink使其指向一个新的release目录时候，由于realpath cache所缓存内容还没有过期，于是就会出现应用使用的还是旧的release，直到realpath cache所缓存内容过期失效为止(默认120秒)，或者重启php-fpm。&lt;/p&gt;

&lt;p&gt;看个例子：
基础环境：nginx + fastcgi + php-fpm  &lt;br/&gt;
应用环境：/var/www/app是一个symlink，并做为document_root，在/var/www下存在version0.1，version0.2两个版本的release。   &lt;br/&gt;
初始情况下/var/www/app指向version0.1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lrwxr-xr-x    1 weizhifeng  staff    10 10 22 16:41 app -&amp;gt; version0.1
drwxr-xr-x    3 weizhifeng  staff   102 10 22 16:43 version0.1
drwxr-xr-x    3 weizhifeng  staff   102 10 22 16:43 version0.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;version0.1，version0.2内部各有一个hello.php&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat version0.1/hello.php 
&amp;lt;?php 
echo 'in version0.1';
?&amp;gt;

$ cat version0.2/hello.php 
&amp;lt;?php 
echo 'in version0.2';
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nginx配置文件片段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;location / {
    root /var/www/app;   #app为symlink
    index  index.php index.html index.htm;
}

location ~ .php$ {
    root /var/www/app; #app为symlink
    fastcgi_pass   127.0.0.1:9000;
    fastcgi_index  index.php;
    include        fastcgi_params;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时通过HTTP访问hello.php，得到的内容是「in version0.1」；修改/var/www/app，使其指向version0.2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rm -f app &amp;amp;&amp;amp; ln -s version0.2 app
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改完成之后通过HTTP访问hello.php，得到的内容仍旧是「in version0.1」，可见是realpath cache在作祟了，此时你可以重启php-fpm或者等待120秒钟让realpath cache失效。 你可以使用&lt;a href=&quot;http://us3.php.net/clearstatcache&quot; title=&quot;clearstatcache&quot;&gt;clearstatcache&lt;/a&gt;来清除realpath cache，但是这个只对当前调用clearstatcache函数的PHP进程有效，而其他的PHP进程还是无效，由于PHP进程池（php-fpm生成，或者Apache在prefork模式下产生的N个httpd子进程）的存在，这个方法不是很适用。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://php.net/manual/en/ini.core.php#ini.sect.performance&quot;&gt;http://php.net/manual/en/ini.core.php#ini.sect.performance&lt;/a&gt;
&lt;a href=&quot;http://sixohthree.com/1517/php-and-the-realpath-cache&quot;&gt;http://sixohthree.com/1517/php-and-the-realpath-cache&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PHP二进制安全</title>
   <link href="http://weizhifeng.net/php-binary-safe.html"/>
   <updated>2011-09-10T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/php-binary-safe</id>
   <content type="html">&lt;h3&gt;前言&lt;/h3&gt;

&lt;p&gt;在PHP中经常看到一些函数有个标识「&lt;a href=&quot;http://en.wikipedia.org/wiki/Binary-safe&quot; title=&quot;Binary safe&quot;&gt;binary safe&lt;/a&gt;」，即二进制安全，这是个什么概念呢？ 在一个字符串中会包含很多的字符，这其中就包括NULL。「binary safe」的函数会把它的输入字符串原封不动的进行处理；而非「binary safe」的函数是在底层直接调用C的字符串相关的函数，而这些函数处理一个字符串会把NULL后边的内容忽略掉。&lt;/p&gt;

&lt;h3&gt;例子&lt;/h3&gt;

&lt;p&gt;以下例子中，如果函数&lt;a href=&quot;http://cn2.php.net/manual/en/function.strlen.php&quot; title=&quot;strlen&quot;&gt;strlen&lt;/a&gt;是binary safe的话，我们将得到7；如果函数是非binary safe的话，我们将得到3
，由于strlen是binary safe的，所以实际上以下的运行结果是7：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
$str = &quot;abcx00abc&quot;; //x00为NULL
echo strlen($str);  //7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/3264514/in-php-what-does-it-mean-by-a-function-being-binary-safe&quot;&gt;http://stackoverflow.com/questions/3264514/in-php-what-does-it-mean-by-a-function-being-binary-safe&lt;/a&gt;
&lt;a href=&quot;http://en.wikipedia.org/wiki/Binary-safe&quot;&gt;http://en.wikipedia.org/wiki/Binary-safe&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Sed</title>
   <link href="http://weizhifeng.net/learning-sed.html"/>
   <updated>2011-08-10T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/learning-sed</id>
   <content type="html">&lt;h3&gt;介绍&lt;/h3&gt;

&lt;p&gt;Sed（&lt;strong&gt;s&lt;/strong&gt;tream &lt;strong&gt;ed&lt;/strong&gt;itor），是个非常方便的流处理器，其执行流程如下： 拷贝输入流中第一行的内容到模式空间（pattern space），如果地址约束（address restriction）成立，那么对模式空间的内容执行第一个sed命令，然后接着执行下一条sed命令，当最后的操作执行完之后，输出模式空间的内容，读入下一行内容。&lt;/p&gt;

&lt;h3&gt;地址约束（address restriction）&lt;/h3&gt;

&lt;p&gt;就是对输入的行进行一个条件测试，如果满足就执行接下来的sed命令，否则不执行，主要有以下类型：  &lt;br/&gt;
* 5,8表示输入的行位于第5到第8行之间   &lt;br/&gt;
* /match/表示输入的行中匹配到了match  &lt;br/&gt;
* /start/,/stop/表示从匹配到start开始，到匹配到stop为止，输入行位于这个区间  &lt;br/&gt;
* 5,/stop/表示从第5行开始，到匹配到stop为止，输入行位于这个区间&lt;/p&gt;

&lt;h3&gt;语法格式&lt;/h3&gt;

&lt;p&gt;单条命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed 'address command' &amp;lt; in &amp;gt; out
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -e 'address command'  -e 'address2 command2' &amp;lt; in &amp;gt; out 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果命令太多，可以把命令放在一个文件script-file中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -f script-file &amp;lt; in &amp;gt; out 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;常用命令&lt;/h3&gt;

&lt;h3&gt;1. s（substitute）这个命令是我们用的最多的，用来进行文本替换&lt;/h3&gt;

&lt;p&gt;把old.txt中的&quot;foo&quot;全部(g的作用)替换成&quot;bar&quot;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed 's/foo/bar/g' old.txt &amp;gt; new.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只替换第二个&quot;foo&quot;为&quot;bar&quot;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed 's/foo/bar/2' old.txt &amp;gt; new.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;amp;代表匹配的字符内容，以下会把“foo”替换成“(foo)”&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo foo | sed 's/[a-z]+/(&amp;amp;)/'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以用1,2...9来引用正则表达式的子模式，以下的输出是“bar foo”&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo foo bar | sed 's/([a-z]*) ([a-z]*)/2 1/'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认情况下sed会把替换之后的内容完全输出，以下命令可以让sed只输出被修改过的内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -n 's/foo/(&amp;amp;)/p' new.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这只会对第5行至第8行进行处理，其中“5,8”为一个区间，与“s/foo/(foo)/”之间有一个空格&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed '5,8 s/foo/(foo)/'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下会对101行以后（包括101）的内容做替换，“$”代表最后一行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed '101,$ s/foo/bar/'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下会对文本中含有&quot;start&quot;行的内容进行替换&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed '/start/ s/foo/bar/'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果一个表达式以反斜杠开始，那么接下来的字符就是分隔符。以下使用&quot;,&quot;来作为分隔符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed ',^#, s/[0-9][0-9]*//'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以指定两个正则表达式作为一个区间。以下会删除“start” “stop”两个关键词之间的注释&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed '/start/,/stop/ s/#.*//'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以把行号和正则表达式合并在一起。以下将会从文件第一行开始到匹配到“start”为止，把这个范围内的注释删掉&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -e '1,/start/ s/#.*//'
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2. d（delete）这个命令用来删除必要的行&lt;/h3&gt;

&lt;p&gt;以下把11行之后的内容删掉&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed '11,$ d'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下为删除所有空白和tab&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -e 's/#.*//' -e 's/[ ^I]*$//' -e '/^$/ d'
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;3. p（print） 这个命令用来控制sed的输出&lt;/h3&gt;

&lt;p&gt;打印前10行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -n '1,10 p'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打印匹配的内容，和'grep match'一样的效果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -n '/match/ p'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不打印匹配的内容，和'grep -v match'一样的效果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -n '/match/ !p'
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;4. q（quit）命令用来在适当的时候让sed退出&lt;/h3&gt;

&lt;p&gt;在第11行退出&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed '11 q'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;q命令不能用在区间中，以下是错的，因为你不可能让sed退出10次&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed '1,10 q'
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;5. w（write）这个命令用来把处理过的内容写入指定的文件&lt;/h3&gt;

&lt;p&gt;把&quot;in&quot;中的偶数写入文件&quot;even&quot;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -n 's/^[0-9]*[02468]/&amp;amp;/w even' &amp;lt; in
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;6. r（read）这个命令用来读入指定文件的内容&lt;/h3&gt;

&lt;p&gt;以下在包含INCLUDE的行后面插入&quot;file&quot;文件的内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed '/INCLUDE/ r file' &amp;lt; in
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;7. a（add）, c（chang）,i（insert）&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;a 在匹配行后面添加一行&lt;/li&gt;
&lt;li&gt;c 替换匹配内容的行&lt;/li&gt;
&lt;li&gt;i 在匹配行前面添加一行&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;在WORD后面插入一行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed '
    /WORD/ a
    Add this line after every line with WORD
'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在WORD前面插入一行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed '
    /WORD/ i
    Add this line before evey line before WORD
'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;替换WORD所在行的内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed '
    /WORD/ c
    Replace the current line with the line
'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上三个命令都可以插入多行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed '
    /WORD/ a
    Add this line
    This line
    And this line
'
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;8. = 命令用来输出行号&lt;/h3&gt;

&lt;p&gt;输出行号
    sed -n '/foo/ =' test.txt&lt;/p&gt;

&lt;p&gt;输出最大行号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -n '$=' test.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;9. y这个命令用来做转换用&lt;/h3&gt;

&lt;p&gt;把单词从小写装换成大写&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed 'y/abcdef/ABCDEF/' file
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;分组&lt;/h3&gt;

&lt;p&gt;你可以用「{」和「}」来把命令分组，如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/sh
# This is a Bourne shell script that removes #-type comments
# between 'begin' and 'end' words.
sed -n '
    /begin/,/end/ {
    s/#.*//
    s/[ ^I]*$//
    /^$/ d
    p
    }
'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.grymoire.com/Unix/Sed.html&quot;&gt;http://www.grymoire.com/Unix/Sed.html&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>半日閑</title>
   <link href="http://weizhifeng.net/23997919999.html"/>
   <updated>2011-07-27T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/23997919999</id>
   <content type="html">&lt;p&gt;浮生難得半日閑  &lt;br/&gt;
縱貫金陵北與南  &lt;br/&gt;
得失安知是福禍  &lt;br/&gt;
月有陰缺才更圓&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PHP扩展编写第二步：参数，数组，以及ZVAL「续」</title>
   <link href="http://weizhifeng.net/write-php-extension-part2-2.html"/>
   <updated>2011-07-20T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/write-php-extension-part2-2</id>
   <content type="html">&lt;h3&gt;拷贝 VS 引用&lt;/h3&gt;

&lt;p&gt;这有两个方法来引用一个&lt;code&gt;zval&lt;/code&gt;。第一种，上面介绍过的，叫做&lt;strong&gt;copy-on-write referencing&lt;/strong&gt;。第二种，叫做&lt;strong&gt;full referencing&lt;/strong&gt;，就是用户空间脚本编写者非常熟悉的「引用」关系，当写出如下代码：&lt;code&gt;$a = &amp;amp;$b;&lt;/code&gt;的时候就会发生。
在一个zval中，这两种类型通过成员&lt;code&gt;is_ref&lt;/code&gt;区分开来，当&lt;code&gt;is_ref&lt;/code&gt;为0的时候是拷贝引用（copy references），非0的时候就是完全引用（full references）。注意一个&lt;code&gt;zval&lt;/code&gt;不可能既是拷贝引用，又是完全引用。所以如果一个变量刚开始&lt;code&gt;is_ref&lt;/code&gt;值非0，然后作为一个拷贝被赋给了一个新变量，那么肯定会执行一个完全拷贝。考虑下面的用户空间代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
    $a = 1;
    $b = &amp;amp;$a;
    $c = $a;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这段代码中，为$a变量创建了一个&lt;code&gt;zval&lt;/code&gt;，初始化&lt;code&gt;is_ref&lt;/code&gt;为0，&lt;code&gt;refcount&lt;/code&gt;为1。当&lt;code&gt;$a&lt;/code&gt;以引用的方式赋给了&lt;code&gt;$b&lt;/code&gt;，其&lt;code&gt;is_ref&lt;/code&gt;变成了1，然后&lt;code&gt;refcount&lt;/code&gt;增加到2。当把$a赋给$c的时候，Zend Engine不能简单的把&lt;code&gt;refcount&lt;/code&gt;增加到3，因为&lt;code&gt;$c&lt;/code&gt;将被看做是&lt;code&gt;$a&lt;/code&gt;的完全引用。关闭&lt;code&gt;is_ref&lt;/code&gt;也不会起作用，因为如果这样做的话&lt;code&gt;$b&lt;/code&gt;就是&lt;code&gt;$a&lt;/code&gt;的一个拷贝了，而不是一个引用了。所以这个时候一个新的&lt;code&gt;zval&lt;/code&gt;被分配了，然后通过&lt;code&gt;zval_copy_ctor()&lt;/code&gt;来把原始的值拷贝进来。原始的zval现在是&lt;code&gt;is_ref==1&lt;/code&gt;，&lt;code&gt;refcount==2&lt;/code&gt;，而新的&lt;code&gt;zval&lt;/code&gt;中&lt;code&gt;is_ref=0&lt;/code&gt;，&lt;code&gt;refcount=1&lt;/code&gt;。现在让我们稍微把代码顺序调整一下再看：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
    $a = 1;
    $c = $a;
    $b = &amp;amp;$a;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终的结果是一样的，&lt;code&gt;$b&lt;/code&gt;是&lt;code&gt;$a&lt;/code&gt;的完全引用，&lt;code&gt;$c&lt;/code&gt;是&lt;code&gt;$a&lt;/code&gt;的一个拷贝。这次，内部的行为稍微有些不同。像之前一样，在开始的时候为&lt;code&gt;$a&lt;/code&gt;创建了一个新的&lt;code&gt;zval&lt;/code&gt;，然后设置&lt;code&gt;is_ref==0&lt;/code&gt;，&lt;code&gt;refcount=1&lt;/code&gt;。之后，&lt;code&gt;$c = $a;&lt;/code&gt;这个语句把上面那个相同的&lt;code&gt;zval&lt;/code&gt;赋给&lt;code&gt;$c&lt;/code&gt;变量，同时增加&lt;code&gt;refcount&lt;/code&gt;到2，&lt;code&gt;is_ref&lt;/code&gt;仍然是0。当Zend Engine遇到&lt;code&gt;$b = &amp;amp;amp;$a;&lt;/code&gt;的时候，它只是想要设置is_ref为1，但是不能这么做因为这么做会影响&lt;code&gt;$c&lt;/code&gt;。替代的做法是它创建一个新的&lt;code&gt;zval&lt;/code&gt;，通过zval_copy_ctor()来把原始的内容拷贝进来，然后对原始&lt;code&gt;zval&lt;/code&gt;的&lt;code&gt;refcount&lt;/code&gt;减一从而来指明$a不在使用那个&lt;code&gt;zval&lt;/code&gt;了。它把新&lt;code&gt;zval&lt;/code&gt;的&lt;code&gt;is_ref&lt;/code&gt;设置为1，&lt;code&gt;refcount&lt;/code&gt;设置为2，然后更新&lt;code&gt;$a&lt;/code&gt;和&lt;code&gt;$b&lt;/code&gt;变量，让其引用这个&lt;code&gt;zval&lt;/code&gt;。&lt;/p&gt;

&lt;h3&gt;完整性检查&lt;/h3&gt;

&lt;p&gt;像之前一样，我们三个主要文件中的完整代码已经列在下面了：&lt;/p&gt;

&lt;h3&gt;config.m4&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;PHP_ARG_ENABLE(hello, [whether to enable Hello World support],
[ --enable-hello   Enable Hello World support])

if test &quot;$PHP_HELLO&quot; = &quot;yes&quot;; then
  AC_DEFINE(HAVE_HELLO, 1, [Whether you have Hello World])
  PHP_NEW_EXTENSION(hello, hello.c, $ext_shared)
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;php_hello.h&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#ifndef PHP_HELLO_H
#define PHP_HELLO_H 1

#ifdef ZTS
#include &quot;TSRM.h&quot;
#endif

ZEND_BEGIN_MODULE_GLOBALS(hello)
    long counter;
    zend_bool direction;
ZEND_END_MODULE_GLOBALS(hello)

#ifdef ZTS
#define HELLO_G(v) TSRMG(hello_globals_id, zend_hello_globals *, v)
#else

#define HELLO_G(v) (hello_globals.v)

#endif

#define PHP_HELLO_WORLD_VERSION &quot;1.0&quot;

#define PHP_HELLO_WORLD_EXTNAME &quot;hello&quot;

PHP_MINIT_FUNCTION(hello);
PHP_MSHUTDOWN_FUNCTION(hello);
PHP_RINIT_FUNCTION(hello);

PHP_FUNCTION(hello_world);
PHP_FUNCTION(hello_long);
PHP_FUNCTION(hello_double);

PHP_FUNCTION(hello_bool);
PHP_FUNCTION(hello_null);
PHP_FUNCTION(hello_greetme);

PHP_FUNCTION(hello_add);
PHP_FUNCTION(hello_dump);
PHP_FUNCTION(hello_array);

PHP_FUNCTION(hello_array_strings);
PHP_FUNCTION(hello_array_walk);
PHP_FUNCTION(hello_array_value);
PHP_FUNCTION(hello_get_global_var);
PHP_FUNCTION(hello_set_local_var);

extern zend_module_entry hello_module_entry;

#define phpext_hello_ptr &amp;amp;hello_module_entry

#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;hello.c&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#ifdef HAVE_CONFIG_H
#include &quot;config.h&quot;
#endif


#include &quot;php.h&quot;
#include &quot;php_ini.h&quot;
#include &quot;php_hello.h&quot;

ZEND_DECLARE_MODULE_GLOBALS(hello)

static function_entry hello_functions[] = {
    PHP_FE(hello_world, NULL)
    PHP_FE(hello_long, NULL)
    PHP_FE(hello_double, NULL)
    PHP_FE(hello_bool, NULL)
    PHP_FE(hello_null, NULL)
    PHP_FE(hello_greetme, NULL)
    PHP_FE(hello_add, NULL)
    PHP_FE(hello_dump, NULL)
    PHP_FE(hello_array, NULL)
    PHP_FE(hello_array_strings, NULL)
    PHP_FE(hello_array_walk, NULL)
    PHP_FE(hello_array_value, NULL)
    PHP_FE(hello_get_global_var, NULL)
    PHP_FE(hello_set_local_var, NULL)
    {NULL, NULL, NULL}
};

zend_module_entry hello_module_entry = {

#if ZEND_MODULE_API_NO &amp;gt;= 20010901
    STANDARD_MODULE_HEADER,
#endif

    PHP_HELLO_WORLD_EXTNAME,
    hello_functions,
    PHP_MINIT(hello),
    PHP_MSHUTDOWN(hello),
    PHP_RINIT(hello),
    NULL,
    NULL,
#if ZEND_MODULE_API_NO &amp;gt;= 20010901
    PHP_HELLO_WORLD_VERSION,
#endif
    STANDARD_MODULE_PROPERTIES

};

#ifdef COMPILE_DL_HELLO
    ZEND_GET_MODULE(hello)
#endif

PHP_INI_BEGIN()
    PHP_INI_ENTRY(&quot;hello.greeting&quot;, &quot;Hello World&quot;, PHP_INI_ALL, NULL)
    STD_PHP_INI_ENTRY(&quot;hello.direction&quot;, &quot;1&quot;, PHP_INI_ALL, OnUpdateBool, direction, zend_hello_globals, hello_globals)
PHP_INI_END()

static void php_hello_init_globals(zend_hello_globals *hello_globals)
{
    hello_globals-&amp;gt;direction = 1;
}

PHP_RINIT_FUNCTION(hello)
{
    HELLO_G(counter) = 0;
    return SUCCESS;
}

PHP_MINIT_FUNCTION(hello)
{
    ZEND_INIT_MODULE_GLOBALS(hello, php_hello_init_globals, NULL);
    REGISTER_INI_ENTRIES();
    return SUCCESS;
}

PHP_MSHUTDOWN_FUNCTION(hello)
{
    UNREGISTER_INI_ENTRIES();
    return SUCCESS;
}

PHP_FUNCTION(hello_world)
{
    RETURN_STRING(&quot;Hello World&quot;, 1);
}

PHP_FUNCTION(hello_long)
{
    if (HELLO_G(direction)) {
        HELLO_G(counter)++;
    } else {
        HELLO_G(counter)--;
    }

    RETURN_LONG(HELLO_G(counter));
}

PHP_FUNCTION(hello_double)
{
    RETURN_DOUBLE(3.1415926535);
}

PHP_FUNCTION(hello_bool)
{
    RETURN_BOOL(1);
}

PHP_FUNCTION(hello_null)
{
    RETURN_NULL();
}

PHP_FUNCTION(hello_greetme)
{
    zval *zname;
    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;z&quot;, &amp;amp;zname) == FAILURE) {
        RETURN_NULL();
    }

    convert_to_string(zname);
    php_printf(&quot;Hello &quot;);
    PHPWRITE(Z_STRVAL_P(zname), Z_STRLEN_P(zname));
    php_printf(&quot; &quot;);

    RETURN_TRUE;
}

PHP_FUNCTION(hello_add)
{
    long a;
    double b;
    zend_bool return_long = 0;

    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;ld|b&quot;, &amp;amp;a, &amp;amp;b, &amp;amp;return_long) == FAILURE) {
        RETURN_NULL();
    }

    if (return_long) {
        RETURN_LONG(a + b);
    } else {
        RETURN_DOUBLE(a + b);
    }
}

PHP_FUNCTION(hello_dump)
{
    zval *uservar;

    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;z&quot;, &amp;amp;uservar) == FAILURE) {
    RETURN_NULL();
    }

    switch (Z_TYPE_P(uservar)) {

    case IS_NULL:
        php_printf(&quot;NULL &quot;);
        break;

    case IS_BOOL:
        php_printf(&quot;Boolean: %s &quot;, Z_LVAL_P(uservar) ? &quot;TRUE&quot; : &quot;FALSE&quot;);
        break;

    case IS_LONG:
        php_printf(&quot;Long: %ld &quot;, Z_LVAL_P(uservar));
        break;

    case IS_DOUBLE:
        php_printf(&quot;Double: %f &quot;, Z_DVAL_P(uservar));
        break;

    case IS_STRING:
        php_printf(&quot;String: &quot;);
        PHPWRITE(Z_STRVAL_P(uservar), Z_STRLEN_P(uservar));
        php_printf(&quot; &quot;);
        break;

    case IS_RESOURCE:
        php_printf(&quot;Resource &quot;);
        break;

    case IS_ARRAY:
        php_printf(&quot;Array &quot;);
        break;

    case IS_OBJECT:
        php_printf(&quot;Object &quot;);
        break;

    default:
        php_printf(&quot;Unknown &quot;);

    }

    RETURN_TRUE;

}

PHP_FUNCTION(hello_array)
{
    char *mystr;
    zval *mysubarray;
    array_init(return_value);
    add_index_long(return_value, 42, 123);
    add_next_index_string(return_value, &quot;I should now be found at index 43&quot;, 1);
    add_next_index_stringl(return_value, &quot;I'm at 44!&quot;, 10, 1);

    mystr = estrdup(&quot;Forty Five&quot;);
    add_next_index_string(return_value, mystr, 0);
    add_assoc_double(return_value, &quot;pi&quot;, 3.1415926535);

    ALLOC_INIT_ZVAL(mysubarray);
    array_init(mysubarray);
    add_next_index_string(mysubarray, &quot;hello&quot;, 1);
    php_printf(&quot;mysubarray-&amp;gt;refcount = %d &quot;, mysubarray-&amp;gt;refcount);
    mysubarray-&amp;gt;refcount = 2;
    php_printf(&quot;mysubarray-&amp;gt;refcount = %d &quot;, mysubarray-&amp;gt;refcount);
    add_assoc_zval(return_value, &quot;subarray&quot;, mysubarray);
    php_printf(&quot;mysubarray-&amp;gt;refcount = %d &quot;, mysubarray-&amp;gt;refcount);

}

PHP_FUNCTION(hello_array_strings)
{
    zval *arr, **data;
    HashTable *arr_hash;
    HashPosition pointer;
    int array_count;

    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;a&quot;, &amp;amp;arr) == FAILURE) {
        RETURN_NULL();
    }

    arr_hash = Z_ARRVAL_P(arr);
    array_count = zend_hash_num_elements(arr_hash);
    php_printf(&quot;The array passed contains %d elements &quot;, array_count);

    for(zend_hash_internal_pointer_reset_ex(arr_hash, &amp;amp;pointer); zend_hash_get_current_data_ex(arr_hash, (void**) &amp;amp;data, &amp;amp;pointer) == SUCCESS; zend_hash_move_forward_ex(arr_hash, &amp;amp;pointer)) {

        zval temp;
        char *key;
        int key_len;
        long index;

        if (zend_hash_get_current_key_ex(arr_hash, &amp;amp;key, &amp;amp;key_len, &amp;amp;index, 0, &amp;amp;pointer) == HASH_KEY_IS_STRING) {
            PHPWRITE(key, key_len);
        } else {
            php_printf(&quot;%ld&quot;, index);
        }

        php_printf(&quot; =&amp;gt; &quot;);

        temp = **data;
        zval_copy_ctor(&amp;amp;temp);
        convert_to_string(&amp;amp;temp);
        PHPWRITE(Z_STRVAL(temp), Z_STRLEN(temp));
        php_printf(&quot; &quot;);
        zval_dtor(&amp;amp;temp);
    }

    RETURN_TRUE;
}

static int php_hello_array_walk(zval **element TSRMLS_DC)
{
    zval temp;

    temp = **element;
    zval_copy_ctor(&amp;amp;temp);
    convert_to_string(&amp;amp;temp);
    PHPWRITE(Z_STRVAL(temp), Z_STRLEN(temp));
    php_printf(&quot; &quot;);
    zval_dtor(&amp;amp;temp);
    return ZEND_HASH_APPLY_KEEP;
}

static int php_hello_array_walk_arg(zval **element, char *greeting TSRMLS_DC)
{
    php_printf(&quot;%s&quot;, greeting);
    php_hello_array_walk(element TSRMLS_CC);
    return ZEND_HASH_APPLY_KEEP;
}

static int php_hello_array_walk_args(zval **element, int num_args, var_list args, zend_hash_key *hash_key)
{
    char *prefix = va_arg(args, char*);
    char *suffix = va_arg(args, char*);
    TSRMLS_FETCH();

    php_printf(&quot;%s&quot;, prefix);
    php_hello_array_walk(element TSRMLS_CC);
    php_printf(&quot;%s &quot;, suffix);

    return ZEND_HASH_APPLY_KEEP;
}

PHP_FUNCTION(hello_array_walk)
{
    zval *zarray;
    int print_newline = 1;

    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;a&quot;, &amp;amp;zarray) == FAILURE) {
        RETURN_NULL();
    }

    zend_hash_apply(Z_ARRVAL_P(zarray), (apply_func_t)php_hello_array_walk TSRMLS_CC);
    zend_hash_internal_pointer_reset(Z_ARRVAL_P(zarray));
    zend_hash_apply_with_argument(Z_ARRVAL_P(zarray), (apply_func_arg_t)php_hello_array_walk_arg, &quot;Hello &quot; TSRMLS_CC);
    zend_hash_apply_with_arguments(Z_ARRVAL_P(zarray), (apply_func_args_t)php_hello_array_walk_args, 2, &quot;Hello &quot;, &quot;Welcome to my extension!&quot;);

    RETURN_TRUE;
}

PHP_FUNCTION(hello_array_value)
{
    zval *zarray, *zoffset, **zvalue;
    long index = 0;
    char *key = NULL;
    int key_len = 0;

    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;az&quot;, &amp;amp;zarray, &amp;amp;zoffset) == FAILURE) {
    RETURN_NULL();
    }

    switch (Z_TYPE_P(zoffset)) {

    case IS_NULL:

        index = 0;
        break;

    case IS_DOUBLE:

        index = (long)Z_DVAL_P(zoffset);
        break;

    case IS_BOOL:

    case IS_LONG:

    case IS_RESOURCE:

        index = Z_LVAL_P(zoffset);
        break;

    case IS_STRING:

        key = Z_STRVAL_P(zoffset);
        key_len = Z_STRLEN_P(zoffset);
        break;

    case IS_ARRAY:

        key = &quot;Array&quot;;
        key_len = sizeof(&quot;Array&quot;) - 1;
        break;

    case IS_OBJECT:

        key = &quot;Object&quot;;
        key_len = sizeof(&quot;Object&quot;) - 1;
        break;

    default:

        key = &quot;Unknown&quot;;
        key_len = sizeof(&quot;Unknown&quot;) - 1;
    }

    if (key &amp;amp;&amp;amp; zend_hash_find(Z_ARRVAL_P(zarray), key, key_len + 1, (void**)&amp;amp;zvalue) == FAILURE) {
        php_error_docref(NULL TSRMLS_CC, E_NOTICE, &quot;Undefined index: %s&quot;, key);
        RETURN_NULL();

    } else if (!key &amp;amp;&amp;amp; zend_hash_index_find(Z_ARRVAL_P(zarray), index, (void**)&amp;amp;zvalue) == FAILURE) {
        php_error_docref(NULL TSRMLS_CC, E_NOTICE, &quot;Undefined index: %ld&quot;, index);
        RETURN_NULL();
    }

    *return_value = **zvalue;
    zval_copy_ctor(return_value);
}

PHP_FUNCTION(hello_get_global_var)
{
    char *varname;
    int varname_len;
    zval **varvalue;

    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;s&quot;, &amp;amp;varname, &amp;amp;varname_len) == FAILURE) {
        RETURN_NULL();
    }

    if (zend_hash_find(&amp;amp;EG(symbol_table), varname, varname_len + 1, (void**)&amp;amp;varvalue) == FAILURE) {
        php_error_docref(NULL TSRMLS_CC, E_NOTICE, &quot;Undefined variable: %s&quot;, varname);
        RETURN_NULL();
    }

    *return_value = **varvalue;
    zval_copy_ctor(return_value);
}

PHP_FUNCTION(hello_set_local_var)
{
    zval *newvar;
    char *varname;
    int varname_len;
    zval *value;

    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;sz&quot;, &amp;amp;varname, &amp;amp;varname_len, &amp;amp;value) == FAILURE) {
        RETURN_NULL();
    }

    ALLOC_INIT_ZVAL(newvar);
    *newvar = *value;
    zval_copy_ctor(newvar);

    zend_hash_add(EG(active_symbol_table), varname, varname_len + 1, &amp;amp;newvar, sizeof(zval*), NULL);
    RETURN_TRUE;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Gist:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;config.m4:    &lt;a href=&quot;https://gist.github.com/2843439&quot;&gt;https://gist.github.com/2843439&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;php_hello.h: &lt;a href=&quot;https://gist.github.com/2843449&quot;&gt;https://gist.github.com/2843449&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;hello.c:      &lt;a href=&quot;https://gist.github.com/2843458&quot;&gt;https://gist.github.com/2843458&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;下一步是什么？&lt;/p&gt;

&lt;p&gt;在这个扩展编写系列教程的第二部分中，你学到了如何接收函数参数，你创建和使用了数组，然后，最重要的，你看了&lt;code&gt;zval&lt;/code&gt;的内部工作过程。在第三部分，你将要看到&lt;code&gt;resource&lt;/code&gt;数据类型，并且和更加复杂的数据结构打交道。&lt;/p&gt;

&lt;p&gt;原文：&lt;a href=&quot;http://devzone.zend.com/node/view/id/1023&quot;&gt;http://devzone.zend.com/node/view/id/1023&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PHP扩展编写第二步：参数，数组，以及ZVAL</title>
   <link href="http://weizhifeng.net/write-php-extension-part2-1.html"/>
   <updated>2011-07-20T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/write-php-extension-part2-1</id>
   <content type="html">&lt;h3&gt;介绍&lt;/h3&gt;

&lt;p&gt;在这个系列教程的第一部分，你已经了解了一个PHP扩展的基本框架结构。你声明了一个简单的函数，这个函数向调用它的脚本返回静态和动态的值，定义了INI配置项，以及声明了内部的值（全局变量）。在这个教程中，你将会知道如何接收传递到你函数中的参数，并且认识到&lt;strong&gt;PHP&lt;/strong&gt;和&lt;strong&gt;Zend Engine&lt;/strong&gt;在内部是如何管理变量的。&lt;/p&gt;

&lt;h3&gt;接收参数&lt;/h3&gt;

&lt;p&gt;不像在用户空间的代码那样，一个内部函数的参数实际上不会声明在函数的头部。相反，参数列表的引用会传递到每个函数中 – 不管参数传递了没有 – 接下来函数就可以让Zend Engine把这些参数变成可以使用的变量。&lt;/p&gt;

&lt;p&gt;让我们来看一下这个过程，我们定义了一个新函数，&lt;code&gt;hello_greetme()&lt;/code&gt;，这个函数会接收1个参数，然后这个参数会和一些其他的问候语一起输出。像之前一样，我将在三个地方添加代码：&lt;/p&gt;

&lt;p&gt;在&lt;strong&gt;php_hello.h&lt;/strong&gt;文件靠近其他函数原型的地方：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PHP_FUNCTION(hello_greetme);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在hello.c文件中hello_functions结构体的结尾处：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PHP_FE(hello_bool, NULL)
    PHP_FE(hello_null, NULL)
    PHP_FE(hello_greetme, NULL)
    {NULL, NULL, NULL}
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在靠近hello.c文件结尾处，其他函数的后面：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PHP_FUNCTION(hello_greetme)
{
    char *name;
    int name_len;

    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;s&quot;, &amp;amp;name, &amp;amp;name_len) == FAILURE) {
        RETURN_NULL();
    }

    php_printf(&quot;Hello %s &quot;, name);
    RETURN_TRUE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;zend_parse_parameters()&lt;/code&gt;函数大部分的代码看起来几乎都一样。&lt;code&gt;ZEND_NUM_ARGS()&lt;/code&gt;向Zend Engine提供关于接收到的参数数量，&lt;code&gt;TSRMLS_CC&lt;/code&gt;被用来保证线程安全，最后函数会返回SUCCESS或者FAILURE。在普通情况下&lt;code&gt;zend_parse_parameters()&lt;/code&gt;将会返回&lt;code&gt;SUCCESS&lt;/code&gt;；如果一个调用脚本传递的参数数量超过了函数定义的参数数量，或者传递的参数不能转换成合适的数据类型，Zend将会自动的输出一个错误信息，然后函数会优雅地把控制权返回给调用脚本。&lt;/p&gt;

&lt;p&gt;在这个例子你使用“s”来指明这个函数只能接收一个参数，并且这个参数可以被转换成&lt;code&gt;string&lt;/code&gt;数据类型，存入通过引用传递的&lt;code&gt;char*&lt;/code&gt;变量中。&lt;/p&gt;

&lt;p&gt;注意一个&lt;code&gt;int&lt;/code&gt;变量也以引用的方式传递给了&lt;code&gt;zend_parse_parameters()&lt;/code&gt;。这个允许&lt;code&gt;Zend Engine&lt;/code&gt;来提供这个字符串的长度有多少字节，所以二进制安全的函数就不需要依赖&lt;code&gt;strlen(name)&lt;/code&gt;来检测字符串的长度。事实上，使用&lt;code&gt;strlen(name)&lt;/code&gt;有可能得不到正确的结果，因为&lt;code&gt;name&lt;/code&gt;可能在字符串末尾前面包含一个或者多个&lt;code&gt;NULL&lt;/code&gt;字符。&lt;/p&gt;

&lt;p&gt;一旦你的函数接收到了&lt;code&gt;name&lt;/code&gt;这个参数，函数接下来要做的事情就是输出一句正式问候语，并把&lt;code&gt;name&lt;/code&gt;参数的值作为其中的一部分。注意到我们使用了&lt;code&gt;php_printf()&lt;/code&gt;而没有使用更加熟悉的&lt;code&gt;printf()&lt;/code&gt;函数。使用这个函数非常重要，有几个原因。第一，它允许通过PHP的输出缓冲（output buffering）机制对输出的字符串进行处理，这个机制实际上除了对数据进行缓冲之外，它还会执行一些额外的处理比如gzip压缩。第二，当以CLI或者CGI方式使用PHP的时候，&lt;code&gt;stdout&lt;/code&gt;是一个数据输出的完美目的地，但是大多数SAPI希望通过一个指定的管道或者套接字来进行输出。因此，如果想简单地使用&lt;code&gt;printf()&lt;/code&gt;来把数据输出到&lt;code&gt;stdout&lt;/code&gt;可能会导致数据丢失，数据发送顺序混乱，或者数据错误，因为它的bypassed 预处理（bypassed preprocessing）。&lt;/p&gt;

&lt;p&gt;最后这个函数通过简单地返回TRUE来把控制权交给那个调用程序。当然你也可以不用明确的返回一个值（默认为NULL），但是这么做是非常糟糕的。如果一个函数没有任何有用的信息需要报告的话，那么就返回&lt;code&gt;TRUE&lt;/code&gt;，简单的说一句：“一切OK，我完成了你让我完成的任务”。&lt;/p&gt;

&lt;p&gt;因为PHP字符串有可能事实上包含&lt;code&gt;NULL&lt;/code&gt;，所以要想输出一个二进制安全的字符串，其中包含&lt;code&gt;NULL&lt;/code&gt;，并且还有&lt;code&gt;NULL&lt;/code&gt;后边的字符，那么方法是把&lt;code&gt;php_printf()&lt;/code&gt;语句替换成如下代码块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;php_printf(&quot;Hello &quot;);
PHPWRITE(name, name_len);
php_printf(&quot; &quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个代码块使用了&lt;code&gt;php_printf()&lt;/code&gt;来处理不包含&lt;code&gt;NULL&lt;/code&gt;字符的字符串，但是用了另一个宏 –&lt;code&gt;PHPWRITE&lt;/code&gt;来处理用户提供的字符串。这个宏接受由&lt;code&gt;zend_parse_parameters()&lt;/code&gt;提供的长度参数（&lt;code&gt;name_len&lt;/code&gt;），所以&lt;code&gt;name&lt;/code&gt;参数的整体内容可以不用担心NULL而放心得输出。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;zend_parse_parameters()&lt;/code&gt;也可以处理可选参数。在下一个例子中，你将会创建一个函数，这个函数接收一个long(PHP的整型)，一个double (浮点型)，和一个可选的Boolean值。在用户空间声明这个函数的话可能看起来如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function hello_add($a, $b, $return_long = false) {
    $sum = (int)$a + (float)$b;

    if ($return_long) {
        return intval($sum);
    } else {
        return floatval($sum);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在C语言中，这个函数看起来如下（当你想把它加到hello.c中的时候，不要忘记在php_hello.h和hello_functions[]中加入这个函数实体声明）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PHP_FUNCTION(hello_add)
{
    long a;
    double b;
    zend_bool return_long = 0;

    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;ld|b&quot;, &amp;amp;a, &amp;amp;b, &amp;amp;return_long) == FAILURE) {
        RETURN_NULL();
    }

    if (return_long) {
        RETURN_LONG(a + b);
    } else {
        RETURN_DOUBLE(a + b);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一次，你的数据类型字符串这样读：“我需要一个(&lt;code&gt;l&lt;/code&gt;)ong类型的参数，然后一个(&lt;code&gt;d&lt;/code&gt;)ouble类型的”。下一个管道字符说明接下来的参数列表是可选的。如果一个可选的参数在函数调用过程中没有被传递，那么&lt;code&gt;zend_parse_parameters()&lt;/code&gt;不会改变已经传给它的参数值。最后那个&lt;code&gt;b&lt;/code&gt;显然是Boolean类型。在数据类型字符串之后，&lt;code&gt;a&lt;/code&gt;，&lt;code&gt;b&lt;/code&gt;，以及&lt;code&gt;return_long&lt;/code&gt;以引用的方式传递进来，所以&lt;code&gt;zend_parse_parameters()&lt;/code&gt;可以用参数值来填充它们。&lt;/p&gt;

&lt;p&gt;警告：尽管&lt;code&gt;int&lt;/code&gt;和&lt;code&gt;long&lt;/code&gt;在32位平台上是可以相互替换着使用的，但是如果这么做的话，当你的代码在64位硬件上重新编译的时候就会非常危险。所以记住用&lt;code&gt;long&lt;/code&gt;来处理long类型，用&lt;code&gt;int&lt;/code&gt;来处理字符串长度。&lt;/p&gt;

&lt;p&gt;Table 1 给出了各种数据类型，以及可以在&lt;code&gt;zend_parse_parameters()&lt;/code&gt;中使用，与这些类型相对应的字母和C语言数据类型：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Table 1: Types and letter codes used in zend_parse_parameters()
Type    Code    Variable Type
Boolean  b       zend_bool
Long     l       long
Double   d       double
String   s       char*, int
Resource r       zval*
Array   a        zval*
Object  o        zval*
zval    z        zval*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可能注意到了&lt;em&gt;Table 1&lt;/em&gt;中最后四个类型都返回了相同的数据类型 – 一个&lt;code&gt;zval*&lt;/code&gt;。一个&lt;code&gt;zval&lt;/code&gt;，就像你将要看到的那样，是用来存储PHP中所有用户空间变量的真实数据类型。三个“复杂”的数据类型，Resource, Array和Object，当他们的数据类型字母标示在&lt;code&gt;zend_parse_parameters()&lt;/code&gt;中被使用的时候，Zend Engine会对其进行类型检查，但是它们在C语言中没有相对应的数据类型，所以不会有任何转换会被实际执行。&lt;/p&gt;

&lt;h3&gt;ZVAL&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;zval&lt;/code&gt;和普通的PHP用户空间变量，将会是最难理解，绞尽你脑汁的概念。它们也将会是最重要的概念。开始之前，让我们看看一个&lt;code&gt;zval&lt;/code&gt;的结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct {
    union {
        long lval;
        double dval;
        struct {
            char *val;
            int len;
        } str;

        HashTable *ht;
        zend_object_value obj;

    } value;

    zend_uint refcount;
    zend_uchar type;
    zend_uchar is_ref;

} zval;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就像你看见的，每个&lt;code&gt;zval&lt;/code&gt;通常有三个基本的元素：&lt;code&gt;type&lt;/code&gt;，&lt;code&gt;is_ref&lt;/code&gt;，&lt;code&gt;refcount&lt;/code&gt;。&lt;code&gt;is_ref&lt;/code&gt;和&lt;code&gt;refcount&lt;/code&gt;将会在这个教程的后面介绍；现在先让我们关注一下&lt;code&gt;type&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;到现在为止你应该已经熟悉了PHP的8个数据类型。它们中的7个在Table 1中列出来了，再加上&lt;code&gt;NULL&lt;/code&gt;，尽管事实上它在字面上表示什么都没有。对于一个特定的&lt;code&gt;zval&lt;/code&gt;来说，它的类型是可以通过以下三个便利的宏中的一个来进行检查：&lt;code&gt;Z_TYPE(zval)&lt;/code&gt;，&lt;code&gt;Z_TYPE_P(zval*)&lt;/code&gt;，或者&lt;code&gt;Z_TYPE_PP(zval**)&lt;/code&gt;。这个三个唯一的不同就是对传递变量的引用的层级要求不同。对于&lt;code&gt;_P&lt;/code&gt; 和 &lt;code&gt;_PP&lt;/code&gt;这种命名的惯例在其他宏中也会出现，比如你将要看见的&lt;code&gt;*VAL&lt;/code&gt;宏。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;type&lt;/code&gt;决定了&lt;code&gt;zval``value&lt;/code&gt;联合体的中那一部分被使用。下面的代码片段演示了一个简单版本的&lt;code&gt;var_dump()&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PHP_FUNCTION(hello_dump)
{
    zval *uservar;

    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;z&quot;, uservar) == FAILURE) {

        RETURN_NULL();

    }

    switch (Z_TYPE_P(uservar)) {

        case IS_NULL:
            php_printf(&quot;NULL &quot;);
            break;

        case IS_BOOL:
            php_printf(&quot;Boolean: %s &quot;, Z_LVAL_P(uservar) ? &quot;TRUE&quot; : &quot;FALSE&quot;);
            break;

        case IS_LONG:
            php_printf(&quot;Long: %ld &quot;, Z_LVAL_P(uservar));
            break;

        case IS_DOUBLE:
            php_printf(&quot;Double: %f &quot;, Z_DVAL_P(uservar));
            break;

        case IS_STRING:
            php_printf(&quot;String: &quot;);
            PHPWRITE(Z_STRVAL_P(uservar), Z_STRLEN_P(uservar));
            php_printf(&quot; &quot;);
            break;

        case IS_RESOURCE:
            php_printf(&quot;Resource &quot;);
            break;

        case IS_ARRAY:
            php_printf(&quot;Array &quot;);
            break;

        case IS_OBJECT:
            php_printf(&quot;Object &quot;);
            break;

        default:
            php_printf(&quot;Unknown &quot;);

    }

    RETURN_TRUE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就像你所看到的，&lt;code&gt;Boolean&lt;/code&gt;数据类型使用了和&lt;code&gt;long&lt;/code&gt;数据类型一样的内部宏。就像你在这个系列教程的第一部分中使用的&lt;code&gt;RETURN_BOOL()&lt;/code&gt;那样，&lt;code&gt;FALSE&lt;/code&gt;用0来代表，&lt;code&gt;TRUE&lt;/code&gt;用1来代表。&lt;/p&gt;

&lt;p&gt;当你使用&lt;code&gt;zend_parse_parameters()&lt;/code&gt;来要求一个指定了数据类型的参数的时候，比如&lt;code&gt;string&lt;/code&gt;，&lt;code&gt;Zend Engine&lt;/code&gt;将会去检查输入变量的数据类型。如果类型匹配，Zend会简单地把参数值简单的传递到&lt;code&gt;zval&lt;/code&gt;中对应的部分。如果不匹配，那么Zend会使用type-juggling规则对输入变量进行类型转换。&lt;/p&gt;

&lt;p&gt;对你之前实现的函数&lt;code&gt;hello_greetme()&lt;/code&gt;进行修改，把其分成几个小片段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PHP_FUNCTION(hello_greetme)
{
    zval *zname;

    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;z&quot;, &amp;amp;zname) == FAILURE) {
        RETURN_NULL();
    }

    convert_to_string(zname);
    php_printf(&quot;Hello &quot;);
    PHPWRITE(Z_STRVAL_P(zname), Z_STRLEN_P(zname));
    php_printf(&quot; &quot;);

    RETURN_TRUE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一次，&lt;code&gt;zend_parse_parameters()&lt;/code&gt;简单的接收一个不定数据类型的PHP变量（&lt;code&gt;zval&lt;/code&gt;），然后这个函数明确的把这个变量转换成字符串类型(类似于&lt;code&gt;$zname = (string)$zname; &lt;/code&gt;)，然后使用Z_STRVAL_P宏得到&lt;code&gt;zname&lt;/code&gt;的值，并输出。就像你可能猜到的，和其他数据类型&lt;code&gt;bool&lt;/code&gt;，&lt;code&gt;long&lt;/code&gt;和&lt;code&gt;double&lt;/code&gt;相对应的&lt;code&gt;convert_to_*()&lt;/code&gt;函数也是存在的。&lt;/p&gt;

&lt;h3&gt;创建ZVAL&lt;/h3&gt;

&lt;p&gt;到现在为止，你所使用的zval都是由Zend Engine来分配和释放的。但是无论如何，有时候，自己创建zval是很必要的。看一下如下的代码块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    zval *temp;

    ALLOC_INIT_ZVAL(temp);

    Z_TYPE_P(temp) = IS_LONG;
    Z_LVAL_P(temp) = 1234;

    zval_ptr_dtor(&amp;amp;temp);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ALLOC_INIT_ZVAL()，就像它名字所表明的那样，为一个&lt;code&gt;zval*&lt;/code&gt;分配内存，然后初始化为一个新的变量。当这个过程一旦完成，&lt;code&gt;Z_*_P()&lt;/code&gt;宏就可以被用来设置变量的数据类型和值。&lt;code&gt;zval_ptr_dtor()&lt;/code&gt;被用来做一脏活：清理分配给变量的内存。&lt;/p&gt;

&lt;p&gt;这两个&lt;code&gt;Z_*_P()&lt;/code&gt;宏的调用可以被减少到一个单独的语句：&lt;br/&gt;&lt;br/&gt;&lt;code&gt;ZVAL_LONG(temp, 1234);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;对于其他数据类型，类似的宏也是存在的，并且它们有相同的语法格式，就像你在这个系列教程第一部分所见的&lt;code&gt;RETURN_*()&lt;/code&gt;宏。事实上&lt;code&gt;RETURN_*()&lt;/code&gt;宏就是对&lt;code&gt;RETVAL_*()&lt;/code&gt;宏进行了简单的包装，&lt;code&gt;ZVAL_*()&lt;/code&gt;宏也是一样的道理。下面的五个版本是等同的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RETURN_LONG(42);

RETVAL_LONG(42);
return;

ZVAL_LONG(return_value, 42);
return;

Z_TYPE_P(return_value) = IS_LONG;
Z_LVAL_P(return_value) = 42;
return;

return_value-&amp;gt;type = IS_LONG;
return_value-&amp;gt;value.lval = 42;
return;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你足够机警，那么你会考虑这些宏是怎么定义的，就像它们在&lt;code&gt;hello_long()&lt;/code&gt;函数中被使用的那样。“&lt;code&gt;return_value&lt;/code&gt;是从哪来的，为什么它没有通过 ALLOC_INIT_ZVAL()来进行分配？”，你可能想知道。&lt;/p&gt;

&lt;p&gt;在你一天又一天的扩展编写过程中&lt;code&gt;return_value&lt;/code&gt;被隐藏了起来，其实它是在每个&lt;code&gt;PHP_FUNCTION()&lt;/code&gt;原型中定义的一个函数参数。Zend Engine会为它分配内存，然后初始化为&lt;code&gt;NULL&lt;/code&gt;，所以即使你的函数没有实际的去设置这个变量，其也有了一个可以被调用程序所用的值。当你的内部函数执行完之后，Zend Engine会把这个变量的值传递给调用程序，或者如果调用程序被告知忽略这个变量，则释放掉它。&lt;/p&gt;

&lt;h3&gt;数组&lt;/h3&gt;

&lt;p&gt;既然你在过去使用过PHP，那么你已经认识到一个数组变量的作用就是包含其他各种变量。它内部是通过一个大家都熟悉的数据结构&lt;code&gt;HashTable&lt;/code&gt;来实现的。当要创建数组，并且把这些数组返回给PHP，最简单的方法就是使用Table 2中所列函数中的一个。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Table 2: zval array creation functions

PHP Syntax  C Syntax (arr is a zval*)   Meaning
$arr = array(); array_init(arr);             Initialize a new array
$arr[] = NULL;  add_next_index_null(arr);   Add a value of a given type to a numerically indexed array
$arr[] = 42;    add_next_index_long(arr, 42);
$arr[] = true;  add_next_index_bool(arr, 1);
$arr[] = 3.14;  add_next_index_double(arr, 3.14);
$arr[] = 'foo'; add_next_index_string(arr, &quot;foo&quot;, 1);
$arr[] = $myvar; add_next_index_zval(arr, myvar);
$arr[0] = NULL; add_index_null(arr, 0);     Add a value of a given type to a specific index in an array
$arr[1] = 42;   add_index_long(arr, 1, 42);
$arr[2] = true; add_index_bool(arr, 2, 1);
$arr[3] = 3.14; add_index_double(arr, 3, 3.14);
$arr[4] = 'foo';add_index_string(arr, 4, &quot;foo&quot;, 1);
$arr[5] = $myvar; add_index_zval(arr, 5, myvar);
$arr['abc'] = NULL; add_assoc_null(arr, &quot;abc&quot;); Add a value of a given type to an associatively indexed array
$arr['def'] = 711; add_assoc_long(arr, &quot;def&quot;, 711);
$arr['ghi'] = true; add_assoc_bool(arr, &quot;ghi&quot;, 1);
$arr['jkl'] = 1.44; add_assoc_double(arr, &quot;jkl&quot;, 1.44);
$arr['mno'] = 'baz'; add_assoc_string(arr, &quot;mno&quot;, &quot;baz&quot;, 1);
$arr['pqr'] = $myvar; add_assoc_zval(arr, &quot;pqr&quot;, myvar);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;像&lt;code&gt;RETURN_STRING()&lt;/code&gt;宏一样，&lt;code&gt;add_*_string()&lt;/code&gt;函数也会在最后一个参数中用0或者1来指明这个字符串内容是否需要复制。这些&lt;code&gt;add_*_string()&lt;/code&gt;函数每个还有&lt;code&gt;add_*_stringl()&lt;/code&gt;格式的变体。&lt;code&gt;l&lt;/code&gt;表示字符串的长度将会明确地提供（不需要Zend Engine调用非二进制安全的&lt;code&gt;strval()&lt;/code&gt;函数来检测）。&lt;/p&gt;

&lt;p&gt;使用这个二进制安全格式的函数只需要简单的在那个复制参数前面指定长度即可，像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;add_assoc_stringl(arr, &quot;someStringVar&quot;, &quot;baz&quot;, 3, 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在使用&lt;code&gt;add_assoc_*()&lt;/code&gt;函数的时候，所有数组的key都假设不包含任何的&lt;code&gt;NULL&lt;/code&gt; – &lt;code&gt;add_assoc_*()&lt;/code&gt;函数本身对于key是非二进制安全。在它们之中使用包含&lt;code&gt;NULL&lt;/code&gt;的key是不被鼓励的（即使这个技术已经在protected对象属性和private对象属性中使用了），但是如果必须这么做的话，当我们稍后接触&lt;code&gt;zend_hash_*()&lt;/code&gt;函数的时候，你将会了解到如何更加充分地用好它。&lt;/p&gt;

&lt;p&gt;把你刚才已经学到的东西展示一下，创建如下的一个函数，其返回一个数组的值给调用程序。确定在&lt;strong&gt;php_hello.h&lt;/strong&gt;和&lt;code&gt;hello_functions[]&lt;/code&gt;中加入适当的函数实体来声明这个函数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PHP_FUNCTION(hello_array)
{
    char *mystr;
    zval *mysubarray;
    array_init(return_value);

    add_index_long(return_value, 42, 123);
    add_next_index_string(return_value, &quot;I should now be found at index 43&quot;, 1);
    add_next_index_stringl(return_value, &quot;I'm at 44!&quot;, 10, 1);

    mystr = estrdup(&quot;Forty Five&quot;);
    add_next_index_string(return_value, mystr, 0);

    add_assoc_double(return_value, &quot;pi&quot;, 3.1415926535);

    ALLOC_INIT_ZVAL(mysubarray);
    array_init(mysubarray);
    add_next_index_string(mysubarray, &quot;hello&quot;, 1);
    add_assoc_zval(return_value, &quot;subarray&quot;, mysubarray);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;构建这个扩展，然后给出&lt;code&gt;var_dump(hello_array())&lt;/code&gt;的结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;array(6) {
  [42]=&amp;gt;
  int(123)

  [43]=&amp;gt;
  string(33) &quot;I should now be found at index 43&quot;

  [44]=&amp;gt;
  string(10) &quot;I'm at 44!&quot;

  [45]=&amp;gt;
  string(10) &quot;Forty Five&quot;

  [&quot;pi&quot;]=&amp;gt;
  float(3.1415926535)

  [&quot;subarray&quot;]=&amp;gt;
  array(1) {
    [0]=&amp;gt;
    string(5) &quot;hello&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;读取数组中的值意味着使用&lt;code&gt;ZENDAPI&lt;/code&gt;中的&lt;code&gt;zend_hash&lt;/code&gt;一类的函数把&lt;code&gt;HashTable&lt;/code&gt;中的内容抽出然后转换成&lt;code&gt;zval**&lt;/code&gt;。让我们以一个接收数组参数的简单函数开始：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function hello_array_strings($arr) {
    if (!is_array($arr)) return NULL;
    printf(&quot;The array passed contains %d elements &quot;, count($arr));

    foreach($arr as $data) {
        if (is_string($data)) echo &quot;$data &quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者，用C语言：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PHP_FUNCTION(hello_array_strings)
{
    zval *arr, **data;
    HashTable *arr_hash;
    HashPosition pointer;
    int array_count;

    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;a&quot;, &amp;amp;arr) == FAILURE) {
        RETURN_NULL();
    }

    arr_hash = Z_ARRVAL_P(arr);
    array_count = zend_hash_num_elements(arr_hash);
    php_printf(&quot;The array passed contains %d elements &quot;, array_count);

    for(zend_hash_internal_pointer_reset_ex(arr_hash, &amp;amp;pointer); zend_hash_get_current_data_ex(arr_hash, (void**) &amp;amp;data, &amp;amp;pointer) == SUCCESS; zend_hash_move_forward_ex(arr_hash, &amp;amp;pointer)) {
        if (Z_TYPE_PP(data) == IS_STRING) {

            PHPWRITE(Z_STRVAL_PP(data), Z_STRLEN_PP(data));

            php_printf(&quot; &quot;);

        }
    }

    RETURN_TRUE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了保持这个函数的简洁，在这个函数中只有&lt;code&gt;string&lt;/code&gt;类型的数组元素被输出了。你可能想知道为什么我们不用&lt;code&gt;convert_to_string()&lt;/code&gt;就像我们在之前的&lt;code&gt;hello_greetme()&lt;/code&gt;函数中做的那样。让我们改一下看看；把上面的for循环代码用以下的代码替换掉：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for(zend_hash_internal_pointer_reset_ex(arr_hash, &amp;amp;pointer); zend_hash_get_current_data_ex(arr_hash, (void**) &amp;amp;data, &amp;amp;pointer) == SUCCESS; zend_hash_move_forward_ex(arr_hash, &amp;amp;pointer)) {
    convert_to_string_ex(data);
    PHPWRITE(Z_STRVAL_PP(data), Z_STRLEN_PP(data));
    php_printf(&quot; &quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在重新编译你的扩展，然后在用户空间运行如下代码：&lt;/p&gt;

&lt;p&gt;注意这个原始的数组已经被更改了！记住，&lt;code&gt;convert_to_*()&lt;/code&gt;函数的作用和调用&lt;code&gt;set_type()&lt;/code&gt;是一样的。由于你在和传递进来的数组一起工作，修改它的类型将会改变原始变量。为了避免这个，你需要首选复制一份zval。为了这么做，再修改一下for循环代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for(zend_hash_internal_pointer_reset_ex(arr_hash, &amp;amp;pointer); zend_hash_get_current_data_ex(arr_hash, (void**) &amp;amp;data, &amp;amp;pointer) == SUCCESS; zend_hash_move_forward_ex(arr_hash, &amp;amp;pointer)) {
        zval temp;
        temp = **data;
        zval_copy_ctor(&amp;amp;temp);
        convert_to_string(&amp;amp;temp);
        PHPWRITE(Z_STRVAL(temp), Z_STRLEN(temp));
        php_printf(&quot; &quot;);
        zval_dtor(&amp;amp;temp);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个版本中最明显的部分 – &lt;code&gt;temp = **data&lt;/code&gt; – 就是拷贝原始&lt;code&gt;zval&lt;/code&gt;中的&lt;code&gt;data&lt;/code&gt;成员，但是因为一个&lt;code&gt;zval&lt;/code&gt;可能会包含附加的资源比如像&lt;code&gt;char*&lt;/code&gt; 字符串，或者&lt;code&gt;HashTable*&lt;/code&gt; 数组，那么这些依赖的资源需要通过&lt;code&gt;zval_copy_ctor()&lt;/code&gt;来复制一份。到目前为止只有一个简单的转换，输出，最后的那个&lt;code&gt;zval_dtor()&lt;/code&gt;用来释放掉&lt;code&gt;zval_copy_ctor()&lt;/code&gt;拷贝的资源。&lt;/p&gt;

&lt;p&gt;如果你想知道当我们首次介绍&lt;code&gt;convert_to_string()&lt;/code&gt;的时候，为什么你不做&lt;code&gt;zval_copy_ctor()&lt;/code&gt;这个工作，那是因为当传递一个变量给一个函数的时候，它会自动创建这个变量的拷贝，从而把zval从原始变量中分离开来。这个只能在基本的zval上完成，所以一些附属的资源（比如数组元素和对象属性）仍然需要在使用之前就分离。&lt;/p&gt;

&lt;p&gt;现在你已经看到了数组的值，让我们再修改一下代码让我们也可以看到数组的key：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for(zend_hash_internal_pointer_reset_ex(arr_hash, &amp;amp;pointer); zend_hash_get_current_data_ex(arr_hash, (void**) &amp;amp;data, &amp;amp;pointer) == SUCCESS; zend_hash_move_forward_ex(arr_hash, &amp;amp;pointer)) {

    zval temp;
    char *key;
    int key_len;
    long index;

    if (zend_hash_get_current_key_ex(arr_hash, &amp;amp;key, &amp;amp;key_len, &amp;amp;index, 0, &amp;amp;pointer) == HASH_KEY_IS_STRING) {
        PHPWRITE(key, key_len);
    } else {
        php_printf(&quot;%ld&quot;, index);
    }

    php_printf(&quot; =&amp;gt; &quot;);

    temp = **data;
    zval_copy_ctor(&amp;amp;temp);
    convert_to_string(&amp;amp;temp);
    PHPWRITE(Z_STRVAL(temp), Z_STRLEN(temp));
    php_printf(&quot; &quot;);
    zval_dtor(&amp;amp;temp);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;记住数组可以有数字索引，关联字符串key，或者二者都有。调用&lt;code&gt;zend_hash_get_current_key_ex()&lt;/code&gt;可以从数组当前位置来获得数组key的类型，然后用返回值来决定key的类型，可能是&lt;code&gt;HASH_KEY_IS_STRING&lt;/code&gt;，&lt;code&gt;HASH_KEY_IS_LONG&lt;/code&gt;，或者&lt;code&gt;HASH_KEY_NON_EXISTANT&lt;/code&gt;。既然&lt;code&gt;zend_hash_get_current_data_ex()&lt;/code&gt;可以返回一个&lt;code&gt;zval**&lt;/code&gt;，你可以安全的假设&lt;code&gt;HASH_KEY_NON_EXISTANT&lt;/code&gt;是不会被返回的，所以只有IS_STRING和IS_LONG需要被检查。&lt;/p&gt;

&lt;p&gt;这儿有另一个迭代HashTable的方法。Zend Engine公开了三个非常相似的函数来协助这个工作：&lt;code&gt;zend_hash_apply()&lt;/code&gt;，&lt;code&gt;zend_hash_apply_with_argument()&lt;/code&gt;，和&lt;code&gt;zend_hash_apply_with_arguments()&lt;/code&gt;。第一个就是循环一个&lt;code&gt;HashTable&lt;/code&gt;，第二个允许传递一个单独的&lt;code&gt;void*&lt;/code&gt;参数给它，与此同时第三个允许通过一个可变参数列表来传递数量不限的参数。hello_array_walk()显示了每个函数的使用方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static int php_hello_array_walk(zval **element TSRMLS_DC)
{
    zval temp;
    temp = **element;
    zval_copy_ctor(&amp;amp;temp);
    convert_to_string(&amp;amp;temp);
    PHPWRITE(Z_STRVAL(temp), Z_STRLEN(temp));
    php_printf(&quot; &quot;);
    zval_dtor(&amp;amp;temp);

    return ZEND_HASH_APPLY_KEEP;
}

static int php_hello_array_walk_arg(zval **element, char *greeting TSRMLS_DC)
{
    php_printf(&quot;%s&quot;, greeting);
    php_hello_array_walk(element TSRMLS_CC);

    return ZEND_HASH_APPLY_KEEP;
}

static int php_hello_array_walk_args(zval **element, int num_args, var_list args, zend_hash_key *hash_key)
{
    char *prefix = va_arg(args, char*);
    char *suffix = va_arg(args, char*);
    TSRMLS_FETCH();

    php_printf(&quot;%s&quot;, prefix);
    php_hello_array_walk(element TSRMLS_CC);
    php_printf(&quot;%s &quot;, suffix);

    return ZEND_HASH_APPLY_KEEP;
}

PHP_FUNCTION(hello_array_walk)
{
    zval *zarray;
    int print_newline = 1;

    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;a&quot;, &amp;amp;zarray) == FAILURE) {
        RETURN_NULL();
    }

    zend_hash_apply(Z_ARRVAL_P(zarray), (apply_func_t)php_hello_array_walk TSRMLS_CC);
    zend_hash_apply_with_argument(Z_ARRVAL_P(zarray), (apply_func_arg_t)php_hello_array_walk_arg, &quot;Hello &quot; TSRMLS_CC);
    zend_hash_apply_with_arguments(Z_ARRVAL_P(zarray), (apply_func_args_t)php_hello_array_walk_args, 2, &quot;Hello &quot;, &quot;Welcome to my extension!&quot;);

    RETURN_TRUE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到现在为止你应该对与上面大部分代码相关联的函数使用很熟悉了。传递给&lt;code&gt;hello_array_walk()&lt;/code&gt;的数组被循环了三次，一次没有任何参数，一次跟着一个参数，第三次跟着两个参数。在这个设计中，&lt;code&gt;walk_arg()&lt;/code&gt;和&lt;code&gt;walk_args()&lt;/code&gt;函数实际上依赖于没有参数的&lt;code&gt;walk()&lt;/code&gt;函数，这个函数的工作是类型转换，并输出zval，显然这个工作对于这三个函数来说都是共同的。&lt;/p&gt;

&lt;p&gt;在这个代码块中，就像在你将要使用&lt;code&gt;zend_hash_apply()&lt;/code&gt;函数的大部分地方，这个&lt;code&gt;apply()&lt;/code&gt;函数会返回&lt;code&gt;ZEND_HASH_APPLY_KEEP&lt;/code&gt;。这个告诉&lt;code&gt;zend_hash_apply()&lt;/code&gt;函数把元素留在&lt;code&gt;HashTable&lt;/code&gt;中，然后继续处理下一个。在这儿还可以返回其他值：&lt;code&gt;ZEND_HASH_APPLY_REMOVE&lt;/code&gt;，意思是 – 删除当前的元素，然后继续处理下一个 –&lt;code&gt;ZEND_HASH_APPLY_STOP&lt;/code&gt;，意思是在当前元素处停止数组迭代，然后完全退出&lt;code&gt;zend_hash_apply()&lt;/code&gt;函数。&lt;/p&gt;

&lt;p&gt;所有组件中稍微不太熟悉的应该是&lt;code&gt;TSRMLS_FETCH()&lt;/code&gt;。你可以回想一下第一部分，&lt;code&gt;TSRMLS_*&lt;/code&gt;宏是线程安全资源管理层的一部分，对于保持线程之间的独立是很必要的。因为多参数版本的&lt;code&gt;zend_hash_apply()&lt;/code&gt;使用了一个可变参数列表，所以这个&lt;code&gt;tsrm_ls&lt;/code&gt;标示没法传递到&lt;code&gt;walk()&lt;/code&gt;函数中。为了当我们在回调&lt;code&gt;php_hello_array_walk()&lt;/code&gt;函数的时候可以使用线程安全机制，你需要在函数中调用&lt;code&gt;TSRMLS_FETCH()&lt;/code&gt;，它会在资源池中寻找正确的线程。（注意：这个方法比直接传递参数要慢得多，所以只在无法避免的时候才用。）&lt;/p&gt;

&lt;p&gt;用foreach这种形式的方法来迭代一个数组是很常见的任务，但是你经常会用一个数字key或者关联key在数组中查找一个特定的值。下一个函数将会根据key从一个数组中返回一个值，其中这个函数的第一个参数是这个数组，第二个参数是所需要的key。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PHP_FUNCTION(hello_array_value)
{
    zval *zarray, *zoffset, **zvalue;
    long index = 0;
    char *key = NULL;
    int key_len = 0;

    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;az&quot;, &amp;amp;zarray, &amp;amp;zoffset) == FAILURE) {
        RETURN_NULL();
    }

    switch (Z_TYPE_P(zoffset)) {

        case IS_NULL:
            index = 0;
            break;

        case IS_DOUBLE:
           index = (long)Z_DVAL_P(zoffset);
            break;

        case IS_BOOL:
        case IS_LONG:
        case IS_RESOURCE:
            index = Z_LVAL_P(zoffset);
            break;

        case IS_STRING:
            key = Z_STRVAL_P(zoffset);
            key_len = Z_STRLEN_P(zoffset);
            break;

        case IS_ARRAY:
            key = &quot;Array&quot;;
            key_len = sizeof(&quot;Array&quot;) - 1;
            break;

        case IS_OBJECT:
            key = &quot;Object&quot;;
            key_len = sizeof(&quot;Object&quot;) - 1;
            break;

        default:
            key = &quot;Unknown&quot;;
            key_len = sizeof(&quot;Unknown&quot;) - 1;
    }

    if (key &amp;amp;&amp;amp; zend_hash_find(Z_ARRVAL_P(zarray), key, key_len + 1, (void**)&amp;amp;zvalue) == FAILURE) {
        RETURN_NULL();
    } else if (!key &amp;amp;&amp;amp; zend_hash_index_find(Z_ARRVAL_P(zarray), index, (void**)&amp;amp;zvalue) == FAILURE) {
        RETURN_NULL();
    }

    *return_value = **zvalue;
    zval_copy_ctor(return_value);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数以一个&lt;code&gt;switch&lt;/code&gt;块开始，主要是处理类型转换，方法和&lt;code&gt;Zend Engine&lt;/code&gt;很像。&lt;code&gt;NULL&lt;/code&gt;被当做0，&lt;code&gt;Boolean&lt;/code&gt;类型被适当的转换为0或者1，&lt;code&gt;double&lt;/code&gt;类型被转换成&lt;code&gt;long&lt;/code&gt;(在处理过程中会被截断)，然后&lt;code&gt;resource&lt;/code&gt;类型被转换成数字值。对&lt;code&gt;resource&lt;/code&gt;类型的处理方式是从PHP3留下来的，当&lt;code&gt;resource&lt;/code&gt;只是查询数组时候所需要的一个数字key而不是一个唯一的类型。&lt;/p&gt;

&lt;p&gt;数组和对象被简单的当成字符串字面量“Array”或“Object”，因为转换不会有实质性结果。最后的default条件是为了能够向后兼容，当这个扩展和PHP未来的一个版本相编译的时候，这个PHP版本可能会有其他的数据类型。&lt;/p&gt;

&lt;p&gt;如果函数正在寻找一个关联key，那么key就必须是非&lt;code&gt;NULL&lt;/code&gt;，可以使用这个key的值来决定是使用关联查询还是数字索引查询。如果查询失败了，那是因为key不存在，然后函数会返回&lt;code&gt;NULL&lt;/code&gt;来表明查询失败。否则&lt;code&gt;zval&lt;/code&gt;会被拷贝到&lt;code&gt;return_value&lt;/code&gt;中。&lt;/p&gt;

&lt;h3&gt;符号表作为数组&lt;/h3&gt;

&lt;p&gt;如果你之前使用过&lt;code&gt;$GLOBALS&lt;/code&gt;数组，你应该知道自己在PHP脚本的全局空间中声明的变量也会出现在这个数组中。回想一下，一个数组的内部实现是一个&lt;code&gt;HashTable&lt;/code&gt;，一个问题出现了：“GLOBALS数组能否在一个特殊的地方被找到呢？”回答是“YES”。它存在于一个叫做&lt;code&gt;EG(symbol_table)&lt;/code&gt;的Executor Globals 结构体中，&lt;code&gt;EG(symbol_table)&lt;/code&gt;是一个&lt;code&gt;HashTable&lt;/code&gt;（不是&lt;code&gt;HashTable*&lt;/code&gt;，提醒一下你，就是&lt;code&gt;HashTable&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;你已经知道如何在一个数组中找到关联key所对应的元素，那么现在你知道该去哪里找全局符号表，那么在扩展代码中查找变量应该是一个很容易的事情：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PHP_FUNCTION(hello_get_global_var)
{
    char *varname;
    int varname_len;
    zval **varvalue;

    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;s&quot;, &amp;amp;varname, &amp;amp;varname_len) == FAILURE) {
        RETURN_NULL();
    }

    if (zend_hash_find(&amp;amp;EG(symbol_table), varname, varname_len + 1, (void**)&amp;amp;varvalue) == FAILURE) {
        php_error_docref(NULL TSRMLS_CC, E_NOTICE, &quot;Undefined variable: %s&quot;, varname);
        RETURN_NULL();
    }

    *return_value = **varvalue;
    zval_copy_ctor(return_value);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在你应该对这个很熟悉了。这个函数接收一个字符串参数，并用它在全局空间中寻找一个变量，然后返回它。&lt;/p&gt;

&lt;p&gt;新出现的一个函数是&lt;code&gt;php_error_docref()&lt;/code&gt;。你将会在PHP源码树中发现这个函数。第一个参数是一个可选的文档引用（默认情况下是当前函数）。接下来是很经常出现的&lt;code&gt;TSRMLS_CC&lt;/code&gt;，之后是一个错误的严重级别，最后是一个&lt;code&gt;printf()&lt;/code&gt;类型格式的字符串和一个带有错误信息实际内容的一个变量。无论你的函数什么时候出现错误，提供一些可以理解的错误信息是非常重要的。事实上，回去给&lt;code&gt;hello_array_value()&lt;/code&gt;加上错误处理语句是非常好的做法。在这个教程最后的完整性检查章节也会包含这个工作。&lt;/p&gt;

&lt;p&gt;除了全局符号表之外，Zend Engine也保留了一个局部符号表的引用。因为内部函数没有他们自己的符号表（它们为什么要有？），所以局部符号表实际上就是用来保存内部函数变量的。让我们看个简单的函数，这个函数在局部作用域设置一个变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PHP_FUNCTION(hello_set_local_var)
{
    zval *newvar;
    char *varname;
    int varname_len;
    zval *value;

    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;sz&quot;, &amp;amp;varname, &amp;amp;varname_len, &amp;amp;value) == FAILURE) {
        RETURN_NULL();
    }

    ALLOC_INIT_ZVAL(newvar);
    *newvar = *value;
    zval_copy_ctor(newvar);
    zend_hash_add(EG(active_symbol_table), varname, varname_len + 1, &amp;amp;newvar, sizeof(zval*), NULL);

    RETURN_TRUE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很明显这没有什么新的东西。继续，然后把你现在手上的代码编译一下，并运行一些测试脚本。确保编译过程无误。&lt;/p&gt;

&lt;h3&gt;引用计数&lt;/h3&gt;

&lt;p&gt;到现在为止，我们添加到&lt;code&gt;HashTable&lt;/code&gt;中的&lt;code&gt;zval&lt;/code&gt;不是新创建的就是新拷贝过来的。这些&lt;code&gt;zval&lt;/code&gt;是独立的，拥有自己的资源，只存在于&lt;code&gt;HashTable&lt;/code&gt;之中。作为一个语言设计的概念而言，这种创建，拷贝变量的方案是“足够好”的，但是我知道你很熟悉用C来编程，所以你知道如果拷贝一大块数据的话是非常耗费内存和CPU时间的，除非你遇到特殊情况不得不这么做。考虑一下这个用户空间代码块：&lt;/p&gt;

&lt;p&gt;如果使用&lt;code&gt;zval_copy_ctor()&lt;/code&gt;（实际上使用&lt;code&gt;estrndup()&lt;/code&gt;来完成的）来把&lt;code&gt;$a&lt;/code&gt;拷贝到&lt;code&gt;$b&lt;/code&gt;，那么这个简短的脚本将会用掉8M的内存来存储两个相同的4M文件的内容。最后一步释放&lt;code&gt;$a&lt;/code&gt;会使情况变得更糟，因为原始的字符串已经被&lt;code&gt;efree()&lt;/code&gt;释放掉了。在C语言中完成这个应该会简单一些：&lt;code&gt;b = a; a = NULL;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;幸运的是，&lt;code&gt;Zend Engine&lt;/code&gt;比以上的做法要聪明一些。当&lt;code&gt;$a&lt;/code&gt;首次被创建的时候，一个隐含的string类型的zval会被创建，内容是log文件。通过调用&lt;code&gt;zend_hash_add()&lt;/code&gt;来把那个&lt;code&gt;zval&lt;/code&gt;分配给&lt;code&gt;$a&lt;/code&gt;。当&lt;code&gt;$a&lt;/code&gt;被拷贝到&lt;code&gt;$b&lt;/code&gt;中的时候，可想而知，Zend Engine会做类似下面的事情：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    zval **value;
    zend_hash_find(EG(active_symbol_table), &quot;a&quot;, sizeof(&quot;a&quot;), (void**)&amp;amp;value);

    ZVAL_ADDREF(*value);
    zend_hash_add(EG(active_symbol_table), &quot;b&quot;, sizeof(&quot;b&quot;), value, sizeof(zval*));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，实际代码会更复杂，但是重点关注的地方是&lt;code&gt;ZVAL_ADDREF()&lt;/code&gt;。记得在一个zval中有四个标准的元素。你已经看过&lt;code&gt;type&lt;/code&gt;和&lt;code&gt;value&lt;/code&gt;了；这次看下&lt;code&gt;refcount&lt;/code&gt;。就像它的名字表示的那样，refcount指的是一个特定的&lt;code&gt;zval&lt;/code&gt;在一个符号表，数组或者其他地方被引用的次数。&lt;/p&gt;

&lt;p&gt;当你使用&lt;code&gt;ALLOC_INIT_ZVAL()&lt;/code&gt;的时候，&lt;code&gt;refcount&lt;/code&gt;会被设置为1，所以当你想要返回这个&lt;code&gt;zval&lt;/code&gt;，或者把它加入到一个&lt;code&gt;HashTable&lt;/code&gt;中的时候，不需要做任何事。在以上的代码中，你从一个&lt;code&gt;HashTable&lt;/code&gt;中找到了一个&lt;code&gt;zval&lt;/code&gt;，但是没有删除它，所以它的&lt;code&gt;refcount&lt;/code&gt;的值符合它被引用的次数。为了在其他地方可以引用它，你需要增加它的引用计数。&lt;/p&gt;

&lt;p&gt;当在用户空间代码中调用&lt;code&gt;unset($a)&lt;/code&gt;时候，&lt;code&gt;Zend Engine&lt;/code&gt;会在那个变量上执行&lt;code&gt;zval_ptr_dtor()&lt;/code&gt;。使用&lt;code&gt;zval_ptr_dtor()&lt;/code&gt;的重要性你是看不见的，这个调用不需要销毁这个&lt;code&gt;zval&lt;/code&gt;以及它的所有内容。它实际做的事情是减少它的&lt;code&gt;refcount&lt;/code&gt;。如果，我说如果，&lt;code&gt;refcount&lt;/code&gt;的值为0了，那么Zend Engine会销毁这个&lt;code&gt;zval&lt;/code&gt;…&lt;/p&gt;

&lt;p&gt;原文：&lt;a href=&quot;http://devzone.zend.com/node/view/id/1022&quot;&gt;http://devzone.zend.com/node/view/id/1022&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PHP扩展编写第一步：PHP和Zend介绍</title>
   <link href="http://weizhifeng.net/write-php-extension-part1.html"/>
   <updated>2011-07-03T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/write-php-extension-part1</id>
   <content type="html">&lt;h3&gt;介绍&lt;/h3&gt;

&lt;p&gt;如果你在读这篇入门文章，那么你可能对写PHP扩展有点兴趣。如果不是… 好吧，那么等我们写完这篇文章，你将会发现一个之前自己完全不知道，但是非常有趣的东西。&lt;/p&gt;

&lt;p&gt;这篇入门文章假设你对PHP语言和以及PHP的编写语言&lt;strong&gt;C语言&lt;/strong&gt;都有一定的熟悉。&lt;/p&gt;

&lt;p&gt;让我们以“为什么你需要写一个PHP扩展”作为开始。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;因为PHP语言本身抽象程度有限，有一些库或者操作系统级别的调用，不能用PHP直接调用。&lt;/li&gt;
&lt;li&gt;你想给PHP添加一些与众不同的行为。&lt;/li&gt;
&lt;li&gt;你已经写了一些PHP代码，但是当运行的时候你知道它可以更快，更小，消耗的内存更少。&lt;/li&gt;
&lt;li&gt;你有一部分程序想出售，你可以把它写成扩展，这样程序是可以执行的，但是别人却无法看到源码。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;这儿有很多完美的原因，但是要想创建一个扩展，你首先要需要明白什么是扩展。&lt;/p&gt;

&lt;h3&gt;什么是扩展？&lt;/h3&gt;

&lt;p&gt;如果你用过PHP，那么你就用过扩展。除了一些极少的特殊情况之外，PHP语言中的每个用户空间函数都是以组的形式分布在一个或多个扩展之中。这些函数中的大部分是位于标准扩展中的 – 总共超过400个。PHP源码中包含86个扩展，平均每个扩展中有30个函数。算一下，大概有2500个函数。如果这个不够用，&lt;a href=&quot;http://pecl.php.net/&quot; title=&quot;PECL&quot;&gt;PECL&lt;/a&gt;仓库还提供了超过100个其他扩展，或者还可以在互联网上找到更多的扩展。&lt;/p&gt;

&lt;p&gt;「PHP除了扩展中的这些函数之外，剩下的是什么」我听到了你的疑问「扩展是什么？PHP的核心又是什么？」&lt;/p&gt;

&lt;p&gt;PHP的核心是由两个独立的部分组成的。在最底层是&lt;strong&gt;Zend Engine (ZE)&lt;/strong&gt;。ZE 负责把人类可以理解的脚本解析成机器可以理解的符号（token），然后在一个进程空间内执行这些符号。ZE还负责内存管理，变量作用域，以及函数调用的调度。另一部分是&lt;strong&gt;PHP&lt;/strong&gt;。PHP负责与&lt;strong&gt;SAPI&lt;/strong&gt;层（Server Application Programming Interface，经常被用来与Apache, IIS, CLI, CGI等host环境进行关联）的交互以及绑定。它也为&lt;code&gt;safe_mode&lt;/code&gt;和&lt;code&gt;open_basedir&lt;/code&gt;检查提供了一个统一的控制层，就像streams层把文件和网络I/O与用户空间函数（例如&lt;code&gt;fopen()&lt;/code&gt;，&lt;code&gt;fread()&lt;/code&gt;和&lt;code&gt;fwrite()&lt;/code&gt;）关联起来一样。&lt;/p&gt;

&lt;h3&gt;生命周期&lt;/h3&gt;

&lt;p&gt;当一个给定的SAPI启动后，以&lt;code&gt;/usr/local/apache/bin/apachectl start&lt;/code&gt;的响应为例，PHP便以初始化它的核心子系统作为开始。随着SAPI启动程序的结束，PHP开始加载每个扩展的代码，然后调用它们的&lt;strong&gt;模块初始化&lt;/strong&gt;(&lt;code&gt;MINIT&lt;/code&gt;)程序。这就给每个扩展机会用来初始化内部变量，申请资源，注册资源处理器，并且用ZE注册自己的函数，这样如果一个脚本调用这些函数中的一个，ZE就知道执行哪些代码。&lt;/p&gt;

&lt;p&gt;接下来，PHP会等待SAPI层的页面处理请求。在CGI或者CLI SAPI情况下，这个请求会立即发生并且只执行一次。在Apache, IIS, 或者其他成熟的web服务器SAPI中，请求处理会在远程用户发起请求的时候发生，并且会重复执行很多次，也可能是并发的。不管请求是怎么进来的，PHP以让ZE来建立脚本可以运行的环境作为开始，然后调用每个扩展的&lt;strong&gt;请求初始化&lt;/strong&gt;（&lt;code&gt;RINIT&lt;/code&gt;）函数。&lt;code&gt;RINIT&lt;/code&gt;给了扩展一个机会，让其可以建立指定的环境变量，分配请求指定的资源，或者执行其他任务例如审计。关于&lt;code&gt;RINIT&lt;/code&gt;函数调用最典型的例子是在session扩展中，如果&lt;code&gt;session.auto_start&lt;/code&gt;选项是开启的，&lt;code&gt;RINIT&lt;/code&gt;会自动触发用户空间的&lt;code&gt;session_start()&lt;/code&gt;函数并且预先填充&lt;code&gt;$_SESSION&lt;/code&gt;变量。&lt;/p&gt;

&lt;p&gt;当请求一旦被初始化，ZE便把PHP脚本翻译成&lt;strong&gt;符号&lt;/strong&gt;（token），最终翻译成可以进行单步调试和执行的&lt;strong&gt;opcode&lt;/strong&gt;。如果这些opcode中的一个需要调用一个扩展函数，ZE将会给那个函数绑定参数，并且临时放弃控制权直到函数执行完成。&lt;/p&gt;

&lt;p&gt;当一个脚本完成了执行之后，PHP将会调用每个扩展的&lt;strong&gt;请求结束&lt;/strong&gt;(&lt;code&gt;RSHUTDOWN&lt;/code&gt;)函数来执行最后的清理工作（比如保存session变量到磁盘上）。接下来，ZE执行一个清理过程（熟知的&lt;strong&gt;垃圾回收&lt;/strong&gt;），实际上是对上次请求过程中使用的变量调用&lt;code&gt;unset()&lt;/code&gt;函数。&lt;/p&gt;

&lt;p&gt;一旦完成，PHP等待SAPI发起另一个文档请求或者一个关闭信号。在CGI和CLI SAPI的情况下，没有所谓的“下一个请求”，所以SAPI会立刻执行关闭流程。在关闭过程中，PHP又让每个扩展调用自己的&lt;strong&gt;模块关闭&lt;/strong&gt;（&lt;code&gt;MSHUTDOWN&lt;/code&gt;）函数，最后关闭自己的核心子系统。&lt;/p&gt;

&lt;p&gt;这个过程第一次听令人有些费解，但是一旦你深入到一个扩展的开发过程中，它就会逐渐的清晰起来。&lt;/p&gt;

&lt;h3&gt;内存分配&lt;/h3&gt;

&lt;p&gt;为了避免写的很糟糕的扩展泄露内存，ZE以自己内部的方式来进行内存管理，通过用一个附加的标志来指明&lt;strong&gt;持久化&lt;/strong&gt;。一个&lt;strong&gt;持久化分配&lt;/strong&gt;的内存比单个页面请求存在的时间要长。一个&lt;strong&gt;非持久化分配&lt;/strong&gt;的内存，相比之下，在请求结束的时候就会被释放，不管free函数是否被调用。例如用户空间变量，都是非持久化分配的内存，因为在请求结束之后这些变量都没有用了。&lt;/p&gt;

&lt;p&gt;一个扩展理论上可以依靠ZE在每个页面请求结束后自动释放非持久化的内存，但这是不被推荐的。在请求结束的时候，分配的内存不会被立即被回收，并且会持续一段时间，所以和那块内存关联的资源将不会被恰当的关闭，这是一个很糟的做法，因为如果不能适当的清理的话，这会产生混乱。就像你即将要看见的，确定所有分配的数据被恰当的清除了是非常的简单。&lt;/p&gt;

&lt;p&gt;让我们把常规的内存分配函数（只应该当和内部库一起工作的时候才会用到）和PHP ZE中的持久化和非持久化内存分配函数进行一个对比。&lt;/p&gt;

&lt;p&gt;Traditional Non-Persistent Persistent
&lt;code&gt;malloc(count)&lt;/code&gt; &lt;code&gt;calloc(count, num)&lt;/code&gt; &lt;code&gt;emalloc(count)&lt;/code&gt;
&lt;code&gt;ecalloc(count, num)&lt;/code&gt; &lt;code&gt;pemalloc(count, 1)&lt;/code&gt;&lt;sup&gt;&lt;em&gt;&lt;/sup&gt; &lt;code&gt;pecalloc(count, num, 1)&lt;/code&gt;
&lt;code&gt;strdup(str)&lt;/code&gt; &lt;code&gt;strndup(str, len)&lt;/code&gt; &lt;code&gt;estrdup(str)&lt;/code&gt;
&lt;code&gt;estrndup(str, len)&lt;/code&gt; &lt;code&gt;pestrdup(str, 1)&lt;/code&gt; &lt;code&gt;pemalloc() &amp;amp;amp; memcpy()``free(ptr)``efree(ptr)``pefree(ptr, 1)``realloc(ptr, newsize)``erealloc(ptr, newsize)``perealloc(ptr, newsize, 1)``malloc(count * num + extr)&lt;/code&gt;&lt;sup&gt;**&lt;/sup&gt;&lt;code&gt;safe_emalloc(count, num, extr)``safe_pemalloc(count, num, extr)&lt;/code&gt;&lt;/em&gt; &lt;strong&gt;The &lt;code&gt;pemalloc()&lt;/code&gt; family include a ‘persistent’ flag which allows them to behave like their non-persistent counterparts.&lt;br/&gt;For example: &lt;code&gt;emalloc(1234)&lt;/code&gt; is the same as &lt;code&gt;pemalloc(1234, 0)&lt;/code&gt;&lt;/strong&gt;&lt;br/&gt;** &lt;strong&gt;&lt;code&gt;safe_emalloc()&lt;/code&gt; and (in PHP 5) &lt;code&gt;safe_pemalloc()&lt;/code&gt; perform an additional check to avoid integer overflows&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;建立一个开发环境&lt;/h3&gt;

&lt;p&gt;现在你已经掌握了一些关于PHP和ZE的工作原理，我估计你希望要深入进去，并且开始写些什么。无论如何在你能做之前，你需要收集一些必要的开发工具，并且建立一个满足自己目标的环境。&lt;/p&gt;

&lt;p&gt;第一你需要PHP本身，以及构建PHP所需要的开发工具集合。如果你对于从源码编译PHP不熟悉，我建议你看看&lt;a href=&quot;http://www.php.net/install.unix&quot;&gt;http://www.php.net/install.unix&lt;/a&gt;。(开发windows下的PHP扩展在以后的文章会介绍)。使用适合自己发行版的PHP二进制包是很诱人的，但是这些版本总是会忽略两个重要的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./configure
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;选项，这两个选项在开发过程中非常方便。第一个是&lt;code&gt;--enable-debug&lt;/code&gt;。这个选项将会用附加符号信息来编译PHP所以，如果一个段错误发生，那么你将可以从PHP收集到一个核心dump信息，然后使用gdb来跟踪这个段错误是在哪里发生的，为什么会发生。另一个选项依赖于你将要进行扩展开发的PHP版本。在PHP4.3这个选项叫&lt;code&gt;--enable-experimental-zts&lt;/code&gt;，在PHP5和以后的版本中叫&lt;code&gt;--enable-maintainer-zts&lt;/code&gt;。这个选项将会让PHP思考在多线程环境中的行为，并且可以让你捕获常见的程序错误，这些错误在非线程环境中不会引起问题，但在多线程环境中却使你的扩展变得不可用。一旦你已经使用这些额外的选项编译好了PHP，并且已经安装在了你的开发服务器（或者工作站）上，那么你可以开始建立你的第一个扩展了。&lt;/p&gt;

&lt;h3&gt;Hello World&lt;/h3&gt;

&lt;p&gt;如果一门语言的入门介绍没有&lt;strong&gt;Hello World&lt;/strong&gt;程序，那么这个介绍就是不完整的。在这种情况下，你将会建立一个扩展，这个扩展会导出一个返回”Hello World”字符串的函数。如果用PHP，你可能这么写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
function hello_world()
{
    return 'Hello World';
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在你将会把这个逻辑放到一个PHP扩展中。首先让我们在你PHP源码树的&lt;strong&gt;ext/&lt;/strong&gt;目录下创建一个名叫&lt;strong&gt;hello&lt;/strong&gt;的目录，并进入(&lt;code&gt;chdir&lt;/code&gt;)到这个目录中。这个目录实际上可以放在任何地方，PHP源码树内或者PHP源码树外，但是我希望你把它放在源码树内为了接下来的文章使用。在这你需要创建三个文件：一个包含你&lt;code&gt;hello_world&lt;/code&gt;函数的&lt;strong&gt;源文件&lt;/strong&gt;，一个&lt;strong&gt;头文件&lt;/strong&gt;，其中包含PHP加载你扩展时候所需的引用，一个&lt;strong&gt;配置文件&lt;/strong&gt;，它会被phpize用来准备扩展的编译环境。&lt;/p&gt;

&lt;h3&gt;config.m4&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;PHP_ARG_ENABLE(hello, whether to enable Hello World support,
[ --enable-hello Enable Hello World support])

if test &quot;$PHP_HELLO&quot; = &quot;yes&quot;; then
    AC_DEFINE(HAVE_HELLO, 1, [Whether you have Hello World])
    PHP_NEW_EXTENSION(hello, hello.c, $ext_shared)
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;php_hello.h&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#ifndef PHP_HELLO_H
    #define PHP_HELLO_H 1
    #define PHP_HELLO_WORLD_VERSION &quot;1.0&quot;
    #define PHP_HELLO_WORLD_EXTNAME &quot;hello&quot;

    PHP_FUNCTION(hello_world);
    extern zend_module_entry hello_module_entry;
    #define phpext_hello_ptr &amp;amp;hello_module_entry

#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;hello.c&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#ifdef HAVE_CONFIG_H
    #include &quot;config.h&quot;
#endif

#include &quot;php.h&quot;
#include &quot;php_hello.h&quot;

static function_entry hello_functions[] = {
    PHP_FE(hello_world, NULL)
    {NULL, NULL, NULL}
};

zend_module_entry hello_module_entry = {
#if ZEND_MODULE_API_NO &amp;gt;= 20010901
    STANDARD_MODULE_HEADER,
#endif
    PHP_HELLO_WORLD_EXTNAME,
    hello_functions,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
#if ZEND_MODULE_API_NO &amp;gt;= 20010901
    PHP_HELLO_WORLD_VERSION,
#endif
    STANDARD_MODULE_PROPERTIES
};

#ifdef COMPILE_DL_HELLO
    ZEND_GET_MODULE(hello)
#endif

PHP_FUNCTION(hello_world)
{
    RETURN_STRING(&quot;Hello World&quot;, 1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上只是一个PHP扩展的大体框架，扩展中的大部分代码只是简单的把几个文件关联在了一起。只有最后四句才像你之前在PHP脚本中调用的“实际代码”。实际上这个层级的代码和我们之前看到的PHP代码非常的相似，从字面上很容易理解：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;声明一个名叫&lt;code&gt;hello_world&lt;/code&gt;的函数&lt;/li&gt;
&lt;li&gt;让那个函数返回一个字符串：“Hello World”&lt;/li&gt;
&lt;li&gt;...额... 1? 那个1是做什么的？&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;回想一下ZE有一个先进的内存管理层，当脚本退出的时候确保分配的资源被释放掉。在内存管理领域，对同一块内存进行两次释放是大错特错的。这种做法叫做&lt;strong&gt;double freeing&lt;/strong&gt;，是引起段错误的常见原因，因为它让程序去访问一个已经不属于自己的内存块。类似的，你不希望让ZE去释放一个静态字符串buffer（就像我们示例扩展中的”Hello World”），因为它是在程序空间，并不是属于任何进程的数据块。&lt;code&gt;RETURN_STRING()&lt;/code&gt;假设任何传递给它的字符串都需要一个拷贝，所以它们可以在之后安全的释放掉。但是由于在一个内部函数中为字符串分配内存，动态填充，然后返回它，这是很平常，&lt;code&gt;RETURN_STRING()&lt;/code&gt;允许我们来指定是否有必要对这个字符串值进行拷贝。为了更好的解释这个概念，接下来的代码片段的功能和上面的是一样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PHP_FUNCTION(hello_world)
{
    char *str;

    str = estrdup(&quot;Hello World&quot;);
    RETURN_STRING(str, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个版本中，你手动为”Hello World”字符串分配了内存，最终返回给调用脚本，然后把内存“给了”&lt;code&gt;RETURN_STRING&lt;/code&gt;，第二个参数值0说明不需要为这个字符串做拷贝。&lt;/p&gt;

&lt;h3&gt;建立你的扩展&lt;/h3&gt;

&lt;p&gt;这个练习的最后一步是把你的扩展编译成一个动态加载的模块。如果你已经正确的拷贝以上的例子，那么这个工作就是在&lt;strong&gt;ext/hello/&lt;/strong&gt;目录下执行三个命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ phpize
$ ./configure --enable-hello
$ make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在运行了这些命令之后，你将会在&lt;strong&gt;ext/hello/modules&lt;/strong&gt;目录中发现一个&lt;strong&gt;hello.so&lt;/strong&gt;文件。现在，可以像其他PHP扩展一样，你可以把它拷贝到你的扩展目录（默认是&lt;strong&gt;/usr/local/lib/php/extensions/&lt;/strong&gt;，检查你的&lt;strong&gt;php.ini&lt;/strong&gt;文件确定一下）中，然后在你的&lt;strong&gt;php.ini&lt;/strong&gt;文件中加上&lt;code&gt;extension=hello.so&lt;/code&gt;这一行，让扩展可以在PHP启动的时候被加载。对于CGI/CLI SAPI来说，这个意味着下一次PHP运行的时候就会生效；对于web server SAPI比如Apache来说，这个意味着web server下次被重启的时候生效。现在让我们以命令行的形式做一个尝试：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ php -r 'echo hello_world();'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果一切正常，你将会看到由这个脚本输出的&lt;strong&gt;Hello World&lt;/strong&gt;，因为在你加载的扩展中已经定义的&lt;code&gt;hello_world()&lt;/code&gt;函数会返回Hello World这个字符串，然后&lt;strong&gt;echo&lt;/strong&gt;命令会打印出任何传递给它的东西。&lt;/p&gt;

&lt;p&gt;其他标量也可以用类似的函数返回，用&lt;code&gt;RETURN_LONG()&lt;/code&gt;返回整型值，&lt;code&gt;RETURN_DOUBLE()&lt;/code&gt;返回浮点型值，&lt;code&gt;RETURN_BOOL()&lt;/code&gt;返回布尔型值，&lt;code&gt;RETURN_NULL()&lt;/code&gt;返回的值，你懂的，&lt;code&gt;NULL&lt;/code&gt;。在&lt;strong&gt;hello.c&lt;/strong&gt;文件中的&lt;code&gt;function_entry&lt;/code&gt;结构体中加入几行&lt;code&gt;PHP_FE()&lt;/code&gt;代码并且在文件最后加入几行&lt;code&gt;PHP_FUNCTION()&lt;/code&gt;代码，让我们真实的看看这些函数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static function_entry hello_functions[] = {
    PHP_FE(hello_world, NULL)
    PHP_FE(hello_long, NULL)
    PHP_FE(hello_double, NULL)
    PHP_FE(hello_bool, NULL)
    PHP_FE(hello_null, NULL)
    {NULL, NULL, NULL}
};

PHP_FUNCTION(hello_long)
{
    RETURN_LONG(42);
}

PHP_FUNCTION(hello_double)
{
    RETURN_DOUBLE(3.1415926535);
}

PHP_FUNCTION(hello_bool)
{
    RETURN_BOOL(1);
}

PHP_FUNCTION(hello_null)
{
    RETURN_NULL();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你还需要在头文件&lt;strong&gt;php_hello.h&lt;/strong&gt;中为这些函数添加原型声明，添加在&lt;code&gt;hello_world()&lt;/code&gt;函数原型旁边，这样构建程序就可以恰当的进行宏替换：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PHP_FUNCTION(hello_world);
PHP_FUNCTION(hello_long);
PHP_FUNCTION(hello_double);
PHP_FUNCTION(hello_bool);
PHP_FUNCTION(hello_null);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你对&lt;strong&gt;config.m4&lt;/strong&gt;文件没有做过更改，那么这次跳过&lt;strong&gt;phpize&lt;/strong&gt;和&lt;strong&gt;./configure&lt;/strong&gt;步骤，直接&lt;strong&gt;make&lt;/strong&gt;，在技术上来说这是安全的。但是无论如何，为了能够没有问题的构建这个扩展，这次我还是想让你完整的走这三个步骤。另外，这次你应该用make clean，而不是上次用的make，从而确保所有源文件都被重新构建。其实这个还是不必要的，因为你做的修改很有限，但是安全比混乱要好。一旦模块构建好了之后，你可以把它拷贝到你的扩展目录下，替换旧的版本。&lt;/p&gt;

&lt;p&gt;此时你可以再一次调用PHP解释器，用一个简单的脚本来测试你刚才加的函数。事实上，为什么你现在不做呢？我在这儿等你….&lt;/p&gt;

&lt;p&gt;测试好了？很好。如果你使用&lt;code&gt;var_dump()&lt;/code&gt;而不是&lt;code&gt;echo&lt;/code&gt;来看每个函数的输出的话，你可能会注意到&lt;code&gt;hello_bool()&lt;/code&gt;返回的是true。这是&lt;code&gt;RETURN_BOOL()&lt;/code&gt;函数中1所代表的值。就像在PHP脚本中，一个整型的0等于&lt;code&gt;FALSE&lt;/code&gt;，同时任何其他的整型值等于&lt;code&gt;TRUE&lt;/code&gt;。扩展的作者们经常使用1来表示&lt;code&gt;TRUE&lt;/code&gt;，也建议你那样做，但是不要拘泥于此。为了添加可读性，&lt;code&gt;RETURN_TRUE&lt;/code&gt;和&lt;code&gt;RETURN_FALSE&lt;/code&gt;宏也是可用的；下面是&lt;code&gt;hello_bool()&lt;/code&gt;的重写，这次使用&lt;code&gt;RETURN_TRUE&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PHP_FUNCTION(hello_bool)
{
    RETURN_TRUE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意这没有使用括号。&lt;code&gt;RETURN_TRUE&lt;/code&gt;和&lt;code&gt;RETURN_FALSE&lt;/code&gt;跟其他RETURN_*()宏不一样，所以别搞错了。&lt;/p&gt;

&lt;p&gt;你可能注意到在以上代码示例中，我们没有传递0或者1来指定是否这个值需要被拷贝。这是因为对于这些简单的标量来说，并没有额外的内存被分配或者释放。&lt;/p&gt;

&lt;p&gt;这还有三个额外的返回类型：&lt;code&gt;RESOURCE&lt;/code&gt;（&lt;code&gt;mysql_connect()&lt;/code&gt;, &lt;code&gt;fsockopen()&lt;/code&gt;和&lt;code&gt;ftp_connect()&lt;/code&gt;等函数返回的类型），&lt;code&gt;ARRAY&lt;/code&gt;（也就是&lt;code&gt;HASH&lt;/code&gt;表），&lt;code&gt;OBJECT&lt;/code&gt;（&lt;code&gt;new&lt;/code&gt;关键字返回的）。这些类型我们将会在&lt;a href=&quot;http://weizhifeng.net/write-php-extension-part2-1.html&quot;&gt;第二部分&lt;/a&gt;也就是深入变量的时候来介绍。&lt;/p&gt;

&lt;h3&gt;INI设置&lt;/h3&gt;

&lt;p&gt;Zend引擎提供了两种管理&lt;code&gt;INI&lt;/code&gt;值的方法。我们现在先看一下简单的方法，之后当你有机会使用全局变量的时候，再看一下更加完整，更加复杂的方法。&lt;/p&gt;

&lt;p&gt;假设你想在你的扩展中声明一个&lt;strong&gt;php.ini&lt;/strong&gt;的配置项，&lt;code&gt;hello.greeting&lt;/code&gt;，这个值被你的函数&lt;code&gt;hello_world()&lt;/code&gt;所使用。你需要对&lt;code&gt;hello_module_entry&lt;/code&gt;做些关键的修改，同时还需要在&lt;strong&gt;hello.c&lt;/strong&gt;和&lt;strong&gt;php_hello.h&lt;/strong&gt;中添加些东西。在&lt;strong&gt;php_hello.h&lt;/strong&gt;的用户区函数原型附近添加如下的函数原型：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PHP_MINIT_FUNCTION(hello);
PHP_MSHUTDOWN_FUNCTION(hello);
PHP_FUNCTION(hello_world);
PHP_FUNCTION(hello_long);
PHP_FUNCTION(hello_double);
PHP_FUNCTION(hello_bool);
PHP_FUNCTION(hello_null);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在到&lt;strong&gt;hello.c&lt;/strong&gt;文件顶部，用以下内容替换掉&lt;code&gt;hello_module_entry&lt;/code&gt;的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;zend_module_entry hello_module_entry = {

#if ZEND_MODULE_API_NO &amp;gt;= 20010901
    STANDARD_MODULE_HEADER,
#endif
    PHP_HELLO_WORLD_EXTNAME,
    hello_functions,
    PHP_MINIT(hello),
    PHP_MSHUTDOWN(hello),
    NULL,
    NULL,
    NULL,
#if ZEND_MODULE_API_NO &amp;gt;= 20010901
    PHP_HELLO_WORLD_VERSION,
#endif
    STANDARD_MODULE_PROPERTIES
};


PHP_INI_BEGIN()
PHP_INI_ENTRY(&quot;hello.greeting&quot;, &quot;Hello World&quot;, PHP_INI_ALL, NULL)
PHP_INI_END()

PHP_MINIT_FUNCTION(hello)
{
    REGISTER_INI_ENTRIES();
    return SUCCESS;
}

PHP_MSHUTDOWN_FUNCTION(hello)
{
    UNREGISTER_INI_ENTRIES();
    return SUCCESS;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，你只需要在&lt;strong&gt;hello.c&lt;/strong&gt;文件头部的&lt;code&gt;#inlcude&lt;/code&gt;代码后面添加一行，从获取对&lt;code&gt;INI&lt;/code&gt;文件支持所需要的正确头文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#ifdef HAVE_CONFIG_H
    #include &quot;config.h&quot;
#endif

#include &quot;php.h&quot;
#include &quot;php_ini.h&quot;
#include &quot;php_hello.h&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，你可以修改你的&lt;code&gt;hello_world&lt;/code&gt;函数来使用&lt;code&gt;INI&lt;/code&gt;值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PHP_FUNCTION(hello_world)
{
    RETURN_STRING(INI_STR(&quot;hello.greeting&quot;), 1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，你拷贝了从&lt;code&gt;INI_STR()&lt;/code&gt;返回的值。因为这是一个静态的字符串。事实上，如果你尝试去修改&lt;code&gt;INI_STR&lt;/code&gt;返回的这个字符串，PHP执行环境将会变得不稳定，甚至会崩溃。&lt;/p&gt;

&lt;p&gt;首先要修改的地方是你非常熟悉的两个函数：&lt;code&gt;MINIT&lt;/code&gt;，&lt;code&gt;MSHUTDOWN&lt;/code&gt;。就像前面提到的，这些函数会在SAPI层初始化启动和最后关闭的时候被调用。他们不会在请求过程中被调用。在这个例子中，你已经用这些函数在你的扩展中注册了&lt;strong&gt;php.ini&lt;/strong&gt;的配置内容。在接下来的内容中，你将会知道如何用&lt;code&gt;MINIT&lt;/code&gt;和&lt;code&gt;MSHUTDOWN&lt;/code&gt;函数来注册resource，object和stream handler。&lt;/p&gt;

&lt;p&gt;在你的&lt;code&gt;hello_world()&lt;/code&gt;函数中，你用&lt;code&gt;INI_STR()&lt;/code&gt;来获得了&lt;code&gt;hello.greeting&lt;/code&gt;当前的值，字符串格式。在下面表格中列出了一些其他函数，这些函数可以返回long，double和Boolean类型的值，并且还有一些带有&lt;code&gt;ORIG&lt;/code&gt;标识的更加原始的函数，这些函数返回&lt;strong&gt;php.ini&lt;/strong&gt;中最初设置的值（在被&lt;strong&gt;.htaccess&lt;/strong&gt;文件或者&lt;code&gt;ini_set()&lt;/code&gt;修改之前）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Current Value   Original Value  Type
INI_STR(name)   INI_ORIG_STR(name)  char * (NULL terminated)
INI_INT(name)   INI_ORIG_INT(name)  signed long
INI_FLT(name)   INI_ORIG_FLT(name)  signed double
INI_BOOL(name)  INI_ORIG_BOOL(name) zend_bool
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;传递给&lt;code&gt;PHP_INI_ENTRY()&lt;/code&gt;的第一个参数是在&lt;strong&gt;php.ini&lt;/strong&gt;中使用的&lt;strong&gt;配置项名称&lt;/strong&gt;。为了避免命名空间的冲突，你应该使用跟你函数命名相同的习惯；在所有的配置项之前都加一个和你扩展名字相同的前缀，就像&lt;code&gt;hello.greeting&lt;/code&gt;一样。事实上习惯就是，一个“.”把扩展名字和ini配置的名字分开。&lt;/p&gt;

&lt;p&gt;第二个参数是&lt;strong&gt;初始化值&lt;/strong&gt;，不管它是否是数字类型的，总是传递&lt;code&gt;char*&lt;/code&gt;字符串类型。这是因为事实上&lt;strong&gt;.ini&lt;/strong&gt;文件中的值都是原生的文本类型。你可以在你的脚本中用&lt;code&gt;INI_INT()&lt;/code&gt;，&lt;code&gt;INI_FLT()&lt;/code&gt;，或者&lt;code&gt;INI_BOOL()&lt;/code&gt;来做类型转换。&lt;/p&gt;

&lt;p&gt;你传递的第三个值是一个&lt;strong&gt;访问模式标识&lt;/strong&gt;。这是一个掩码字段，用来决定在什么时候，在什么地方这个&lt;code&gt;INI&lt;/code&gt;的配置项可以被修改。一些配置项，比如像&lt;code&gt;register_globals&lt;/code&gt;，它就不可能在脚本中用&lt;code&gt;ini_set()&lt;/code&gt;来进行修改，因为这个配置项只有在请求启动的时候才有意义，也就是脚本根本就没有机会去修改它。其他的，比如像&lt;code&gt;allow_url_fopen&lt;/code&gt;，它是管理员级别的配置项，所以你不希望在共享托管环境中的用户去修改它，不管是通过&lt;code&gt;ini_set()&lt;/code&gt;还是用&lt;strong&gt;.htaccess&lt;/strong&gt;指令。这个参数常见的值可能是&lt;code&gt;PHP_INI_ALL&lt;/code&gt;，表明这个配置项可以在任何地方修改。还有&lt;code&gt;PHP_INI_SYSTEM｜PHP_INI_PERDIR&lt;/code&gt;，表明配置项可以在&lt;strong&gt;php.ini&lt;/strong&gt;文件或者在&lt;strong&gt;.htaccess&lt;/strong&gt;文件通过Apache的指令来修改，但是不能使用&lt;code&gt;ini_set()&lt;/code&gt;来修改。&lt;code&gt;PHP_INI_SYSTEM&lt;/code&gt;，表示这个配置项只能在&lt;strong&gt;php.ini&lt;/strong&gt;中修改，不能在其他地方修改。&lt;/p&gt;

&lt;p&gt;当前我们将要跳过第四个参数，只是提一下这个参数允许传递一个回调方法，这个方法会在&lt;strong&gt;ini&lt;/strong&gt;配置被修改的时候触发，无论什么时候，比如用&lt;strong&gt;ini_set()&lt;/strong&gt;修改。这就允许一个扩展可以在配置被修改的时候做一些更准确的控制，或者触发一个需要依赖新配置的动作。&lt;/p&gt;

&lt;h3&gt;全局变量&lt;/h3&gt;

&lt;p&gt;通常，一个扩展在一个特殊的请求中需要跟踪一个值，并保证这个值与同一时间其他的请求是独立开来的。在一个非线程SAPI中那很简单：在源文件中直接声明一个全局变量，在需要的时候访问它。麻烦是，自从PHP被设计成可以运行在多线程的web服务器上（像Apache2和IIS），所以需要把一个线程使用的全局变量与其他线程使用的全局变量分离开来。PHP用TSRM (Thread Safe Resource Management)抽象层，有时有也叫ZTS (Zend Thread Safety)，非常简单的解决了这个问题。&lt;/p&gt;

&lt;p&gt;事实上，你已经用过了TSRM的一部分，只是不知道而已。（先别费劲搜索呢；你将会发现这些东西都被隐藏了。）&lt;/p&gt;

&lt;p&gt;创建一个线程安全的全局变量的第一步，和其他全局变量都一样，先声明。由于这个例子的缘故，你必须声明一个&lt;code&gt;long&lt;/code&gt;类型值为&lt;code&gt;0&lt;/code&gt;的全局变量。每次调用&lt;code&gt;hello_long()&lt;/code&gt;函数的时候，你将会增加这个值，然后返回它。在&lt;strong&gt;php_hello.h&lt;/strong&gt;中的&lt;code&gt;#define PHP_HELLO_H&lt;/code&gt;代码段后面加上以下的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#ifdef ZTS
    #include &quot;TSRM.h&quot;
#endif

ZEND_BEGIN_MODULE_GLOBALS(hello)
    long counter;
ZEND_END_MODULE_GLOBALS(hello)

#ifdef ZTS
    #define HELLO_G(v) TSRMG(hello_globals_id, zend_hello_globals *, v)
#else
    #define HELLO_G(v) (hello_globals.v)
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这次你还是要使用&lt;code&gt;RINIT&lt;/code&gt;方法，所以你需要在头文件中声明它的原型：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PHP_MINIT_FUNCTION(hello);
PHP_MSHUTDOWN_FUNCTION(hello);
PHP_RINIT_FUNCTION(hello);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在让我们回到&lt;strong&gt;hello.c&lt;/strong&gt;中，在你的&lt;code&gt;include&lt;/code&gt;块后面加上如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#ifdef HAVE_CONFIG_H
    #include &quot;config.h&quot;
#endif

#include &quot;php.h&quot;
#include &quot;php_ini.h&quot;
#include &quot;php_hello.h&quot;
ZEND_DECLARE_MODULE_GLOBALS(hello)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改&lt;code&gt;hello_module_entry&lt;/code&gt;，添加&lt;code&gt;PHP_RINIT(hello)&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;zend_module_entry hello_module_entry = {

#if ZEND_MODULE_API_NO &amp;gt;= 20010901
    STANDARD_MODULE_HEADER,
#endif
    PHP_HELLO_WORLD_EXTNAME,
    hello_functions,
    PHP_MINIT(hello),
    PHP_MSHUTDOWN(hello),
    PHP_RINIT(hello),
    NULL,
    NULL,
#if ZEND_MODULE_API_NO &amp;gt;= 20010901
    PHP_HELLO_WORLD_VERSION,
#endif
    STANDARD_MODULE_PROPERTIES
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并修改你的MINIT函数，和另一对函数一起，用来在请求开始的时候初始化：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void php_hello_init_globals(zend_hello_globals *hello_globals)
{
}

PHP_RINIT_FUNCTION(hello)
{
    HELLO_G(counter) = 0;
    return SUCCESS;
}

PHP_MINIT_FUNCTION(hello)
{
    ZEND_INIT_MODULE_GLOBALS(hello, php_hello_init_globals, NULL);
    REGISTER_INI_ENTRIES();
    return SUCCESS;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，你可以修改&lt;code&gt;hello_long()&lt;/code&gt;函数来使用这个值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PHP_FUNCTION(hello_long)
{
    HELLO_G(counter)++;
    RETURN_LONG(HELLO_G(counter));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;strong&gt;php_hello.h&lt;/strong&gt;添加的内容中，你使用了一对宏&lt;code&gt;ZEND_BEGIN_MODULE_GLOBALS()&lt;/code&gt;和&lt;code&gt;ZEND_END_MODULE_GLOBALS()&lt;/code&gt; – 用来创建一个包含一个&lt;code&gt;long&lt;/code&gt;类型，名为&lt;code&gt;zend_hello_globals&lt;/code&gt;的结构体。然后你继续声明了&lt;code&gt;HELLO_G()&lt;/code&gt;来从一个线程池中获取值，或者只是从全局空间中获取 － 如果你为一个非线程环境编译的话。&lt;/p&gt;

&lt;p&gt;在&lt;strong&gt;hello.c&lt;/strong&gt;中你用了&lt;code&gt;ZEND_DECLARE_MODULE_GLOBALS()&lt;/code&gt;宏来真正实例化&lt;code&gt;zend_hello_globals&lt;/code&gt;结构体为一个真正的全局变量（如果是以非线程安全编译的话），或者一个线程资源池的一个成员。对于一个扩展的作者来说，这个区别我们不需要担心，因为Zend Engine已经为我们处理了这个事情。最后，在&lt;code&gt;MINIT&lt;/code&gt;中，你使用了&lt;code&gt;ZEND_INIT_MODULE_GLOBALS()&lt;/code&gt;来分配一个线程安全的资源id – 现在不用担心这个东西是什么。&lt;/p&gt;

&lt;p&gt;你可能注意到了那个&lt;code&gt;php_hello_init_globals()&lt;/code&gt;函数实际上根本没做任何事情，我们想在其中初始化&lt;code&gt;counter&lt;/code&gt;为&lt;code&gt;0&lt;/code&gt;，而实际上我们是在&lt;code&gt;RINIT&lt;/code&gt;中初始化的。为什么？&lt;/p&gt;

&lt;p&gt;关键在于这两个函数什么时候被调用。&lt;code&gt;php_hello_init_globals()&lt;/code&gt;只有当一个新的进程或者线程启动的时候才会被调用；而与此同时，每个进程可以处理多个请求，所以用这个函数来初始化我们的&lt;code&gt;counter&lt;/code&gt;为&lt;code&gt;0&lt;/code&gt;的话，那么这个初始化只会在第一个页面请求到达的时候工作。等随后到达这个相同进程的页面请求，得到的仍然是旧的&lt;code&gt;counter&lt;/code&gt;值，因此也就不会从0开始计数了。为了让每个单独的页面请求都能初始化&lt;code&gt;counter&lt;/code&gt;为&lt;code&gt;0&lt;/code&gt;，我们实现了&lt;code&gt;RINIT&lt;/code&gt;函数，就像你之前了解的那样，这个函数在每次页面请求的时候都会被调用。我们在这个时候包含了&lt;code&gt;php_hello_init_globals()&lt;/code&gt;函数是因为你将会在一段时间后使用它，同时也是由于如果把一个&lt;code&gt;NULL&lt;/code&gt;做为初始化函数传递给&lt;code&gt;ZEND_INIT_MODULE_GLOBALS()&lt;/code&gt;将会在非线程平台上引起一个段错误。&lt;/p&gt;

&lt;h3&gt;INI配置项作为全局变量值&lt;/h3&gt;

&lt;p&gt;如果你回想起之前，一个用&lt;code&gt;PHP_INI_ENTRY()&lt;/code&gt;声明的&lt;strong&gt;php.ini&lt;/strong&gt;的配置项被解析成一个字符串值，并且在需要的时候可以用&lt;code&gt;INI_INT()&lt;/code&gt;，&lt;code&gt;INI_FLT()&lt;/code&gt;和&lt;code&gt;INI_BOOL()&lt;/code&gt;转换成对应的类型。&lt;/p&gt;

&lt;p&gt;对于一些配置项，存在很多不必要的重复工作，比如配置项的值在一个脚本执行的时候被一遍又一遍的读取。幸运的是可以让ZE以一种特殊的数据类型来存储&lt;code&gt;INI&lt;/code&gt;配置项的值，并且只有值改变的时候才执行类型转换。让我们声明另一个&lt;code&gt;INI&lt;/code&gt;配置的值，这次是一个&lt;code&gt;Boolean&lt;/code&gt;类型，用来标示&lt;code&gt;counter&lt;/code&gt;是否增加或者减少。修改&lt;strong&gt;php_hello.h&lt;/strong&gt;文件的&lt;code&gt;MODULE_GLOBALS&lt;/code&gt;块为以下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ZEND_BEGIN_MODULE_GLOBALS(hello)
    long counter;
    zend_bool direction;
ZEND_ENG_MODULE_GLOBALS(hello)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，修改&lt;code&gt;PHP_INI_BEGIN()&lt;/code&gt;块内容从而来声明&lt;code&gt;INI&lt;/code&gt;配置项的值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PHP_INI_BEGIN()
    PHP_INI_ENTRY(&quot;hello.greeting&quot;, &quot;Hello World&quot;, PHP_INI_ALL, NULL)
    STD_PHP_INI_ENTRY(&quot;hello.direction&quot;, &quot;1&quot;, PHP_INI_ALL, OnUpdateBool, direction, zend_hello_globals, hello_globals)
PHP_INI_END()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，在&lt;code&gt;init_globals&lt;/code&gt;方法中初始化配置项：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void php_hello_init_globals(zend_hello_globals *hello_globals)
{
    hello_globals-&amp;gt;direction = 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，在&lt;code&gt;hello_long()&lt;/code&gt;函数中使用&lt;code&gt;INI&lt;/code&gt;配置项的值来决定是否要增加或者减少&lt;code&gt;counter&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PHP_FUNCTION(hello_long)
{
    if (HELLO_G(direction)) {
        HELLO_G(counter)++;
    } else {
        HELLO_G(counter)--;
    }
    RETURN_LONG(HELLO_G(counter));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是全部了。在&lt;code&gt;INI_ENTRY&lt;/code&gt;中指定的&lt;code&gt;OnUpdateBool&lt;/code&gt;方法将会自动的转换&lt;strong&gt;php.ini&lt;/strong&gt;，&lt;strong&gt;.htaccess&lt;/strong&gt;文件提供的或者在脚本中通过&lt;code&gt;ini_set()&lt;/code&gt;设置的值称为TRUE或者FALSE。&lt;code&gt;STD_PHP_INI_ENTRY&lt;/code&gt;的最后三个参数是来告诉PHP修改哪个全局变量，我们扩展的全局变量的数据结构，以及这些全局变量被保存到的全局容器的名称。&lt;/p&gt;

&lt;h3&gt;稳妥的检查&lt;/h3&gt;

&lt;p&gt;到现在我们的三个文件看起来应该像下面所列的一样。（一些内容已经被移除了，并且规整到一起，只为了易读）
&lt;strong&gt;config.m4&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PHP_ARG_ENABLE(hello, whether to enable Hello World support,
[ --enable-hello Enable Hello World support])

if test &quot;$PHP_HELLO&quot; = &quot;yes&quot;; then
    AC_DEFINE(HAVE_HELLO, 1, [Whether you have Hello World])
    PHP_NEW_EXTENSION(hello, hello.c, $ext_shared)
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;php_hello.h&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#ifndef PHP_HELLO_H
    #define PHP_HELLO_H 1

    #ifdef ZTS
        #include &quot;TSRM.h&quot;
    #endif

    ZEND_BEGIN_MODULE_GLOBALS(hello)
        long counter;
        zend_bool direction;
    ZEND_END_MODULE_GLOBALS(hello)

    #ifdef ZTS
        #define HELLO_G(v) TSRMG(hello_globals_id, zend_hello_globals *, v)
    #else
        #define HELLO_G(v) (hello_globals.v)
    #endif

    #define PHP_HELLO_WORLD_VERSION &quot;1.0&quot;
    #define PHP_HELLO_WORLD_EXTNAME &quot;hello&quot;

    PHP_MINIT_FUNCTION(hello);
    PHP_MSHUTDOWN_FUNCTION(hello);
    PHP_RINIT_FUNCTION(hello);

    PHP_FUNCTION(hello_world);
    PHP_FUNCTION(hello_long);
    PHP_FUNCTION(hello_double);
    PHP_FUNCTION(hello_bool);
    PHP_FUNCTION(hello_null);

    extern zend_module_entry hello_module_entry;
    #define phpext_hello_ptr &amp;amp;hello_module_entry
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;hello.c&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#ifdef HAVE_CONFIG_H
    #include &quot;config.h&quot;
#endif

#include &quot;php.h&quot;
#include &quot;php_ini.h&quot;
#include &quot;php_hello.h&quot; 

ZEND_DECLARE_MODULE_GLOBALS(hello)

static function_entry hello_functions[] = {
    PHP_FE(hello_world, NULL)
    PHP_FE(hello_long, NULL)
    PHP_FE(hello_double, NULL)
    PHP_FE(hello_bool, NULL)
    PHP_FE(hello_null, NULL)
    {NULL, NULL, NULL}
};

zend_module_entry hello_module_entry = {
#if ZEND_MODULE_API_NO &amp;gt;= 20010901
    STANDARD_MODULE_HEADER,
#endif
   PHP_HELLO_WORLD_EXTNAME,
   hello_functions,
   PHP_MINIT(hello),
   PHP_MSHUTDOWN(hello),
   PHP_RINIT(hello),
   NULL,
   NULL,
#if ZEND_MODULE_API_NO &amp;gt;= 20010901
   PHP_HELLO_WORLD_VERSION,
#endif
   STANDARD_MODULE_PROPERTIES
};

#ifdef COMPILE_DL_HELLO
    ZEND_GET_MODULE(hello)
#endif

PHP_INI_BEGIN()
    PHP_INI_ENTRY(&quot;hello.greeting&quot;, &quot;Hello World&quot;, PHP_INI_ALL, NULL)
    STD_PHP_INI_ENTRY(&quot;hello.direction&quot;, &quot;1&quot;, PHP_INI_ALL, OnUpdateBool, direction, zend_hello_globals, hello_globals)
PHP_INI_END()

static void php_hello_init_globals(zend_hello_globals *hello_globals)
{
    hello_globals-&amp;gt;direction = 1;
}

PHP_RINIT_FUNCTION(hello)
{
    HELLO_G(counter) = 0;
    return SUCCESS;
}

PHP_MINIT_FUNCTION(hello)
{
    ZEND_INIT_MODULE_GLOBALS(hello, php_hello_init_globals, NULL);
    REGISTER_INI_ENTRIES();
    return SUCCESS;
}

PHP_MSHUTDOWN_FUNCTION(hello)
{
    UNREGISTER_INI_ENTRIES();
    return SUCCESS;
}

PHP_FUNCTION(hello_world)
{
    RETURN_STRING(&quot;Hello World&quot;, 1);
}

PHP_FUNCTION(hello_long)
{
    if (HELLO_G(direction)) {
        HELLO_G(counter)++;
    } else {
        HELLO_G(counter)--;
    } 

    RETURN_LONG(HELLO_G(counter));
}

PHP_FUNCTION(hello_double)
{
    RETURN_DOUBLE(3.1415926535);
}

PHP_FUNCTION(hello_bool)
{
    RETURN_BOOL(1);
}

PHP_FUNCTION(hello_null)
{
    RETURN_NULL();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;接下来是什么？&lt;/h3&gt;

&lt;p&gt;在这个教程中，我们探寻了一个简单PHP扩展的结构，这个扩展向用户空间增加了函数，返回了值，声明了INI配置，跟踪了一个请求过程中的内部状态。&lt;/p&gt;

&lt;p&gt;在下一个话题中，我们将要探寻PHP变量的内部结构，看看它们在一个脚本环境中是什么怎么样被存储，跟踪，以及维护的。当一个函数被调用时候，我们将要使用&lt;code&gt;zend_parse_parameters&lt;/code&gt;来接收参数，然后探寻如何返回更复杂的结果，包括这次教程中所提及的&lt;code&gt;数组&lt;/code&gt;，&lt;code&gt;对象&lt;/code&gt;，以及&lt;code&gt;资源&lt;/code&gt;类型。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Varnish安装与配置</title>
   <link href="http://weizhifeng.net/using-varnish.html"/>
   <updated>2011-06-19T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/using-varnish</id>
   <content type="html">&lt;h3&gt;介绍&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.varnish-cache.org/&quot; title=&quot;Varnish&quot;&gt;Varnish&lt;/a&gt;是一款高性能的开源HTTP加速器，挪威最大的在线报纸&lt;a href=&quot;http://www.vg.no&quot; title=&quot;Verdens Gang&quot;&gt;Verdens Gang&lt;/a&gt;使用3台Varnish代替了原来的12台Squid，性能居然比以前更好。Varnish 的作者Poul-Henning Kamp是FreeBSD的内核开发者之一，他认为现在的计算机比起1975年已经复杂许多。在1975年时，储存媒介只有两种：内存与硬盘。但现在计算机系统的内存除了主存外，还包括了cpu内的L1、L2，甚至有L3快取。硬盘上也有自己的快取装置，因此Squid cache自行处理物件替换的架构不可能得知这些情况而做到最佳化，但操作系统可以得知这些情况，所以这部份的工作应该交给操作系统处理，这就是Varnish cache设计架构。目前很多互联网公司在使用Varnish，其中包括&lt;a href=&quot;http://www.facebook.com&quot; title=&quot;非死不可&quot;&gt;Facebook&lt;/a&gt;。&lt;/p&gt;

&lt;h3&gt;特性&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.varnish-cache.org/docs/2.1/reference/vcl.html&quot; title=&quot;vcl&quot;&gt;VCL&lt;/a&gt;(Varnish Configuration Language)：区别于其他系统，Varnish采用了自身的配置语言来配置，非常容易上手，这些配置会被编译成二进制机器码，明显加快了执行速度。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.varnish-cache.org/docs/2.1/tutorial/advanced_backend_servers.html#health-checks&quot; title=&quot;health check&quot;&gt;Health checks&lt;/a&gt;：完善的健康检查机制。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.varnish-cache.org/docs/2.1/tutorial/esi.html&quot; title=&quot;ESI&quot;&gt;ESI&lt;/a&gt;(Edge Side Includes)：在HTML中嵌入动态脚本文件。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.varnish-cache.org/docs/2.1/reference/vcl.html#directors&quot; title=&quot;directors&quot;&gt;Directors&lt;/a&gt;：后端服务器的调度方式：random，round-robin，client，hash，DNS。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.varnish-cache.org/docs/2.1/tutorial/purging.html&quot; title=&quot;purging&quot;&gt;Purging and banning&lt;/a&gt;：强大的缓存清除功能，可以以正则表达式的形式清除缓存。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.varnish-cache.org/docs/2.1/tutorial/logging.html&quot; title=&quot;logging&quot;&gt;Logging in Varnish&lt;/a&gt;：Varnish的log不是记录在文件中的，而是记录在共享内存中。当日志大小达到分配的共享内存容量，覆盖掉旧的日志。以这种方式记录日志比文件的形式要快很多，并且不需要磁盘空间。&lt;/li&gt;
&lt;li&gt;丰富的管理程序：varnishadm，varnishtop，varnishhist，varnishstat以及varnishlog等。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;环境&lt;/h3&gt;

&lt;p&gt;OS: CentOS 5.5 &lt;br/&gt;
varnish: 2.1.5&lt;/p&gt;

&lt;h3&gt;安装&lt;/h3&gt;

&lt;p&gt;首先安装ncurses-devel，否则&lt;code&gt;varnishstat&lt;/code&gt;，&lt;code&gt;varnishtop&lt;/code&gt;都无法编译完成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ yum install ncurses-devel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来安装varnish&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wget http://repo.varnish-cache.org/source/varnish-2.1.5.tar.gz
$ tar -zxvf varnish-2.1.5.tar.gz
$ cd varnish-2.1.5
$ ./configure --prefix=/usr/local/varnish-2.1.5
$ make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ /usr/local/varnish2.1.5/sbin/varnishd -f \
/usr/local/varnish2.1.5/etc/varnish/default.vcl \
-T 127.0.0.1:2000 -a 0.0.0.0:80 -s file,/tmp,200M
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;-f&lt;/code&gt;用来指定配置文件，&lt;code&gt;-T&lt;/code&gt;指定管理台的访问地址，&lt;code&gt;-a&lt;/code&gt;指定Varnish监听地址，&lt;code&gt;-s&lt;/code&gt;指定Varnish以文件方式来缓存资源，地址为/tmp，大小200MB。&lt;/p&gt;

&lt;h3&gt;配置&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#后端处理器b1
backend b1{
    .host = &quot;192.168.2.110&quot;;
    .port = &quot;81&quot;;
    .connect_timeout = 5s;
    .first_byte_timeout= 5s;
    .probe = {
        #health check
        .url = &quot;/check.txt&quot;;
        .interval = 5s;
        .timeout = 5s;
        .window = 5;
        .threshold = 3;
    }
}

#后端处理器b2
backend b2{
    .host = &quot;192.168.2.109&quot;;
    .port = &quot;81&quot;;
    .connect_timeout = 5s;
    .first_byte_timeout = 5s;
    .probe = {
        #health check
        .url = &quot;/check.txt&quot;;
        .interval = 5s;
        .timeout = 5s;
        .window = 5;
        .threshold = 3;
    }
}

#以轮询方式实现负载均衡
director d1 round-robin {
    {
        .backend = b1;
    }

    {
        .backend = b2;
    }
}

#acl
acl purge {
    &quot;localhost&quot;;
    &quot;192.168.0.64&quot;;
}

sub vcl_recv {
     # 设置director
     set req.backend = d1;

     # 如果从后端返回的资源中含有Set-Cookie头的话，那么varnish不会进行缓存；
     # 如果客户端发送了Cookie头的话，那么varnish会bypass（绕开）缓存，
     # 直接发送到后端，并不会进行缓存，所以需要如下处理：
    if ( !( req.url ~ ^/admin/) ) {
        unset req.http.Cookie;
    }

    if (req.http.Cookie == &quot;&quot;) {
        remove req.http.Cookie;
    }

    if (req.restarts == 0) {
        if (req.http.x-forwarded-for) {
            set req.http.X-Forwarded-For =
                req.http.X-Forwarded-For &quot;, &quot; client.ip;
        } else {
            set req.http.X-Forwarded-For = client.ip;
        }
     }

     if (req.request != &quot;GET&quot; &amp;amp;&amp;amp;
       req.request != &quot;HEAD&quot; &amp;amp;&amp;amp;
       req.request != &quot;PUT&quot; &amp;amp;&amp;amp;
       req.request != &quot;POST&quot; &amp;amp;&amp;amp;
       req.request != &quot;TRACE&quot; &amp;amp;&amp;amp;
       req.request != &quot;OPTIONS&quot; &amp;amp;&amp;amp;
       req.request != &quot;DELETE&quot; &amp;amp;&amp;amp;
       req.request != &quot;PURGE&quot;) {

         /* Non-RFC2616 or CONNECT which is weird. */
         return (pipe);
     }

     # allow PURGE from localhost and 192.168.0...
     if (req.request == &quot;PURGE&quot;) {
         if (!client.ip ~ purge) {
             error 405 &quot;Not allowed.&quot;;
         }
         return (lookup);
     }

     if (req.request != &quot;GET&quot; &amp;amp;&amp;amp; req.request != &quot;HEAD&quot; &amp;amp;&amp;amp; req.request != &quot;PURGE&quot;) {
         /* We only deal with GET and HEAD by default */
         return (pass);
     }

     if (req.http.Authorization || req.http.Cookie) {
         /* Not cacheable by default */
         return (pass);
     }
     return (lookup);
 }

sub vcl_hit {
     if (req.request == &quot;PURGE&quot;) {
        # Note that setting ttl to 0 is magical.
        # the object is zapped from cache.
        set obj.ttl = 0s;
        error 200 &quot;Purged.&quot;;

     } else {
        return (deliver);
     }
}

sub vcl_miss {
    if (req.request == &quot;PURGE&quot;) {
        error 404 &quot;Not in cache.&quot;;
    } else {
        return (fetch);
    }
}

sub vcl_fetch {
     #设置TTL为1个小时
     set beresp.ttl = 1h;
     if (!beresp.cacheable) {
         return (pass);
     }

     if (beresp.http.Set-Cookie) {
         return (pass);
     }

     return (deliver);
 }

sub vcl_deliver {
     return (deliver);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;启动脚本&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ wget -O varnishd https://raw.github.com/gist/3671408/3a51578bbd60a4cf8317bdc9508527b81eb23da5/varnishd
$ cp varnishd /etc/init.d/varnishd
$ chmod +x /etc/init.d/varnishd
$ /etc/init.d/varnishd start
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Subroutine列表&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;vcl_recv&lt;/strong&gt;
在请求开始时候被调用，在请求已经被接收到并且解析后调用。目的就是决定是否处理这个请求，怎么处理，使用哪个后端。vcl_recv以&lt;code&gt;return&lt;/code&gt;结束，参数可以为如下关键字：  &lt;br/&gt;
  &lt;strong&gt;error code&lt;/strong&gt; [reason]：返回错误码给客户端，丢弃请求。 &lt;br/&gt;
  &lt;strong&gt;pass&lt;/strong&gt;：转换到pass模式。控制权最后会转移到&lt;code&gt;vcl_pass&lt;/code&gt;。  &lt;br/&gt;
  &lt;strong&gt;pipe&lt;/strong&gt;：转换到pipe模式。控制权最后会转移到&lt;code&gt;vcl_pipe&lt;/code&gt;。  &lt;br/&gt;
  &lt;strong&gt;lookup&lt;/strong&gt;：在缓存中寻找请求对象。控制权最后会转移到&lt;code&gt;vcl_hit&lt;/code&gt;或者&lt;code&gt;vcl_miss&lt;/code&gt;，决定于对象是否在缓存中。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;vcl_pipe&lt;/strong&gt;
当进入pipe模式的时候被调用。在这个模式中，请求会被转移到后端，后续的数据不管是从客户端还是后端来的都会以不变的方式传送，直到连接关闭为止。vcl_pipe以&lt;code&gt;return&lt;/code&gt;结束，参数可以为如下关键字：   &lt;br/&gt;
&lt;strong&gt;error code&lt;/strong&gt; [reason]：返回错误码给客户端，丢弃请求。 &lt;br/&gt;
&lt;strong&gt;pipe&lt;/strong&gt;：以pipe模式执行。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;vcl_pass&lt;/strong&gt;
当进入pass模式的时候会被调用。在这个模式中，请求会被传送到后端，然后后端的响应会被传送回客户端，但是响应不会进入缓存中。接下来通过相同客户端连接发起的请求会以普通的方式来处理。vcl_pass以&lt;code&gt;return&lt;/code&gt;结束，参数可以为如下关键字：  &lt;br/&gt;
&lt;strong&gt;error code&lt;/strong&gt; [reason]：返回错误码给客户端，丢弃请求。  &lt;br/&gt;
&lt;strong&gt;pass&lt;/strong&gt;：以pass模式执行。  &lt;br/&gt;
&lt;strong&gt;restart&lt;/strong&gt;：重新启动这个事务。增加了重启计数。如果重启的次数高于&lt;code&gt;max_restarts&lt;/code&gt;，varnish会引起一个错误。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;vcl_hash&lt;/strong&gt;
你如果把想把数据加入到hash中，那么调用hash_data()。vcl_hash以&lt;code&gt;return&lt;/code&gt;结束，参数可以为如下关键字：   &lt;br/&gt;
&lt;strong&gt;hash&lt;/strong&gt;：执行hash逻辑。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;vcl_hit&lt;/strong&gt;
如果请求的对象在缓存中被找到了，那么在缓存查找结束后被调用。vcl_hit以&lt;code&gt;return&lt;/code&gt;结束，参数可以为如下关键字： &lt;br/&gt;
&lt;strong&gt;deliver&lt;/strong&gt;：deliver缓存对象到客户端。控制权最后会转移到&lt;code&gt;vcl_deliver&lt;/code&gt;。 &lt;br/&gt;
&lt;strong&gt;error code&lt;/strong&gt; [reason]：返回错误码给客户端，丢弃请求。 &lt;br/&gt;
&lt;strong&gt;pass&lt;/strong&gt;：切换到pass模式。控制权最后会转移到&lt;code&gt;vcl_pass&lt;/code&gt;。 &lt;br/&gt;
&lt;strong&gt;restart&lt;/strong&gt;：重新启动这个事务。增加了重启计数。如果重启的次数高于&lt;code&gt;max_restarts&lt;/code&gt;，varnish会引起一个错误。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;vcl_miss&lt;/strong&gt;
如果请求的对象在缓存中没有被找到，那么在缓存查找结束后被调用。目的是为了决定是否去后端获取这个请求对象，并且要选择哪个后端。vcl_miss以return结束，参数可以为如下关键字：    &lt;br/&gt;
&lt;strong&gt;error code&lt;/strong&gt; [reason]：返回错误码给客户端，丢弃请求。   &lt;br/&gt;
&lt;strong&gt;pass&lt;/strong&gt;：切换到pass模式。控制权最后会转移到&lt;code&gt;vcl_pass&lt;/code&gt;。    &lt;br/&gt;
&lt;strong&gt;fetch&lt;/strong&gt;：去后端获取请求对象。控制权最后会转移到&lt;code&gt;vcl_fetch&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;vcl_fetch&lt;/strong&gt;
当一个对象被成功从后端获取的时候此方法会被调用。vcl_fetch以&lt;code&gt;return&lt;/code&gt;结束，参数可以为如下关键字：   &lt;br/&gt;
&lt;strong&gt;deliver&lt;/strong&gt;：可能把对象放入缓存中，然后再deliver到客户端。控制权最后会转移到&lt;code&gt;vcl_deliver&lt;/code&gt;。   &lt;br/&gt;
&lt;strong&gt;error code&lt;/strong&gt; [reason]：返回错误码给客户端，丢弃请求。    &lt;br/&gt;
&lt;strong&gt;esi&lt;/strong&gt;：以ESI形式来处理刚刚被获取到的对象。   &lt;br/&gt;
&lt;strong&gt;pass&lt;/strong&gt;：切换到pass模式。控制权最后会转移到&lt;code&gt;vcl_pass&lt;/code&gt;。   &lt;br/&gt;
&lt;strong&gt;restart&lt;/strong&gt;：重新启动这个事务。增加了重启计数。如果重启的次数高于&lt;code&gt;max_restarts&lt;/code&gt;，varnish会引起一个错误。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;vcl_deliver&lt;/strong&gt;当一个缓存的对象被deliver到客户端的时候，此方法会被调用。vcl_deliver以&lt;code&gt;return&lt;/code&gt;结束，参数可以为如下关键字：     &lt;br/&gt;
&lt;strong&gt;deliver&lt;/strong&gt;：发送对象到客户端。   &lt;br/&gt;
&lt;strong&gt;error code&lt;/strong&gt; [reason]：返回错误码给客户端，丢弃请求。   &lt;br/&gt;
&lt;strong&gt;restart&lt;/strong&gt;：重新启动这个事务，增加重启计数。如果重启的次数高于&lt;code&gt;max_restarts&lt;/code&gt;，varnish会引起一个错误。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;vcl_error&lt;/strong&gt;
当遇见一个错误的时候会被调用，错误可能是跟后端有关系或者内部错误。vcl_error以&lt;code&gt;return&lt;/code&gt;结束，参数可以为如下关键字：    &lt;br/&gt;
&lt;strong&gt;deliver&lt;/strong&gt;：发送对象到客户端。    &lt;br/&gt;
&lt;strong&gt;restart&lt;/strong&gt;：重新启动这个事务，增加重启计数。如果重启的次数高于&lt;code&gt;max_restarts&lt;/code&gt;，varnish会引起一个错误。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;重要变量&lt;/h3&gt;

&lt;p&gt;subroutine不带参数，一般通过全局变量来实现信息的传递。&lt;/p&gt;

&lt;p&gt;如下变量在&lt;strong&gt;backend&lt;/strong&gt;中有效：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;.host：backend的主机名或者IP。&lt;/li&gt;
&lt;li&gt;.port：backend的端口。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;如下变量在&lt;strong&gt;处理一个请求&lt;/strong&gt;（例如&lt;code&gt;vcl_recv&lt;/code&gt;）的时候可用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;client.ip：客户端IP地址。&lt;/li&gt;
&lt;li&gt;server.hostname：服务器的主机名。&lt;/li&gt;
&lt;li&gt;server.identity：服务器标示，当启动varnish的时候用&lt;code&gt;-i&lt;/code&gt;参数来指定。如果varnish启动时候没有指定&lt;code&gt;-i&lt;/code&gt;参数，那么server.identity会被设置为用&lt;code&gt;-n&lt;/code&gt;参数所指定的实例名称。&lt;/li&gt;
&lt;li&gt;server.ip：服务器IP地址。&lt;/li&gt;
&lt;li&gt;server.port：服务器端口。&lt;/li&gt;
&lt;li&gt;req.request：请求类型（例如&lt;code&gt;GET&lt;/code&gt;，&lt;code&gt;HEAD&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;req.url：请求的URL。&lt;/li&gt;
&lt;li&gt;req.proto：HTTP协议版本。&lt;/li&gt;
&lt;li&gt;req.backend：处理请求的后端服务器。&lt;/li&gt;
&lt;li&gt;req.backend.healthy：后端是否健康。health check需要在&lt;code&gt;backend&lt;/code&gt;的&lt;code&gt;probe&lt;/code&gt;中进行设置。&lt;/li&gt;
&lt;li&gt;req.http.header：相关的HTTP头。&lt;/li&gt;
&lt;li&gt;req.hash_always_miss：强迫对于本次请求的缓存查找结果为miss。如果设置为&lt;code&gt;true&lt;/code&gt;，那么varnish将会忽略任何存在的缓存对象，一直从后端重新获取资源。&lt;/li&gt;
&lt;li&gt;req.hash_ignore_busy：在缓存查找时候忽略任何忙的对象。如果有两个服务器，彼此互相查找缓存内容，那么可以使用这个变量来避免潜在的死锁。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;如下变量在&lt;strong&gt;准备一个后端请求&lt;/strong&gt;(比如在&lt;code&gt;cache miss&lt;/code&gt;或者&lt;code&gt;pass&lt;/code&gt;，&lt;code&gt;pipe&lt;/code&gt;模式)的时候可用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;bereq.request：请求的类型（比如&lt;code&gt;GET&lt;/code&gt;，&lt;code&gt;HEAD&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;bereq.url：请求的URL。&lt;/li&gt;
&lt;li&gt;bereq.proto：与后端服务器交互的HTTP协议版本。&lt;/li&gt;
&lt;li&gt;bereq.http.header：相关的HTTP头。&lt;/li&gt;
&lt;li&gt;bereq.connect_timeout：与后端连接的超时时间。&lt;/li&gt;
&lt;li&gt;bereq.first_byte_timeout：从后端返回第一个字节所需等待的秒数，在&lt;code&gt;pipe&lt;/code&gt;模式中不可用。&lt;/li&gt;
&lt;li&gt;bereq.between_bytes_timeout：从后端返回的每个字节之间的时间间隔，以秒计。在&lt;code&gt;pipe&lt;/code&gt;模式中不可用。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;如下的变量在&lt;strong&gt;请求对象从后端返回之后，在其被放入缓存之前&lt;/strong&gt;可用。换句话说，也就是在&lt;code&gt;vcl_fetch&lt;/code&gt;中可用。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;beresp.proto：HTTP协议版本。&lt;/li&gt;
&lt;li&gt;beresp.status：后端返回的HTTP状态码（例如200,302等）。&lt;/li&gt;
&lt;li&gt;beresp.response：后端返回的状态内容（例如&lt;code&gt;OK&lt;/code&gt;，&lt;code&gt;Found&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;beresp.cacheable：如果请求的结果是可以被缓存的，那么此变量为&lt;code&gt;true&lt;/code&gt;。如果HTTP状态码为200, 203, 300, 301, 302, 404，410之一并且&lt;code&gt;pass&lt;/code&gt;没有在&lt;code&gt;vcl_recv&lt;/code&gt;中被调用，那么这个结果就是可以被缓存的。如果response的&lt;code&gt;TTL&lt;/code&gt;和&lt;code&gt;grace time&lt;/code&gt;都为0，那么&lt;code&gt;beresp.cacheable&lt;/code&gt;将会为0。&lt;code&gt;beresp.cacheable&lt;/code&gt;是可写的。&lt;/li&gt;
&lt;li&gt;beresp.ttl：缓存对象的生存时间，以秒为单位，这个变量是可写的。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;在对象&lt;strong&gt;已经存在于缓存中并被查询到&lt;/strong&gt;的时候，一般在&lt;code&gt;vcl_hit&lt;/code&gt;和&lt;code&gt;vcl_deliver&lt;/code&gt;中，如下的变量（大部分是read-only）可用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;obj.proto：与后端交互的HTTP版本协议。&lt;/li&gt;
&lt;li&gt;obj.status：后端返回的HTTP状态码。&lt;/li&gt;
&lt;li&gt;obj.response：后端返回的HTTP状态内容。&lt;/li&gt;
&lt;li&gt;obj.cacheable：如果对象的beresp.cacheable为&lt;code&gt;true&lt;/code&gt;，那么此变量的值为&lt;code&gt;true&lt;/code&gt;。除非你强制delivery，否则&lt;code&gt;obj.cacheable&lt;/code&gt;一直为&lt;code&gt;true&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;obj.ttl：缓存对象的生存时间，以秒为单位，这个变量是可写的。&lt;/li&gt;
&lt;li&gt;obj.lastuse：从现在到对象最近一次访问所间隔的时间，以秒为单位。&lt;/li&gt;
&lt;li&gt;obj.hits：对象被发送到客户端的次数，0表示缓存查询miss了。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;如下变量在&lt;strong&gt;决定对象hash key&lt;/strong&gt;的时候可用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;req.hash：hash key被用来关联一个缓存中的对象。在读写缓存的时候都会被用到。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;如下变量在&lt;strong&gt;准备把一个响应发送给客户端&lt;/strong&gt;时候可用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;resp.proto：响应使用的HTTP协议版本。&lt;/li&gt;
&lt;li&gt;resp.status：将要返回的HTTP状态码。&lt;/li&gt;
&lt;li&gt;resp.response：将要返回的HTTP状态内容。&lt;/li&gt;
&lt;li&gt;resp.http.header：相关的HTTP头。&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>$_REQUEST数组详解</title>
   <link href="http://weizhifeng.net/more-about-global-request-array.html"/>
   <updated>2011-06-12T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/more-about-global-request-array</id>
   <content type="html">&lt;h3&gt;前言&lt;/h3&gt;

&lt;p&gt;$_REQUEST数组是PHP中比较常用的数组，一般从其中取出POST，GET，COOKIE等参数，在这里写明一下$_REQUEST数组的填充方式，防止出现一些意想不到的问题。&lt;/p&gt;

&lt;h3&gt;说明&lt;/h3&gt;

&lt;p&gt;在&lt;code&gt;php.ini&lt;/code&gt;中有如下的配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;; This directive determines which super global data (G,P,C,E &amp;amp; S) should
; be registered into the super global array REQUEST. If so, it also determines
; the order in which that data is registered. The values for this directive are
; specified in the same manner as the variables_order directive, EXCEPT one.
; Leaving this value empty will cause PHP to use the value set in the
; variables_order directive. It does not mean it will leave the super globals
; array REQUEST empty.
; Default Value: None
; Development Value: &quot;GP&quot;
; Production Value: &quot;GP&quot;
; http://php.net/request-order

request_order = &quot;GP&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;request_order&lt;/code&gt;这个配置项说明哪些全局变量（G，P，C，E，S分别代表&lt;code&gt;$_GET&lt;/code&gt;，&lt;code&gt;$_POST&lt;/code&gt;，&lt;code&gt;$COOKIE&lt;/code&gt;，&lt;code&gt;$_ENV&lt;/code&gt;，&lt;code&gt;$_SERVER&lt;/code&gt;）的内容会被添加到&lt;code&gt;$_REQUEST&lt;/code&gt;数组中，并且会指明变量填充的顺序，如果重名，那么后面填充的变量会覆盖前面填充的变量内容。如果把&lt;code&gt;request_order&lt;/code&gt;置空，那么PHP将会使用&lt;code&gt;variables_order&lt;/code&gt;（如下）配置项所指定的全局变量注册顺序来填充&lt;code&gt;$_REQUEST&lt;/code&gt;数组，而不是说把&lt;code&gt;$_REQUEST&lt;/code&gt;置空。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;; This directive determines which super global arrays are registered when PHP
; starts up. If the register_globals directive is enabled, it also determines
; what order variables are populated into the global space. G,P,C,E &amp;amp; S are
; abbreviations for the following respective super globals: GET, POST, COOKIE,
; ENV and SERVER. There is a performance penalty paid for the registration of
; these arrays and because ENV is not as commonly used as the others, ENV is
; is not recommended on productions servers. You can still get access to
; the environment variables through getenv() should you need to.
; Default Value: &quot;EGPCS&quot;
; Development Value: &quot;GPCS&quot;
; Production Value: &quot;GPCS&quot;;
; http://php.net/variables-order

variables_order = &quot;GPCS&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;variables_order&lt;/code&gt;这个配置项用来指定全局变量EGPCS (Environment, Get, Post, Cookie, and Server)的解析顺序。
如果&lt;code&gt;variables_order&lt;/code&gt;被设置为SP，那么PHP会创建&lt;code&gt;$_SERVER&lt;/code&gt;和&lt;code&gt;$_POST&lt;/code&gt;，而不会创建&lt;code&gt;$_ENV&lt;/code&gt;，&lt;code&gt;$_GET&lt;/code&gt;，&lt;code&gt;$_COOKIE&lt;/code&gt;等变量，
如果被设置为空，那么PHP不会创建任何超级全局变量。&lt;/p&gt;

&lt;h3&gt;注意&lt;/h3&gt;

&lt;p&gt;有时候从&lt;code&gt;$_REQUEST&lt;/code&gt;中取出的值不是想要的，考虑这样一个场景：
如果在&lt;code&gt;php.ini&lt;/code&gt;中设置&lt;code&gt;request_order = “GPCES”&lt;/code&gt;，在HTTP请求中GET或者POST参数的name恰好与COOKIE的name相同，假如为foo。
那么在程序中通过&lt;code&gt;$_REQUEST[‘foo’]&lt;/code&gt;来获取到的值是名为foo的一个cookie的值，而不是GET或者POST请求的值。&lt;/p&gt;

&lt;h3&gt;结语&lt;/h3&gt;

&lt;p&gt;尽量不要使用&lt;code&gt;$_REQUEST&lt;/code&gt;，应该从&lt;code&gt;$_GET&lt;/code&gt;，&lt;code&gt;$_POST&lt;/code&gt;，&lt;code&gt;$COOKIE&lt;/code&gt;，&lt;code&gt;$_ENV&lt;/code&gt;，&lt;code&gt;$_SERVER&lt;/code&gt;等变量中取出需要的值。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>金陵煙雨</title>
   <link href="http://weizhifeng.net/23230071618.html"/>
   <updated>2011-06-09T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/23230071618</id>
   <content type="html">&lt;p&gt;青城浸雨煙  &lt;br/&gt;
綿綿隱重山 &lt;br/&gt;
行人穿煙柳 &lt;br/&gt;
此地謂江南&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>無題</title>
   <link href="http://weizhifeng.net/23230049291.html"/>
   <updated>2011-05-01T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/23230049291</id>
   <content type="html">&lt;p&gt;人面似桃花  &lt;br/&gt;
淺笑作晚霞  &lt;br/&gt;
此生共相伴 &lt;br/&gt;
海角與天涯&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>浏览器中F5和CTRL F5的行为区别</title>
   <link href="http://weizhifeng.net/difference-between-f5-and-ctrl-f5.html"/>
   <updated>2011-04-24T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/difference-between-f5-and-ctrl-f5</id>
   <content type="html">&lt;h3&gt;前言&lt;/h3&gt;

&lt;p&gt;在印象中，浏览器中的F5和刷新按钮是一样的效果，都是对当前页面进行刷新；Ctrl-F5的行为也是刷新页面，但是会清除浏览器缓存，这在前端调试时候会常用。二者真正的区别是什么呢？在stackoverflow上有人给出了很详细的&lt;a href=&quot;http://stackoverflow.com/questions/385367/what-requests-do-browsers-f5-and-ctrl-f5-refreshes-generate&quot;&gt;解释&lt;/a&gt;，整理如下。&lt;/p&gt;

&lt;h3&gt;说明&lt;/h3&gt;

&lt;p&gt;在不同的浏览器中F5和CTRL-F5的行为是不一样的，但是他们的主要行为还是非常相似的，以下结果是在FF，IE，Opera和Chrome中进行过测试得出。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;F5使用缓存，并且只有在资源内容发生变化的时候才会去更新资源。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;当刷新一个页面的时候，浏览器会尝试使用各种类型的缓存，并且会发送&lt;code&gt;If-Modified-Since&lt;/code&gt;头到服务器，如果服务器返回&lt;code&gt;304 Not Modified&lt;/code&gt;，那么浏览器会使用本地的缓存；如果服务器返回&lt;code&gt;200 OK&lt;/code&gt;和资源内容，那么浏览器会使用返回的资源内容，并把资源内容进行缓存，待下次使用。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CTRL-F5 强制更新页面资源的缓存。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;MSIE会发送&lt;code&gt;Cache-Control: no-cache&lt;/code&gt;头，Firefox和Chrome除了发送&lt;code&gt;Cache-Control: no-cache&lt;/code&gt;头之外，还会发送&lt;code&gt;Pragma: no-cache&lt;/code&gt;头。Opera比较另类，不发送任何和缓存相关的头。&lt;/p&gt;

&lt;p&gt;以下表格很直观的表明了F5和CTRL-F5的行为，由于原文中测试的浏览器版本较低，所以进行了更新。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;F5 and CTRL-F5
┌────────────┬───────────────────────────────────────────────┐
│  UPDATED   │                 Firefox 3.x 4.x               │
│2011-04-24  │  ┌────────────────────────────────────────────┤
│            │  │              MSIE 7 8                      │
│            │  │  ┌─────────────────────────────────────────┤
│            │  │  │           MSIE 9                        │
│            │  │  │  ┌──────────────────────────────────────┤
│            │  │  │  │        Chrome 10                     │
│            │  │  │  │  ┌───────────────────────────────────┤
│            │  │  │  │  │     Opera 11                      │
│            │  │  │  │  │  ┌────────────────────────────────┤
│            │  │  │  │  │  │ I = &quot;If─Modified─Since&quot;        │
├────────────┼──┼──┼──┼──┼──┤ P = &quot;Pragma: No─cache&quot;         │
│          F5│IM│IM│I │IM│I │ C = &quot;Cache─Control: no─cache&quot;  │
│     CTRL─F5│CP│C │C │CP│- │ M = &quot;Cache─Control: max─age=0&quot; │
│  Click Icon│IM│I │I │IM│I │ Click Icon= &quot;a mouse click on  │
│            │  │  │  │  │  │ refresh icon&quot;                  │
└────────────┴──┴──┴──┴──┴──┴──-─────────────────────────────┘
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;HTTP协议说明&lt;/h3&gt;

&lt;p&gt;HTTP/1.1规范14.9.4中规定：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;End-to-end reload(即CTRL-F5强制刷新)会发送如下HTTP头：   &lt;br/&gt;
Cache-Control: no-cache  &lt;br/&gt;
Pragma: no-cache&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Specific end-to-end revalidation(即F5 刷新)会发送如下HTTP头：   &lt;br/&gt;
Cache-Control: max-age=0  &lt;br/&gt;
If-Modified-Since: Fri, 15 Apr 2011 12:08:21 GMT&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;参考：&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/385367/what-requests-do-browsers-f5-and-ctrl-f5-refreshes-generate&quot;&gt;http://stackoverflow.com/questions/385367/what-requests-do-browsers-f5-and-ctrl-f5-refreshes-generate&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>利用Proxy Cache使Nginx对静态资源进行缓存</title>
   <link href="http://weizhifeng.net/nginx-proxy-cache.html"/>
   <updated>2011-04-17T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/nginx-proxy-cache</id>
   <content type="html">&lt;h3&gt;前言&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://nginx.org/&quot; title=&quot;Nginx&quot;&gt;Nginx&lt;/a&gt;是高性能的HTTP服务器，通过&lt;a href=&quot;http://wiki.nginx.org/HttpProxyModule#proxy_cache&quot; title=&quot;proxy_cache&quot;&gt;Proxy Cache&lt;/a&gt;可以使其对静态资源进行缓存。其原理就是把静态资源按照一定的规则存在本地硬盘，并且会在内存中缓存常用的资源，从而加快静态资源的响应。&lt;/p&gt;

&lt;h3&gt;配置Proxy Cache&lt;/h3&gt;

&lt;p&gt;以下为nginx配置片段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;proxy_temp_path   /usr/local/nginx/proxy_temp_dir 1 2;

#keys_zone=cache1:100m 表示这个zone名称为cache1，分配的内存大小为100MB
#/usr/local/nginx/proxy_cache_dir/cache1 表示cache1这个zone的文件要存放的目录
#levels=1:2 表示缓存目录的第一级目录是1个字符，第二级目录是2个字符，即/usr/local/nginx/proxy_cache_dir/cache1/a/1b这种形式
#inactive=1d 表示这个zone中的缓存文件如果在1天内都没有被访问，那么文件会被cache manager进程删除掉
#max_size=10g 表示这个zone的硬盘容量为10GB

proxy_cache_path  /usr/local/nginx/proxy_cache_dir/cache1  levels=1:2 keys_zone=cache1:100m inactive=1d max_size=10g;

server {
    listen 80;
    server_name *.example.com;

    #在日志格式中加入$upstream_cache_status
    log_format format1 '$remote_addr - $remote_user [$time_local]  '
        '&quot;$request&quot; $status $body_bytes_sent '
        '&quot;$http_referer&quot; &quot;$http_user_agent&quot; $upstream_cache_status';

    access_log log/access.log fomat1;

    #$upstream_cache_status表示资源缓存的状态，有HIT MISS EXPIRED三种状态
    add_header X-Cache $upstream_cache_status;
    location ~ .(jpg|png|gif|css|js)$ {
        proxy_pass http://127.0.0.1:81;

        #设置资源缓存的zone
        proxy_cache cache1;

        #设置缓存的key
        proxy_cache_key $host$uri$is_args$args;

        #设置状态码为200和304的响应可以进行缓存，并且缓存时间为10分钟
        proxy_cache_valid 200 304 10m;

        expires 30d;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;安装Purge模块&lt;/h3&gt;

&lt;p&gt;Purge模块被用来清除缓存&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wget http://labs.frickle.com/files/ngx_cache_purge-1.2.tar.gz
$ tar -zxvf ngx_cache_purge-1.2.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看编译参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ /usr/local/nginx/sbin/nginx -V 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在原有的编译参数后面加上&lt;code&gt;--add-module=/usr/local/ngx_cache_purge-1.2&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./configure --user=www --group=www --prefix=/usr/local/nginx \
--with-http_stub_status_module --with-http_ssl_module \
--with-http_realip_module --add-module=/usr/local/ngx_cache_purge-1.2
$ make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;退出nginx，并重新启动&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ /usr/local/nginx/sbin/nginx -s quit
$ /usr/local/nginx/sbin/nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;配置Purge&lt;/h3&gt;

&lt;p&gt;以下是nginx中的Purge配置片段&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;location ~ /purge(/.*) {
    #允许的IP
    allow 127.0.0.1;
    deny all;
    proxy_cache_purge cache1 $host$1$is_args$args;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;清除缓存&lt;/h3&gt;

&lt;p&gt;使用方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wget http://example.com/purge/uri
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;uri&lt;/code&gt;为静态资源的URI，如果缓存的资源的URL为
&lt;code&gt;http://example.com/js/jquery.js&lt;/code&gt;，那么访问
&lt;code&gt;http://example.com/purge/js/jquery.js&lt;/code&gt;则会清除缓存。&lt;/p&gt;

&lt;h3&gt;命中率&lt;/h3&gt;

&lt;p&gt;保存如下代码为hit_rate.sh：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
# author: Jeremy Wei &amp;lt;shuimuqingshu@gmail.com&amp;gt;
# proxy_cache hit rate

if [ $1x != x ] then
    if [ -e $1 ] then
        HIT=`cat $1 | grep HIT | wc -l`
        ALL=`cat $1 | wc -l`
        Hit_rate=`echo &quot;scale=2;($HIT/$ALL)*100&quot; | bc`
        echo &quot;Hit rate=$Hit_rate%&quot;
    else
        echo &quot;$1 not exsist!&quot;
    fi
else
    echo &quot;usage: ./hit_rate.sh file_path&quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用方式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./hit_rate.sh /usr/local/nginx/log/access.log
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;参考：&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://wiki.nginx.org/HttpProxyModule&quot;&gt;http://wiki.nginx.org/HttpProxyModule&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Keepalived配置与使用</title>
   <link href="http://weizhifeng.net/using-keepalived.html"/>
   <updated>2011-04-03T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/using-keepalived</id>
   <content type="html">&lt;h3&gt;介绍&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.keepalived.org/&quot; title=&quot;Keepalived&quot;&gt;Keepalived&lt;/a&gt;是一个基于VRRP协议来实现的WEB服务高可用方案，可以利用其来避免单点故障。一个WEB服务至少会有2台服务器运行Keepalived，一台为主服务器（MASTER），一台为备份服务器（BACKUP），但是对外表现为一个虚拟IP，主服务器会发送特定的消息给备份服务器，当备份服务器收不到这个消息的时候，即主服务器宕机的时候，备份服务器就会接管虚拟IP，继续提供服务，从而保证了高可用性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    +---------VIP(192.168.0.7)----------+
    |                                   |
    |                                   |
server(MASTER) &amp;lt;----keepalived----&amp;gt; server(BACKUP)
(192.168.0.1)                       (192.168.0.2)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;VRRP&lt;/h3&gt;

&lt;p&gt;在&lt;a href=&quot;http://en.wikipedia.org/wiki/Virtual_Router_Redundancy_Protocol&quot; title=&quot;Virtual Router Redundancy Protocol&quot;&gt;VRRP&lt;/a&gt;协议中，有两组重要的概念：VRRP路由器和虚拟路由器，主控路由器和备份路由器。 VRRP路由器是指运行VRRP的路由器，是物理实体，虚拟路由器是指VRRP协议创建的，是逻辑概念。一组VRRP路由器协同工作，共同构成一台虚拟路由器。该虚拟路由器对外表现为一个具有唯一固定IP地址和MAC地址的逻辑路由器。处于同一个VRRP组中的路由器具有两种互斥的角色：主控路由器和备份路由器，一个VRRP组中有且只有一台处于主控角色的路由器，可以有一个或者多个处于备份角色的路由器。VRRP协议使用选择策略从路由器组中选出一台作为主控，负责ARP相应和转发IP数据包，组中的其它路由器作为备份的角色处于待命状态。当由于某种原因主控路由器发生故障时，备份路由器能在几秒钟的时延后升级为主路由器。由于此切换非常迅速而且不用改变IP地址和MAC地址，故对终端使用者系统是透明的。&lt;/p&gt;

&lt;h3&gt;安装&lt;/h3&gt;

&lt;p&gt;编译安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wget http://www.keepalived.org/software/keepalived-1.2.2.tar.gz&amp;lt;/a&amp;gt;
$ tar -zxvf keepalived-1.2.2.tar.gz
$ cd keepalived-1.2.2
$ ./configure --prefix=/usr/local/keepalived
$ make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;拷贝需要的文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cp /usr/local/keepalived/etc/rc.d/init.d/keepalived /etc/init.d/keepalived
$ cp /usr/local/keepalived/sbin/keepalived /usr/sbin/
$ cp /usr/local/keepalived/etc/sysconfig/keepalived /etc/sysconfig/
$ mkdir -p /etc/keepalived/
$ cp /usr/local/etc/keepalived/keepalived.conf /etc/keepalived/keepalived.conf 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/etc/keepalived/keepalived.conf&lt;/code&gt;是默认配置文件&lt;/p&gt;

&lt;h3&gt;配置&lt;/h3&gt;

&lt;p&gt;master:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;global_defs {
   notification_email {
      user@example.com
   }

   notification_email_from mail@example.org
   smtp_server 192.168.200.1
   smtp_connect_timeout 30
   router_id LVS_DEVEL
}

vrrp_instance VI_1 {
    state MASTER #标示状态为MASTER
    interface eth0
    virtual_router_id 51
    priority 101   #MASTER权重要高于BACKUP
    advert_int 1
    mcast_src_ip 192.168.2.115 #vrrp实体服务器的IP

    authentication {
        auth_type PASS #主从服务器验证方式
        auth_pass 1111
    }

    #VIP
    virtual_ipaddress {
        192.168.2.233 #虚拟IP
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;backup:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;global_defs {
   notification_email {
       user@example.com
   }

   notification_email_from mail@example.org
   smtp_server 192.168.200.1
   smtp_connect_timeout 30
   router_id LVS_DEVEL
}

vrrp_instance VI_1 {

    state BACKUP #状态为BACKUP
    interface eth0
    virtual_router_id 51
    priority 100  #权重要低于MASTER
    advert_int 1
    mcast_src_ip 192.168.2.227 #vrrp实体服务器的IP

    authentication {
        auth_type PASS
        auth_pass 1111
    }

    #VIP
    virtual_ipaddress {
        192.168.2.233 #虚拟IP
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;使用&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ /etc/init.d/keepalived start | restart | stop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当启动了keepalived之后，通过&lt;code&gt;ifconfig&lt;/code&gt;是看不到VIP的，但是通过&lt;code&gt;ip a&lt;/code&gt;命令是可以看到的。 当MASTER宕机，BACKUP升级为MASTER，这些VRRP_Instance状态的切换都可以在&lt;code&gt;/var/log/message&lt;/code&gt;中进行记录。&lt;/p&gt;

&lt;h3&gt;参考：&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.keepalived.org/&quot;&gt;http://www.keepalived.org/&lt;/a&gt;   &lt;br/&gt;
&lt;a href=&quot;http://www.chinaunix.net/jh/30/284898.html&quot;&gt;http://www.chinaunix.net/jh/30/284898.html&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Linux下查看内存,CPU信息</title>
   <link href="http://weizhifeng.net/view-cpu-memory-info-of-linux.html"/>
   <updated>2011-03-26T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/view-cpu-memory-info-of-linux</id>
   <content type="html">&lt;h3&gt;内存信息&lt;/h3&gt;

&lt;p&gt;使用&lt;a href=&quot;http://linux.die.net/man/1/free&quot; title=&quot;free&quot;&gt;free&lt;/a&gt;查看内存信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ free -m
                total       used       free     shared    buffers     cached
Mem:              222         136         86          0         29       60
-/+ buffers/cache:             47        175
Swap:             1905          0       1905
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;total：总共的内存大小&lt;/li&gt;
&lt;li&gt;used：已经被使用的内存&lt;/li&gt;
&lt;li&gt;free：空闲的内存&lt;/li&gt;
&lt;li&gt;shared：共享的内存大小&lt;/li&gt;
&lt;li&gt;buffers：用来做缓冲的内存&lt;/li&gt;
&lt;li&gt;cached：用来做cache的内存&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;Mem&lt;/strong&gt;这行是以操作系统的角度去看待内存的使用，可以看到我们总共的内存是222M(total1)，使用了136M(used1)，有86M的空闲(free1)，29M的缓冲(buffers1)，60M的缓存(cached1)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;-/+ buffers/cache&lt;/strong&gt;这行是以应用程序的角度去看待内存的使用，对于应用来说&lt;strong&gt;buffers&lt;/strong&gt;和&lt;strong&gt;cached&lt;/strong&gt;的内存是就是空闲的内存，在需要的时候是 可以直接拿来用的，所以：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;used = used1 – buffers1 – shared1 = 136 – 29 – 60 = 47，
free = free1 + buffers1 + shared1 = 86 + 29 + 60 = 175。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Swap&lt;/strong&gt;这行是交换区的使用情况，如果used很大的话，说明内存不够用了。&lt;/p&gt;

&lt;p&gt;PS:跑的虚拟机，内存有些小，见笑~~~&lt;/p&gt;

&lt;h3&gt;CPU信息&lt;/h3&gt;

&lt;p&gt;Linux系统中的CPU信息存在于&lt;code&gt;/proc/cpuinfo&lt;/code&gt;文件中，如果想了解全部的信息，可以直接查看这个文件。&lt;/p&gt;

&lt;p&gt;有多少个物理CPU？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat /proc/cpuinfo | grep 'physical id' | sort | uniq |wc -l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有多少个虚拟CPU？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat /proc/cpuinfo | grep ^processor | sort | uniq |wc -l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CPU是几个核心的？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat /proc/cpuinfo | grep 'cpu cores' | uniq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如何查看每个CPU的使用情况？执行&lt;a href=&quot;http://linux.die.net/man/1/top&quot; title=&quot;top&quot;&gt;top&lt;/a&gt;指令，然后按1就可以看到CPU的使用情况了。&lt;/p&gt;

&lt;h3&gt;参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.php-oa.com/2008/04/04/linux-free.html&quot;&gt;http://www.php-oa.com/2008/04/04/linux-free.html&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Samba配置与使用</title>
   <link href="http://weizhifeng.net/using-samba.html"/>
   <updated>2011-03-26T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/using-samba</id>
   <content type="html">&lt;h3&gt;介绍&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.samba.org/&quot; title=&quot;samba&quot;&gt;Samba&lt;/a&gt;可以让我们在windows中访问linux系统中的文件，如果用来调试linux虚拟机中的代码会非常的方便。&lt;/p&gt;

&lt;h3&gt;安装&lt;/h3&gt;

&lt;p&gt;以下是CentOS中Samba的安装方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum install samba
/etc/init.d/samba start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加用户到Samba中,这个用户就可以用来访问Samba中的文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;groupadd sambagroup
useradd -g sambagroup sambauser1
passwd sambauser1 #shell 登录用
smbpasswd -a sambauser1 #samba登录用
smbpasswd sambauser1   #修改samba用户sambauser1的密码
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;配置&lt;/h3&gt;

&lt;p&gt;Samba配置文件为&lt;code&gt;/etc/samba/smb.conf&lt;/code&gt;用户验证访问模式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[global]
workgroup = Ubuntu
netbios name = UbuntuServer
server string = Linux Samba Server TestServer
security = user
encrypt passwords = yes
smb passwd file = /etc/samba/smbpasswd
display charset = cp936
unix charset = cp936
dos  charset = cp936

[noshare]
path = /home/sambauser1
writeable = yes   
browseable = yes
create mask =  0664
directory mask = 0775
valid users = sambauser1 #允许访问的用户，多个以','分割
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;匿名访问方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[global]
workgroup = Ubuntu
netbios name = UbuntuServer
server string = Linux Samba Server TestServer
security = share
display charset = cp936
unix charset = cp936
dos  charset = cp936

[share]
path = /share/smb
writeable = yes
browseable = yes
create mask =  0664
directory mask = 0775
guest ok = yes #允许匿名访问
public = yes
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;问题&lt;/h3&gt;

&lt;p&gt;最近在配置samba，windows连接的时候出现如下问题：&lt;strong&gt;samba不允许一个用户使用一个以上用户名与一个服务器或共享资源的多重连接&lt;/strong&gt;，google查询后，找到解决方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;net use * /del /y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 事实上这个不是samba的限制，是Windows的限制。始终要用public＝yes的话，上面的方法都不能有效解决，因为：在打开存在public＝yes的samba服务器时，如果首先点击了有public＝yes的共享资源的时候，widows会用默认的用户名去连接服务器，一般就是windows的登录名（可以在服务器端查看到的），这时候，再去点击没有public＝yes的共享资源，由于使用了user级别，服务器就会要求验证，这时，之前的默认登录已经存在，就出现了楼主的故障了。即使注销连接后如果没有采用正确的顺序访问共享资源，还是会陷入这个泥潭中。因此，最好办法就是不用public＝yes，给公共帐号建立一个共用的账户并公示出来。这样处理，其实权限更清晰一些。&lt;/p&gt;

&lt;h3&gt;Selinux&lt;/h3&gt;

&lt;p&gt;在配置好samba后，有时候还会出现无法访问的情况，这种情况下需要关闭Selinux：&lt;/p&gt;

&lt;p&gt;修改 &lt;code&gt;/etc/selinux/config&lt;/code&gt; 修改 &lt;code&gt;SELINUX=enforcing&lt;/code&gt; 为 &lt;code&gt;SELINUX=disabled&lt;/code&gt;，然后重启服务器。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.linuxsir.org/main/?q=node/158&quot;&gt;http://www.linuxsir.org/main/?q=node/158&lt;/a&gt;   &lt;br/&gt;
&lt;a href=&quot;http://blogold.chinaunix.net/u/19637/showart_491257.html&quot;&gt;http://blogold.chinaunix.net/u/19637/showart_491257.html&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Memcachedb的安装与使用</title>
   <link href="http://weizhifeng.net/using-memcachedb.html"/>
   <updated>2011-03-26T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/using-memcachedb</id>
   <content type="html">&lt;h3&gt;前言&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.danga.com/memcached/&quot; title=&quot;Memcached&quot;&gt;Memcached&lt;/a&gt;想必大家都知道,是一个缓存服务器,数据直接存在内存中，如果重启memcached进程或者重启服务器，数据就都消失了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://memcachedb.org/&quot; title=&quot;Memcachedb&quot;&gt;Memcachedb&lt;/a&gt;是一个Memcached的改进版，Memcachedb把数据存在&lt;a href=&quot;http://www.oracle.com/database/berkeley-db/db/index.html&quot; title=&quot;berkeley db&quot;&gt;Berkeley DB&lt;/a&gt;中，这样就可以使数据持久化，应用在其他的领域，&lt;a href=&quot;http://stvchu.org/&quot; title=&quot;stvchu&quot;&gt;开发者&lt;/a&gt;来自&lt;a href=&quot;http://sina.com&quot; title=&quot;SINA&quot;&gt;SINA&lt;/a&gt;。本文介绍下Memcachedb的安装以及使用。&lt;/p&gt;

&lt;h3&gt;安装&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装Berkeley DB&lt;/p&gt;

&lt;p&gt;版本：Berkeley DB 4.7 or later&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $ wget http://download.oracle.com/berkeley-db/db-4.7.25.tar.gz
 $ tar -xvzf db-4.7.25.tar.gz
 $ cd db-4.7.25/
 $ cd build_unix/
 $ ../dist/configure 或者--prefix=你的路径
 $ make
 $ sudo make install
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装libevent&lt;/p&gt;

&lt;p&gt;版本：libevent 1.3e or later（最好用1.3e）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $ wget http://monkey.org/~provos/libevent-1.3e.tar.gz
 $ tar -xvzf libevent-1.3e.tar.gz
 $ cd libevent-1.3e
 $ ./configure 或者--prefix=你要安装的路径
 $ make
 $ sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 修改/etc/ld.so.conf文件，添加下面两行:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; /usr/local/lib #这个是libevent的路径
 /usr/local/BerkeleyDB.4.7/lib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 然后执行ldconfig&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装memcachedb&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $ tar xvzf memcachedb-X.Y.Z.tar.gz
 $ cd memcachedb-X.Y.Z
 $ ./configure --enable-threads #-h有很多帮助
 $ make
 $ sudo make install
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;使用&lt;/h3&gt;

&lt;p&gt;如下命令进行启动：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ /usr/local/memcachedb/bin/memcachedb -p 21201 -d -r -u \
root -f /data1/21201.db -H /data1/demo -N -P /data1 /logs/21201.pid
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://memcachedb.googlecode.com/svn/trunk/INSTALL&quot;&gt;http://memcachedb.googlecode.com/svn/trunk/INSTALL&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>HAProxy配置</title>
   <link href="http://weizhifeng.net/using-haproxy.html"/>
   <updated>2011-03-26T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/using-haproxy</id>
   <content type="html">&lt;h3&gt;前言&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://haproxy.1wt.eu/&quot;&gt;Haproxy&lt;/a&gt;是一个负载均衡服务器，能够提供4层，7层代理，并能支持上万级别的连接，你可以直接在WEB服务器前端加上它，而不影响应用的访问，完全透明。&lt;/p&gt;

&lt;h3&gt;安装&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ wget http://haproxy.1wt.eu/download/1.4/src/haproxy-1.4.8.tar.gz
$ tar -zxvf haproxy-1.4.8.tar.gz
$ cd haproxy-1.4.8
$ ./configure --prefix=/path/to/haproxy
$ make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;配置&lt;/h3&gt;

&lt;p&gt;首先要添加haproxy:haproxy用户：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ groupadd haproxy
$ useradd -g haproxy haproxy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看uid和gid&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo cat /etc/passwd |grep haproxy 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑haproxy.cfg，添加如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;global
    log 127.0.0.1   local3
    maxconn 4096            #最大连接数
    chroot /path/to/haproxy #安装目录
    uid 535  #用户haproxy
    gid 520  #组haproxy
    daemon   #守护进程运行
    nbproc 1 #进程数量
    pidfile logs/haproxy.pid

defaults

   log     127.0.0.1       local3
   mode    http       #layer 7代理
   option  httplog
   option  httpclose
   option  dontlognull
   option  forwardfor
   retries 2
   maxconn 2000
   balance roundrobin
   stats   uri     /haproxy-stats
   contimeout      5000
   clitimeout      50000
   srvtimeout      50000

frontend http-in

    bind *:80 #监听地址
    default_backend pool1

backend pool1

    option  httpchk GET /test.php #用来做健康检查
    stats refresh 2
    server server1 192.168.1.1:82 weight 3 maxconn 32 check #check表示对这个server进行健康检查
    server server2 192.168.1.2:82 weight 3 maxconn 32 check
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看后端server状态： http://example.com/haproxy-stats&lt;/p&gt;

&lt;p&gt;启动&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo ./sbin/haproxy -f haproxy.cfg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo ./sbin/haproxy -f haproxy.cfg -st `cat logs/haproxy.pid`
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;日志问题&lt;/h3&gt;

&lt;p&gt;有童鞋说日志怎么也写不进去，我也遇到了这个问题，在这里分享下。 编辑&lt;code&gt;/etc/syslog.conf&lt;/code&gt;文件，添加：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;local3.*    /var/log/haproxy.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑&lt;code&gt;/etc/sysconfig/syslog&lt;/code&gt;文件，把&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SYSLOGD_OPTIONS=&quot;-m 0&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SYSLOGD_OPTIONS=&quot;-r -m 0&quot; #enables logging from remote machines
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启syslogd:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/etc/init.d/syslog restart 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过&lt;code&gt;tail&lt;/code&gt;应该可以看到日志输出了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tail -f -n 30 /var/log/haproxy.log 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;参考：&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.chenlb.com/2009/06/install-haproxy-and-configure-load-balance.html&quot;&gt;http://blog.chenlb.com/2009/06/install-haproxy-and-configure-load-balance.html&lt;/a&gt;  &lt;br/&gt;
&lt;a href=&quot;http://haproxy.1wt.eu/download/1.4/doc/configuration.txt&quot;&gt;http://haproxy.1wt.eu/download/1.4/doc/configuration.txt&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>域名详解</title>
   <link href="http://weizhifeng.net/talking-about-domain.html"/>
   <updated>2011-03-26T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/talking-about-domain</id>
   <content type="html">&lt;h3&gt;域名&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Domain_name&quot;&gt;域名&lt;/a&gt;就是用来唯一标示互联网上的服务器的，当我们访问一个网站时候，比如http://www.example.com/index.html，其中的&lt;code&gt;com&lt;/code&gt;，&lt;code&gt;example.com&lt;/code&gt;，&lt;code&gt;www.example.com&lt;/code&gt;都是域名。域名不区分大小写，即&lt;code&gt;www.example.com&lt;/code&gt;与&lt;code&gt;WWW.EXAMPLE.COM&lt;/code&gt;一样。&lt;/p&gt;

&lt;h3&gt;FQDN&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/FQDN&quot; title=&quot;Fully qualified domain name&quot;&gt;FQDN&lt;/a&gt;(Fully qualified domain name)即全域名，大多数指的是一个绝对域名，这个域名指明了其在DNS树级结构中的准确位置。它也指明了其中所有域的层 级，包括顶级域和根域。&lt;code&gt;www.example.com.&lt;/code&gt;就是一个FQDN。 DNS resolver一般是按照FQDN的格式来解析一个域名的，如果被解析的域名 中不存在&lt;code&gt;.&lt;/code&gt;，则DNS resolver会自动为其加上&lt;code&gt;.&lt;/code&gt;。&lt;/p&gt;

&lt;h3&gt;域名的等级&lt;/h3&gt;

&lt;p&gt;域名分为&lt;a href=&quot;http://en.wikipedia.org/wiki/TLD&quot; title=&quot;Top Level Domain&quot;&gt;顶级域名&lt;/a&gt;(Top Level Domain, TLD)，二级域名，三级域名等等。以&lt;code&gt;www.example.com&lt;/code&gt;为例，其中&lt;code&gt;com&lt;/code&gt;为顶级域名，&lt;code&gt;example&lt;/code&gt;为&lt;code&gt;com&lt;/code&gt;下的子域名，&lt;code&gt;www&lt;/code&gt;是&lt;code&gt;example.com&lt;/code&gt;下的子域名，这是一个树形的结构，最多可以有127个层 级。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;com
  |--example
      |-- www
           .
           .
           .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;com&lt;/code&gt;顶级域名，&lt;code&gt;example.com&lt;/code&gt;为二级域名，&lt;code&gt;www.example.com&lt;/code&gt;为三级域名，并且指明这个域名是一个WWW(World-Wide Web)服务器的主机名。&lt;/p&gt;

&lt;h3&gt;hostname&lt;/h3&gt;

&lt;p&gt;hostname就是一个域名，但是这个域名要有IP指向。例如www.example.com和example.com都是hostname，但是com不是一个hostname。&lt;/p&gt;

&lt;h3&gt;根域名&lt;/h3&gt;

&lt;p&gt;DNS系统是一个树状的层级结构，树根是&lt;a href=&quot;http://en.wikipedia.org/wiki/DNS_root_zone&quot; title=&quot;root domain&quot;&gt;根域&lt;/a&gt;(root domian)。根域没有名字，在&lt;a href=&quot;http://en.wikipedia.org/wiki/Domain_Name_System&quot;&gt;DNS&lt;/a&gt;系统中就用一个空字符串来表示。互联网上所有的FQDN都可以看成是以 根域来结尾，所以都是以分隔符&lt;code&gt;.&lt;/code&gt;来结束的，例如&lt;code&gt;www.example.com.&lt;/code&gt;。现在的DNS系统都不会要求域名以&lt;code&gt;.&lt;/code&gt;来结束，即&lt;code&gt;www.example.com&lt;/code&gt;就可以解析 了，但是现在很多DNS解析服务商还是会要求在填写DNS记录的时候以&lt;code&gt;.&lt;/code&gt;来结尾域名。&lt;/p&gt;

&lt;p&gt;全球共有13组根域名服务器，名字是&lt;code&gt;[a-z].root-servers.net&lt;/code&gt;。10组在美国，其中的一些已经采用&lt;a href=&quot;http://en.wikipedia.org/wiki/Anycast&quot;&gt;Anycast&lt;/a&gt;技术进行部署，剩下三组分为位于瑞典斯德哥尔摩(i)，荷兰 阿姆斯特丹(k)，日本东京(m)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root domain
  |-- com
       |-- example.com
              |-- www.example.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;顶级域名&lt;/h3&gt;

&lt;p&gt;当1980年DNS系统被创建的时候，域名空间被分成了两个部分，一部分是二个字母表示的国家域名和&lt;strong&gt;gov&lt;/strong&gt;，&lt;strong&gt;edu&lt;/strong&gt;，&lt;strong&gt;com&lt;/strong&gt;，&lt;strong&gt;mil&lt;/strong&gt;，&lt;strong&gt;org&lt;/strong&gt;，&lt;strong&gt;net&lt;/strong&gt;，&lt;strong&gt;int&lt;/strong&gt;七个组织用域名。 更多的顶级域名见：&lt;a href=&quot;http://www.iana.org/domains/root/db/&quot;&gt;http://www.iana.org/domains/root/db/&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;域名解析流程&lt;/h3&gt;

&lt;p&gt;以www.example.com为例，如果要解析这个域名，首先客户端要对根域名服务 器发起DNS查询请求，然后根域名服务器返回com顶级域名的IP地址，然后客户 端向com顶级域名服务器发起查询请求，com顶级域名服务器返回example.com 二级域名服务器的IP地址，客户端再向example.com域名服务器发起查询请求， example.com域名服务器返回www.example.com的IP地址，域名解析完毕。 为了提高解析速度，ISP会在自己的服务器上缓存DNS的解析结果，防止每次都 去递归查找，这个缓存的时间是由DNS记录的TTL来决定的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload.wikimedia.org/wikipedia/commons/7/77/An_example_of_theoretical_DNS_recursion.svg&quot; title=&quot;DNS&quot; alt=&quot;DNS&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;参考：&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Domain_Name_System&quot;&gt;http://en.wikipedia.org/wiki/Domain_Name_System&lt;/a&gt;  &lt;br/&gt;
&lt;a href=&quot;http://en.wikipedia.org/wiki/Domain_name&quot;&gt;http://en.wikipedia.org/wiki/Domain_name&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>CR, LF, CR/LF区别与关系</title>
   <link href="http://weizhifeng.net/talking-about-cr-lf.html"/>
   <updated>2011-03-26T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/talking-about-cr-lf</id>
   <content type="html">&lt;h3&gt;前言&lt;/h3&gt;

&lt;p&gt;在文本处理中，&lt;a href=&quot;http://en.wikipedia.org/wiki/Carriage_return&quot;&gt;CR&lt;/a&gt;（&lt;strong&gt;C&lt;/strong&gt;arriage &lt;strong&gt;R&lt;/strong&gt;eturn），&lt;a href=&quot;http://en.wikipedia.org/wiki/Line_feed&quot;&gt;LF&lt;/a&gt;（&lt;strong&gt;L&lt;/strong&gt;ine &lt;strong&gt;F&lt;/strong&gt;eed），CR/LF是不同操作系统上使用的换行符，具体如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Dos和Windows采用回车+换行&lt;code&gt;CR/LF&lt;/code&gt;表示下一行&lt;/li&gt;
&lt;li&gt;而UNIX/Linux采用换行符&lt;code&gt;LF&lt;/code&gt;表示下一行&lt;/li&gt;
&lt;li&gt;苹果机(MAC OS系统)则采用回车符&lt;code&gt;CR&lt;/code&gt;表示下一行&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;区别&lt;/h3&gt;

&lt;p&gt;CR与LF区别如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CR用符号&lt;code&gt;\r&lt;/code&gt;表示，十进制ASCII代码是&lt;code&gt;13&lt;/code&gt;，十六进制代码为&lt;code&gt;0x0D&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;LF使用&lt;code&gt;\n&lt;/code&gt;符号表示，ASCII代码是&lt;code&gt;10&lt;/code&gt;，十六制为&lt;code&gt;0x0A&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;所以Windows平台上换行在文本文件中是使用&lt;code&gt;0d 0a&lt;/code&gt;两个字节表示，而UNIX和苹果平台上换行则是使用&lt;code&gt;0a&lt;/code&gt;或&lt;code&gt;0d&lt;/code&gt;一个字节表示。&lt;/p&gt;

&lt;h3&gt;问题&lt;/h3&gt;

&lt;p&gt;一般操作系统上的运行库会自动决定文本文件的换行格式。如一个程序在Windows上运行就生成&lt;code&gt;CR/LF&lt;/code&gt;换行格式的文本文件，而在Linux上运行就生成&lt;code&gt;LF&lt;/code&gt;格式换行的文本文件。在一个平台上使用另一种换行符的文件文件可能会带来意想不到的问题，特别是在编辑程序代码时。有时候代码在编辑器中显示正常，但在编辑时却会因为换行符问题而出错。很多文本/代码编辑器带有换行符转换功能，使用这个功能可以将文本文件中的换行符在不同格式单互换。&lt;/p&gt;

&lt;p&gt;在不同平台间使用FTP软件传送文件时，在ASCII文本模式传输模式下，一些FTP客户端程序会自动对换行格式进行转换。经过这种传输的文件字节数可能会发生变化。如果你不想FTP修改原文件，可以使用bin模式(二进制模式)传输文本。&lt;/p&gt;

&lt;h3&gt;参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Carriage_return&quot;&gt;http://en.wikipedia.org/wiki/Carriage_return&lt;/a&gt;   &lt;br/&gt;
&lt;a href=&quot;http://en.wikipedia.org/wiki/Line_feed&quot;&gt;http://en.wikipedia.org/wiki/Line_feed&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PHP中用Memcache存储Session数据</title>
   <link href="http://weizhifeng.net/store-session-in-memcache.html"/>
   <updated>2011-03-26T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/store-session-in-memcache</id>
   <content type="html">&lt;h3&gt;前言&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Session_(computer_science)&quot; title=&quot;Session&quot;&gt;Session&lt;/a&gt;是WEB程序中常用的功能，默认情况下其数据是以文件方式存储，对大访问量的场景，其处理能力较低。&lt;a href=&quot;http://memcached.org/&quot; title=&quot;Memcache&quot;&gt;Memcache&lt;/a&gt;是高性能的基于内存的Key=&gt;Value存储系统。本文将介绍如何在&lt;a href=&quot;http://www.php.net&quot; title=&quot;PHP Hypertext Preprocessor&quot;&gt;PHP&lt;/a&gt;中使用Memcache来存储Session数据。&lt;/p&gt;

&lt;h3&gt;实现&lt;/h3&gt;

&lt;p&gt;在PHP中用Memcache来存储Session数据有两种方法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果使用的是&lt;a href=&quot;http://cn.php.net/manual/en/book.memcache.php&quot; title=&quot;memcache extension&quot;&gt;memcache&lt;/a&gt;扩展    &lt;br/&gt;
在配置文件中进行设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; session.save_handler = memcache
 session.save_path = &quot;tcp://127.0.0.1:11211&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者在PHP运行时进行设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ini_set(&quot;session.save_handler&quot;,&quot;memcache&quot;);
 ini_set(&quot;session.save_path&quot;,&quot;tcp://127.0.0.1:11211&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详见：&lt;a href=&quot;http://cn.php.net/manual/en/memcache.ini.php&quot;&gt;http://cn.php.net/manual/en/memcache.ini.php&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果使用的是&lt;a href=&quot;http://cn.php.net/manual/en/book.memcached.php&quot; title=&quot;memcached extension&quot;&gt;memcached&lt;/a&gt;扩展      &lt;br/&gt;
在配置文件中进行设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; session.save_handler = memcached
 session.save_path = &quot;127.0.0.1:11211&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意这里的&lt;code&gt;session.save_path&lt;/code&gt;不需要&lt;code&gt;tcp&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;或者在PHP运行时进行设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ini_set(&quot;session.save_handler&quot;,&quot;memcached&quot;);
 ini_set(&quot;session.save_path&quot;,&quot;127.0.0.1:11211&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详见：&lt;a href=&quot;http://cn.php.net/manual/en/memcached.sessions.php&quot;&gt;http://cn.php.net/manual/en/memcached.sessions.php&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;验证&lt;/h3&gt;

&lt;p&gt;完成设置之后，可以通过&lt;a href=&quot;http://livebookmark.net/memcachephp/memcachephp.zip&quot; title=&quot;memcachephp&quot;&gt;memcachephp&lt;/a&gt;来查询session数据是否被正确设置。&lt;/p&gt;

&lt;h3&gt;参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://cn.php.net/manual/en/memcache.ini.php&quot;&gt;http://cn.php.net/manual/en/memcache.ini.php&lt;/a&gt;  &lt;br/&gt;
&lt;a href=&quot;http://cn.php.net/manual/en/memcached.sessions.php&quot;&gt;http://cn.php.net/manual/en/memcached.sessions.php&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PHP5.3+Apache2+FastCGI+PHP-FPM配置</title>
   <link href="http://weizhifeng.net/php5.3-apache2-fastcgi-php-fpm.html"/>
   <updated>2011-03-26T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/php5.3-apache2-fastcgi-php-fpm</id>
   <content type="html">&lt;h3&gt;前言&lt;/h3&gt;

&lt;p&gt;本文将利用&lt;a href=&quot;www.php.net/&quot; title=&quot;PHP Hypertext Preprocessor&quot;&gt;PHP&lt;/a&gt;，&lt;a href=&quot;http://httpd.apache.org/&quot; title=&quot;Apache&quot;&gt;Apache2&lt;/a&gt;，&lt;a href=&quot;http://php-fpm.org/&quot; title=&quot;PHP FPM&quot;&gt;PHP-FPM&lt;/a&gt;，&lt;a href=&quot;http://www.fastcgi.com/dist/mod_fastcgi-current.tar.gz&quot; title=&quot;mod_fastcgi&quot;&gt;mod_fastcgi&lt;/a&gt;构建可行的WEB运行环境。&lt;/p&gt;

&lt;h3&gt;安装apache2的&lt;a href=&quot;http://www.fastcgi.com/dist/mod_fastcgi-current.tar.gz&quot; title=&quot;mod_fastcgi&quot;&gt;mod_fastcgi&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;wget http://www.fastcgi.com/dist/mod_fastcgi-current.tar.gz
tar -zxvf mod_fastcgi-current.tar.gz
cd mod_fastcgi-2.4.6
cp Makefile.AP2 Makefile
make top_dir=/path/to/apache2
make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/path/to/apache2&lt;/code&gt;为你的Apache安装位置。&lt;/p&gt;

&lt;p&gt;编辑&lt;code&gt;httpd.conf&lt;/code&gt;增加如下配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LoadModule fastcgi_module modules/mod_fastcgi.so
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;安装autoconf2.13&lt;/h3&gt;

&lt;p&gt;必须确保已经安装了autoconf2.13，否则在执行之后的&lt;code&gt;./buildconf --force&lt;/code&gt;命令时候会出现以下错误：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Forcing buildconf using default Zend directory buildconf: 
checking installation… buildconf: autoconf version 2.59 (ok) 
buildconf: Your version of autoconf likely contains buggy cache code. 
Running cvsclean for you. To avoid this, install autoconf-2.13.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以先安装autoconf2.13：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget http://ftp.gnu.org/gnu/autoconf/autoconf-2.13.tar.gz
tar -zxvf autoconf-2.13.tar.gz
cd autoconf-2.13
./configure --prefix=/path/to/autoconf
make &amp;amp;&amp;amp; make install
export PHP_AUTOCONF=/path/to/autoconf/bin/autoconf
export PHP_AUTOHEADER=/path/to/autoconf/bin/autoheader
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;安装libevent&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;wget http://www.monkey.org/~provos/libevent-1.4.13-stable.tar.gz
tar -zxvf libevent-1.4.13-stable.tar.gz
cd libevent-1.4.13-stable/
 ./configure
make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;安装PHP&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;wget http://cn.php.net/distributions/php-5.3.2.tar.gz
tar -zxvf php-5.3.2.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给PHP打PHP-FPM的补丁：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd php-5.3.2
svn co http://svn.php.net/repository/php/php-src/branches/PHP_5_3/sapi/fpm sapi/fpm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开始编译：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ./buildconf --force
./configure --prefix=/path/to/php5.3.2/ --with-config-file-path=/path/to/php5.3.2/ \
--enable-fpm --enable-mbstring --enable-xml --enable-fastcgi
make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;启动&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;cd /path/to/php5.3.2/etc/
mv php-fpm.default.conf php-fpm.conf
/path/to/php5.3.2/sbin/php-fpm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑&lt;code&gt;php-fpm.conf&lt;/code&gt;，把下面几行前的注释符号去掉：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pm.start_servers = 10
pm.min_spare_servers = 10
pm.max_spare_servers = 20
pm.max_requests = 100
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;配置Apache&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;cd /var
mkdir fcgi-bin
cd fcgi-bin
ln -s php-cgi /path/to/php/bin/php #你的php路径，其中要注意权限问题。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果用Apache的内部的FPM(&lt;a href=&quot;http://www.fastcgi.com/dist/mod_fastcgi-current.tar.gz&quot; title=&quot;mod_fastcgi&quot;&gt;mod_fastcgi&lt;/a&gt;)，则编辑&lt;code&gt;httpd.conf&lt;/code&gt;，添加如下配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#定义目录映射
ScriptAlias /fcgi-bin/ &quot;/var/fcgi-bin/&quot; 

#配置fastcgi server
FastCgiServer /var/fcgi-bin/php-cgi -processes 10

SetHandler fastcgi-script
Options FollowSymLinks
Order allow,deny
Allow from all

#增加MIME类型
AddType application/x-httpd-php .php 

#.php结尾的请求都要用php-fastcgi来处理 
AddHandler php-fastcgi .php

#设置php-fastcgi的处理器
Action php-fastcgi /fcgi-bin/php-cgi 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果用[PHP-FPM][2]来管理&lt;a href=&quot;http://en.wikipedia.org/wiki/Common_Gateway_Interface&quot; title=&quot;CGI&quot;&gt;CGI&lt;/a&gt;的话，编辑&lt;code&gt;httpd.conf&lt;/code&gt;添加如下配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#定义目录映射
ScriptAlias /fcgi-bin/ &quot;/var/fcgi-bin/&quot; 

#配置fastcgi外部server，127.0.0.1:9000地址为php-fpm的监听地址。
FastCgiExternalServer /var/fcgi-bin/php-cgi -host 127.0.0.1:9000

SetHandler fastcgi-script
Options FollowSymLinks
Order allow,deny
Allow from all

#增加MIME类型
AddType application/x-httpd-php .php

#.php结尾的请求都要用php-fastcgi来处理  
AddHandler php-fastcgi .php         

#设置php-fastcgi的处理器
Action php-fastcgi /fcgi-bin/php-cgi 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用[PHP-FPM][2]是有很多&lt;a href=&quot;http://www.yeead.com/archives/shiyongphp-fpmlaipinghuabiangengfastcgimoshixiadephpshezhi&quot;&gt;优点&lt;/a&gt;的，比如可以平滑地重新加载&lt;code&gt;php.ini&lt;/code&gt;文件而不用重启&lt;a href=&quot;http://www.fastcgi.com/drupal/&quot; title=&quot;Fast CGI&quot;&gt;FastCGI&lt;/a&gt;进程，对于访问量大的网站来说是很重要的。&lt;/p&gt;

&lt;h3&gt;重启Apache&lt;/h3&gt;

&lt;p&gt;重启Apache，查看&lt;code&gt;phpinfo&lt;/code&gt;，如果服务器信息存在如下类似信息，那么说明安装成功：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Apache/2.2.11 (Unix) mod_fastcgi/2.4.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果出现403的错误，查看下&lt;code&gt;/var/fcgi-bin/&lt;/code&gt;是否有足够的权限。&lt;/p&gt;

&lt;p&gt;执行以下操作应该可以看见N个PHP-FPM进程在运行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ps aux|grep php
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://php-fpm.org/wiki/Documentation&quot;&gt;http://php-fpm.org/wiki/Documentation&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Pagespeed优化准则之缓存优化</title>
   <link href="http://weizhifeng.net/pagespeed-optimize-caching.html"/>
   <updated>2011-03-26T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/pagespeed-optimize-caching</id>
   <content type="html">&lt;p&gt;大多数网页中会包含很多资源，比如CSS，JavaScript，图片，这些资源一般很少有改动，所以可以缓存在浏览器。浏览器缓存可以减少HTTP的请求数量，减少请求的交互时间，减少响应的大小，减少带宽使用量。&lt;/p&gt;

&lt;h2&gt;改进浏览器缓存(Leverage browser caching)&lt;/h2&gt;

&lt;h3&gt;概述&lt;/h3&gt;

&lt;p&gt;给资源加上一个过期时间(Expire)或者生存时间(Cache-Control: max-age)可以在浏览器上缓存那些不经常变化的资源，本地访问肯定比网络访问要快。&lt;/p&gt;

&lt;h3&gt;具体&lt;/h3&gt;

&lt;p&gt;HTTP和HTTPS支持本地缓存，最新的浏览器(比如IE7,Chrome等)用heuristic的方式来决定对没有明确设置缓存header的资源缓存多长时间。对于老旧的浏览器，必须要对资源明确设置了缓存header才能缓存，并且有些浏览器无法缓存通过SSL加密传输的资源。为了兼容所有浏览器，还是需要对资源进行明确的缓存header设置，可缓存的资源包括图片，CSS，JavaScript，以及其他二进制文件(包 括多媒体文件，PDF，FLASH等)，HTML不需要进行缓存。&lt;/p&gt;

&lt;p&gt;HTTP/1.1提供以下缓存用的响应头：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Expires 和 Cache-Control: max-age&lt;/p&gt;

&lt;p&gt;如果设置了这两个header之一，被请求的资源如果没有过期，那么浏览器会直接从本地读取资源而不是去服务器上获取。Cache-Control: max-age的值是相对于资源首次被访问的时间差，单位是秒，而Expires指的是资源过期的绝对日期，如果这两个header同时存 在，Cache-Control: max-age会覆盖掉Expires。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Last-Mofidied和ETag&lt;/p&gt;

&lt;p&gt;Last-Mofidied和ETag都是用来标示资源的有效性的，Last-Mofidied的值是个日期，ETag的值是按照规则生成的字符串。如果 访问的资源已经过期，设置了Last-Mofidied的资源会在请求中加上If-Modified-Since请求头，来询问服务器这个资源是否被修改 过，如果修改过则返回新的资源，如果没有则返回304 Not Modified。同样如果被设置了ETag的资源会在请求中加上If-None-Match请求头来询问服务器这个资源的情况，如果资源被修改过则返回 新的资源，如果没有则返回304 Not Modified。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;对于网页中可以缓存的资源，Expires和Cache-Control: max-age之间需要有一个被设置，Last-Mofidied和Etag之间需要有一个被设置。这个四个header不需要都被设置，因为他们的功能用重复。&lt;/p&gt;

&lt;h3&gt;建议&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;给静态资源设置缓存头(Set caching headers aggressively for all static resources)&lt;/p&gt;

&lt;p&gt;设置Expires头的值至少一个月，最好是一年，不要超过一年，因为这个违反RFC标准。之所以选择Expires，是因为Expires比max- age的支持更加广泛。如果一个资源会发生改变，那么可以把过期时间设置的短些；如果认为一个资源会发生改变，但是又不知道什么时候，你可以设置一个比较 长的过期时间，然后可以通过URL fingerprinting来清除它。浏览器缓存不能无限设置，因为浏览器会有一个LRU算法来清除不用的缓存。设置Last-Mofidied头的 值为资源最后修改的日期。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用指纹来动态的缓存资源(Use fingerprinting to dynamically enable caching)&lt;/p&gt;

&lt;p&gt;如果有些资源可以被缓存，但是又更改的比较频繁，那么可以在URL中加入一个fingerprint，就是一个GET请求的参数，当资源改变需要清除浏览器缓存的时候，就改变fingerprint的值，让浏览器重新加载资源。这样的话这些资源可以设置很长的缓存时间。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为IE设置正确的vary头(Set the Vary header correctly for Internet Explorer)&lt;/p&gt;

&lt;p&gt;IE不会缓存设置了vary头，并且其field为Accept-Encoding和User-Agent之外其他field的资源。所以要确保设置了正确的vary头。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;避免Firefox中URL引起的缓存冲突(Avoid URLs that cause cache collisions in Firefox)&lt;/p&gt;

&lt;p&gt;在Firefox中，其缓存hash算法存在问题，如果两个URL非常相近，差别不超过8个字符的话，那么它们的hash key是一样的，所以如果使用了fingerprint方式来清除缓存，那么请保证前后fingerprint的字符长度差别最少为9个字符。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在Firefox中利用Cache control: public 来使HTTPS的缓存生效(Use the Cache control: public directive to enable HTTPS caching for Firefox)&lt;/p&gt;

&lt;p&gt;一些版本的Firefox需要在设置了普通缓存头的基础上，设置Cache-Control：public才能缓存HTTPS的资源。这个头是用来在代理服务器上缓存资源用的，但是即使设置了，代理服务器也无法缓存HTTPS的资源，所以这个调整是安全的。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;改进代理缓存(Leverage proxy caching)&lt;/h2&gt;

&lt;h3&gt;概述&lt;/h3&gt;

&lt;p&gt;对静态资源使用public缓存，让浏览器从更近的代理服务器访问资源，而不是从原始服务器访问。&lt;/p&gt;

&lt;h3&gt;具体&lt;/h3&gt;

&lt;p&gt;HTTP除了提供浏览器缓存，还提供了代理服务器缓存机制，静态资源可以被缓存在代理服务器上，一般是ISP的服务器。即使一个用户首次访问你的网站，但 是很有可能他的资源是来自代理服务器上的缓存。使用代理缓存的益处是可以降低延迟和节省带宽。你可以通过设置Cache-control: public头来使用代理缓存。&lt;/p&gt;

&lt;h3&gt;建议&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;不要在静态资源中包含查询字串(Don’t include a query string in the URL for static resources)&lt;/p&gt;

&lt;p&gt;大多数的代理服务器，特别明显的是squid(版本最高到3.0)，不会缓存URL中带有?的资源，即使设置了Cache-control: public，所以如果希望代理缓存服务器缓存静态资源，请把URL中的查询字串去掉，或者把这些查询参数编码，然后加在文件名中 。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不要对设置cookie的资源开启代理缓存(Don’t enable proxy caching for resources that set cookies)&lt;/p&gt;

&lt;p&gt;设置Cache-control: public可以在不同的用户之间共享资源，但是也共享了这个资源携带的cookie。尽管大多数的代理服务器不会缓存携带cookie的资源，但是还是 应该尽可能的避免这种情况的发生。有两种方式可以选择：对携带cookie的资源设置Cache-control: private或者使用一个独立的新域名(cookieless domain)。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注意JS和CSS文件的代理缓存问题(Be aware of issues with proxy caching of JS and CSS files)&lt;/p&gt;

&lt;p&gt;一些代理服务器不能检测到响应头中的Content-Encoding，可能会把gzip压缩过的文件发送给不支持gzip解压的浏览器，有两种方式可以 解决这个问题： 给资源设置Cache-control: private头，这样资源不会被代理服务器缓存；给资源设置Vary: Accept-Encoding头，这样代理服务器会缓存两份资源，一份为压缩过的，一份为没有压缩的，代理服务器可以根据请求头的Accept- Encoding来判断是返回哪一个资源。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;原文：&lt;a href=&quot;http://code.google.com/speed/page-speed/docs/caching.html&quot;&gt;http://code.google.com/speed/page-speed/docs/caching.html&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Pagespeed优化准则之减少请求开销</title>
   <link href="http://weizhifeng.net/pagespeed-minimize-request-overhead.html"/>
   <updated>2011-03-26T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/pagespeed-minimize-request-overhead</id>
   <content type="html">&lt;p&gt;当客户端发送一个HTTP请求的时候，给这个域名和path设置的cookie也会随同一次发送。大多数用户的网络带宽是不对称的，上传和下载之间 的比例是1:4到1:20之间。这就是说发送一个500B的HTTP头和下载一个10KB的HTTP响应花费的时间是一样的。有的时候情况会更糟，因为 HTTP头是没有经过压缩的。在一个新的浏览器会话开始的时候，这个延迟会更大。为了避免网络拥堵，TCP会使用slow start的算法来创建新的连接。浏览器在发送新数据之前需要等待服务器返回对已经发送数据的ACK响应，这就限制了数据的发送量。如果需要发送的数据超过了一个连接一次能发送的最大量，那么数据就会分批发送，从而增加了浏览器和服务器之间交互的时间，即RTT。缩短请求时间的方法是减少请求的字节数，比如说HTTP头。&lt;/p&gt;

&lt;h2&gt;最小化请求大小(Minimize request size)&lt;/h2&gt;

&lt;h3&gt;概述&lt;/h3&gt;

&lt;p&gt;尽可能保持cookie和请求头要小，确保一个HTTP请求可以通过一个TCP包传输完成。&lt;/p&gt;

&lt;h3&gt;详细&lt;/h3&gt;

&lt;p&gt;理想情况下，一个HTTP请求不会用超过1个packet来传输。大多数使用范围很广的网络会限制一个packet最多能传输1500个字节；所以，如果可以把每个请求限制在1500个字节之内，那么就减少请求的开销。&lt;/p&gt;

&lt;p&gt;HTTP请求头包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Cookie: 对于需要cookie的资源，要保证cookie最小。为了使HTTP请求的数据少，对于一个域名不允许设置大于1000个字节的cookie，推荐所有cookie的平均大小小于400个字节。&lt;/li&gt;
&lt;li&gt;浏览器设置的头：有些HTTP头是浏览器自动设置的，这个无法控制。&lt;/li&gt;
&lt;li&gt;请求资源的URL(GET和Host字段)：拥有太多参数的URL会造成很大的请求数据量，请精简URL。&lt;/li&gt;
&lt;li&gt;Referrer URL&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;建议&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;用服务端存储来节省cookie带来的负载 (Use server-side storage for most of the cookie payload.)
在cookie里存储一个唯一的标识符，然后用这个ID和服务器端的数据进行关联，一些需要存在cookie里的内容，可以在服务器端找到，从而减小了cookie的大小。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;删除无用或者重复的cookie字段 (Remove unused or duplicated cookie fields)
如果cookie被设置在一个域名的顶级路径下，比如”/”，那么这个域名下所有路径都会继承这个cookie。如果想要在不同的路径中使用同一个 cookie，那么可以在顶级路径下面设置这个cookie，不需要在子路径下设置重复的cookie。如果只需要在子路径中使用一个cookie，那么 不要在顶级路径中设置这个cookie，因为这样会导致cookie会发送到不需要此cookie的路径中，造成不必要的流量。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;使用cookie无关的域名来传输静态内容 (Serve static content from a cookieless domain)&lt;/h2&gt;

&lt;h3&gt;概述&lt;/h3&gt;

&lt;p&gt;使用一个cookie无关的域名来传输静态资源，可以减少页面总体的流量。&lt;/p&gt;

&lt;h3&gt;详细&lt;/h3&gt;

&lt;p&gt;静态的内容，例如图片，JS，CSS等，不需要传递cookie，因为没有用户会与这些资源进行交互。可以使用cookie无关的域名来传输静态资源，这 样可以降低请求的延迟。这个技术对于其中包含大量很难被缓存的内容的页面特别有效，比如经常修改的缩略图或者不经常被访问的图片。对于页面中包含超过5个静态资源的页面推荐使用这种技术，如果少于5个，那么不值得这么做。如果想使用cookie无关的域名来传输静态资源，需要注册一个域名，然后添加 CNAME记录，并指向到已经存在的A记录上。调整程序，使所有的静态资源都通过cookie无关的域名进行传输。&lt;/p&gt;

&lt;h3&gt;建议&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;开启代理缓存 (Enable proxy caching)
对于很难改变的内容，设置浏览器和代理缓存。由于这些资源不会附带cookie，所以不用担心代理服务器会缓存用户的数据。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不要用cookie无关的域名来传输外部JS (Don’t serve early loaded external JS files from the cookieless domain)
在HTML文档头部引入并且页面渲染所需要的外部JavaScript文件，应该使用和页面一样的域名来传输，而不是使用cookie无关的新域名，因为 浏览器会阻塞JavaScript后面其他的资源下载，直到所有的JavaScript完成下载，解析，执行。所以如果使用cookie无关的域名则可能 会增加额外的DNS查询的时间。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;原文：&lt;a href=&quot;http://code.google.com/speed/page-speed/docs/request.html&quot;&gt;http://code.google.com/speed/page-speed/docs/request.html&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Apache性能优化</title>
   <link href="http://weizhifeng.net/high-performance-with-apache.html"/>
   <updated>2011-03-26T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/high-performance-with-apache</id>
   <content type="html">&lt;h3&gt;前言&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://httpd.apache.org/&quot; title=&quot;Apache&quot;&gt;Apache&lt;/a&gt;是世界上使用最广泛的WEB服务器，根据&lt;a href=&quot;https://developers.google.com/speed/docs/best-practices/rules_intro&quot; title=&quot;PageSpeed&quot;&gt;PageSpeed&lt;/a&gt;的规则，我们可以从&lt;a href=&quot;http://en.wikipedia.org/wiki/Keepalive&quot; title=&quot;KeepAlive&quot;&gt;KeepAlive&lt;/a&gt;，&lt;a href=&quot;http://en.wikipedia.org/wiki/HTTP_cache&quot; title=&quot;HTTP cache&quot;&gt;浏览器缓存&lt;/a&gt;，&lt;a href=&quot;http://en.wikipedia.org/wiki/Gzip&quot; title=&quot;Gzip&quot;&gt;Gzip&lt;/a&gt;等方面对其进行些调整，从而提高网站性能。&lt;/p&gt;

&lt;h3&gt;开启Keep-Alive&lt;/h3&gt;

&lt;p&gt;开启Keep-Alive后，可以保证浏览器和服务器之间的连接持久存在，这样如果同一个域名请求很多资源的情况下可以省去建立连接的时间和资源消耗。所以对于静态服务器来说，由于一个域名会请求N多资源，比较宜开启Keep-Alive，但是对于动态服务器，不宜开启Keep-Alive，因为这样会造成很多的空闲进程，浪费内存空间。 配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;KeepAlive On #开启KeepAlive
KeepAliveTimeout 5 #保持连接5秒
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;HTTP缓存设置&lt;/h3&gt;

&lt;p&gt;当直接在浏览器中输入一个URL，或者点击一个链接的时候，那么浏览器缓存就会起作用，如果缓存没有过期，那么浏览器会从本地读取资源，不会发起HTTP请求，如果缓存过期，那么浏览器会发起新的浏览器请求。按&lt;code&gt;ctrl+F5&lt;/code&gt;，浏览器会情况本地缓存，重新请求资源。    &lt;br/&gt;
&lt;code&gt;Expires&lt;/code&gt;是HTTP/1.0的缓存头， &lt;code&gt;Cache-Control: max-age&lt;/code&gt;是HTTP/1.1是用来进行HTTP缓存的头。   &lt;br/&gt;
Expires指定了资源过期的绝对时间，GMT格式，Cache-Control: max-age指定了资源过期的相对时间，单位是秒。    &lt;br/&gt;
在支持HTTP/1.1的浏览器上，如果发送两个头，那么Cache-Control: max-age会覆盖掉Expires；     &lt;br/&gt;
在支持HTTP/1.0的浏览器上，即使发送了两个头，但是只有Expires会起作用，所以为了兼容老的浏览器，还是要同时发送这两个头。&lt;/p&gt;

&lt;p&gt;设置HTTP缓存，需要安装expires_module，其会发送Expires和Cache-Control: max-age两个HTTP头。配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;IfModule expires_module&amp;gt;
    ExpiresActive On
    ExpiresByType application/x-javascript  &quot;access plus 30 days&quot;
    ExpiresByType text/css  &quot;access plus 30 days&quot;
    ExpiresByType image/gif  &quot;access plus 30 days&quot;
    ExpiresByType image/jpeg  &quot;access plus 30 days&quot;
    ExpiresByType image/png  &quot;access plus 30 days&quot;
&amp;lt;/IfModule&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ExpiresByType application/x-javascript &quot;access plus 30 days&quot;&lt;/code&gt;表示对js资源设置&lt;code&gt;Expires&lt;/code&gt;和&lt;code&gt;Cache-Control: max-age&lt;/code&gt;头，其中&lt;code&gt;Expires&lt;/code&gt;的值是以客户端访问资源的时间为基准的后30天，&lt;code&gt;Cache-Control: max-age&lt;/code&gt;的值是3600x24x30秒。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ExpiresByType application/x-javascript &quot;modification plus 30 days&quot;&lt;/code&gt;和上面效果一样，只是&lt;code&gt;Expires&lt;/code&gt;的时间是以资源最后修改的时间作为计算的基准。&lt;/p&gt;

&lt;h3&gt;开启Gzip压缩，并设置vary头&lt;/h3&gt;

&lt;p&gt;Gzip会对文本资源进行压缩，一般能节省40%的大小，二进制内容不需要开启Gzip压缩，因为这些文件是已经压缩过的，如果再进行Gzip压缩反而会增加其大小。静态资源一般都会在代理服务器上进行缓存，而有的浏览器支持Gzip，但是也有不支持Gzip的老旧浏览器，所以需要设置&lt;code&gt;Vary: Accept-Encoding&lt;/code&gt; 头，这个头告诉代理缓存服务器要对资源缓存两份，一份压缩过的，一份没有压缩过，然后根据浏览器发送的&lt;code&gt;Accept-Encoding&lt;/code&gt;头来返回压缩或者不压缩的内容。设置Gzip压缩，需要安装&lt;code&gt;deflate_module&lt;/code&gt;。 配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;IfModule deflate_module&amp;gt;

    #对js,html,xml,css,普通文本开启Gzip压缩
    AddOutputFilterByType DEFLATE application/x-javascript text/html text/plain text/xml text/css

&amp;lt;/IfModule&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;关掉ETag&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Last-Modified&lt;/code&gt;与&lt;code&gt;ETag&lt;/code&gt;是同样的功能，都是用来标识一个资源是否更改过，Last-Modified的值是资源的时间戳，如果按&lt;code&gt;F5&lt;/code&gt;或者刷新按钮则&lt;code&gt;If-Modified-Since&lt;/code&gt;头会带着时间戳发送到服务器，如果服务器上资源的最后修改时间&amp;lt;=这个时间，那么返回&lt;code&gt;304 Not Modified&lt;/code&gt;，否则返回&lt;code&gt;200 OK&lt;/code&gt; 以及新的资源；ETag的值是通过资源的信息（一般为inode，大小，时间戳）而计算出来的一个字符串，如果按F5或者刷新按钮则&lt;code&gt;If-None-Match&lt;/code&gt;头会带着这个值发送到服务器，服务器用这个值来和当前资源的值进行比对，如果相等，则返回&lt;code&gt;304 Not Modified&lt;/code&gt;，否则返回&lt;code&gt;200 OK&lt;/code&gt; 以及新的资源。默认情况下Apache对静态资源会发送Last-Modified和ETage，但是由于ETage的计算会耗费服务器的CPU资源，所以选择关掉，只开启Last-Modified。 配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FileETag None
Header unset ETag
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;参考：&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://lamp.linux.gov.cn/Apache/ApacheMenu/mod/mod_expires.html&quot;&gt;http://lamp.linux.gov.cn/Apache/ApacheMenu/mod/mod_expires.html&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>HAR(HTTP Archive)规范</title>
   <link href="http://weizhifeng.net/har-12-spec-chinese-edtion.html"/>
   <updated>2011-03-26T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/har-12-spec-chinese-edtion</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;http://www.softwareishard.com/blog/har-12-spec/&quot; title=&quot;har-12-spec&quot;&gt;HAR&lt;/a&gt;（HTTP Archive），是一个用来储存HTTP请求/响应信息的通用文件格式，基于&lt;a href=&quot;http://www.ietf.org/rfc/rfc4627.txt&quot; title=&quot;JSON&quot;&gt;JSON&lt;/a&gt;。这个格式的出现可以使HTTP监测工具以一种通用的格式导出所收集的数据，这些数据可以被其他支持HAR的HTTP&lt;a href=&quot;http://www.softwareishard.com/blog/har-adopters/&quot; title=&quot;分析工具&quot;&gt;分析工具&lt;/a&gt;（包括&lt;a href=&quot;http://getfirebug.com/&quot; title=&quot;Firebug&quot;&gt;Firebug&lt;/a&gt;，&lt;a href=&quot;http://www.httpwatch.com/&quot; title=&quot;httpwatch&quot;&gt;httpwatch&lt;/a&gt;，&lt;a href=&quot;http://www.fiddler2.com/fiddler2/&quot; title=&quot;Fiddler&quot;&gt;Fiddler&lt;/a&gt;等）所使用，来分析网站的性能瓶颈。目前HAR规范最新版本为&lt;a href=&quot;http://www.softwareishard.com/blog/har-12-spec/&quot; title=&quot;har-12-spec&quot;&gt;HAR 1.2&lt;/a&gt;。HAR文件必须是UTF-8编码，有无BOM无所谓。&lt;/p&gt;

&lt;h3&gt;HAR数据结构：&lt;/h3&gt;

&lt;p&gt;一个HAR文件就是一个JSON对象，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &quot;log&quot;: {
        &quot;version&quot; : &quot;1.2&quot;,
        &quot;creator&quot; : {},
        &quot;browser&quot; : {},
        &quot;pages&quot;: [],
        &quot;entries&quot;: [],
        &quot;comment&quot;: &quot;&quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;version [string] – 版本，默认为1.1。&lt;/li&gt;
&lt;li&gt;creator [object] – 创建HAR文件的程序名称和版本信息。&lt;/li&gt;
&lt;li&gt;browser [object, 可选] – 浏览器的名称和版本信息。&lt;/li&gt;
&lt;li&gt;pages [array, 可选] – 页面列表，如果应用不支持按照page分组，可以省去此字段。&lt;/li&gt;
&lt;li&gt;entries [array] – 所有HTTP请求的列表。&lt;/li&gt;
&lt;li&gt;comment [string, 可选]（new in 1.2） – 注释。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;注：每个页面对应一个 对象，每个HTTP请求对应一个对象。如果HTTP的监测分析工具不能把请求按照page分组，那么为空。&lt;/p&gt;

&lt;h3&gt;&amp;lt;creator&amp;gt; &amp;amp; &amp;lt;browser&amp;gt;&lt;/h3&gt;

&lt;p&gt;这两个对象的结构是一样的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;creator&quot;: {
    &quot;name&quot;: &quot;Firebug&quot;,
    &quot;version&quot;: &quot;1.6&quot;,
    &quot;comment&quot;: &quot;&quot;,
}

&quot;browser&quot;: {
    &quot;name&quot;: &quot;Firefox&quot;,
    &quot;version&quot;: &quot;3.6&quot;,
    &quot;comment&quot;: &quot;&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;name [string] – HAR生成工具或者浏览器的名称。&lt;/li&gt;
&lt;li&gt;version [string] – HAR生成工具或者浏览器的版本。&lt;/li&gt;
&lt;li&gt;comment [string, 可选]（new in 1.2） – 注释。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;&amp;lt;pages&amp;gt;&lt;/h3&gt;

&lt;p&gt;这个对象保存了页面列表，格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;pages&quot;: [
    {
        &quot;startedDateTime&quot;: &quot;2009-04-16T12:07:25.123+01:00&quot;,
        &quot;id&quot;: &quot;page_0&quot;,
        &quot;title&quot;: &quot;Test Page&quot;,
        &quot;pageTimings&quot;: {...},
        &quot;comment&quot;: &quot;&quot;
    }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;startedDateTime [string] – 页面开始加载的时间(格式ISO 8601 – YYYY-MM-DDThh:mm:ss.sTZD, 例如2009-07-24T19:20:30.45+01:00)。&lt;/li&gt;
&lt;li&gt;id [string] – page的唯一标示，entry会用到这个id来和page关联在一起。&lt;/li&gt;
&lt;li&gt;title [string] – 页面标题。&lt;/li&gt;
&lt;li&gt;pageTimings[object] – 页面加载过程中详细的时间信息。&lt;/li&gt;
&lt;li&gt;comment [string, 可选]（new in 1.2） – 注释。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;&amp;lt;pageTimings&amp;gt;&lt;/h3&gt;

&lt;p&gt;这个对象描述了在页面加载过程中各个事件发生的时间点。所有的时间都是以毫秒计算的。如果有的时间无法计算出来，那么相应字段置为-1。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;pageTimings&quot;: [
    {
        &quot;onContentLoad&quot;: 1720,
        &quot;onLoad&quot;: 2500,
        &quot;comment&quot;: &quot;&quot;
    }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;onContentLoad [number, 可选] – 页面内容加载时间，相对于页面开始加载时间的毫秒数（page.startedDateTime）。如果时间不适用于当前的请求，那么置为-1。&lt;/li&gt;
&lt;li&gt;onLoad [number,可选] – 页面加载时间（即onLoad事件触发的时间）。相对于页面开始加载时间的毫秒数（page.startedDateTime）。如果时间不适用于当前的请求，那么置为-1。&lt;/li&gt;
&lt;li&gt;comment [string, 可选]（new in 1.2） – 注释。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;由于不同浏览器实现不一样，onContentLoad属性可能代表&lt;strong&gt;DOMContentLoad&lt;/strong&gt;事件触发，也可能代表document.readyState等于&lt;strong&gt;interactive&lt;/strong&gt;。&lt;/p&gt;

&lt;h3&gt;&amp;lt;entries&amp;gt;&lt;/h3&gt;

&lt;p&gt;这个对象包含了一个数组，数组中每个元素的内容就是一个HTTP请求的相应信息。用startedDateTime来排序的话可以加快数据导出的速度。HAR分析工具要确保此数组是按照startedDateTime排序的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;entries&quot;: [
    {
        &quot;pageref&quot;: &quot;page_0&quot;,
        &quot;startedDateTime&quot;: &quot;2009-04-16T12:07:23.596Z&quot;,
        &quot;time&quot;: 50,
        &quot;request&quot;: {...},
        &quot;response&quot;: {...},
        &quot;cache&quot;: {...},
        &quot;timings&quot;: {},
        &quot;serverIPAddress&quot;: &quot;10.0.0.1&quot;,
        &quot;connection&quot;: &quot;52492&quot;,
        &quot;comment&quot;: &quot;&quot;
    }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;pageref [string, unique, 可选] – 页面id，如果不支持按照page分组，那么字段为空。&lt;/li&gt;
&lt;li&gt;startedDateTime [string] – 请求开始时间 (格式ISO 8601 – YYYY-MM-DDThh:mm:ss.sTZD)。&lt;/li&gt;
&lt;li&gt;time [number] – 请求消耗的时间，以毫秒为单位。这个值是timings对象中所有可用(值不为-1) timing的和。&lt;/li&gt;
&lt;li&gt;request [object] – 请求的详细信息。&lt;/li&gt;
&lt;li&gt;response [object] – 响应的详细信息。&lt;/li&gt;
&lt;li&gt;cache [object] – 缓存使用情况的信息。&lt;/li&gt;
&lt;li&gt;timings [object] – 请求/响应过程（round trip）的详细时间信息。&lt;/li&gt;
&lt;li&gt;serverIPAddress [string, 可选]（new in 1.2） – 服务器IP地址。&lt;/li&gt;
&lt;li&gt;connection [string, 可选]（new in 1.2）– TCP/IP连接的唯一标示。 如果程序不支持，直接忽略此字段。&lt;/li&gt;
&lt;li&gt;comment [string, optional]（new in 1.2） – 注释。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;&amp;lt;request&amp;gt;&lt;/h3&gt;

&lt;p&gt;这个对象包含了请求的详细信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;request&quot;: {
    &quot;method&quot;: &quot;GET&quot;,
    &quot;url&quot;: &quot;http://www.example.com/path/?param=value&quot;,
    &quot;httpVersion&quot;: &quot;HTTP/1.1&quot;,
    &quot;cookies&quot;: [],
    &quot;headers&quot;: [],
    &quot;queryString&quot; : [],
    &quot;postData&quot; : {},
    &quot;headersSize&quot; : 150,
    &quot;bodySize&quot; : 0,
    &quot;comment&quot; : &quot;&quot;,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;method [string] – 请求方法(GET，POST，...)。&lt;/li&gt;
&lt;li&gt;url [string] – 请求的绝对URL(fragments are not included)。&lt;/li&gt;
&lt;li&gt;httpVersion [string] – 请求HTTP版本。&lt;/li&gt;
&lt;li&gt;cookies [array] – cookie列表。&lt;/li&gt;
&lt;li&gt;headers [array] – header列表。&lt;/li&gt;
&lt;li&gt;queryString [object] – 查询字符串信息。&lt;/li&gt;
&lt;li&gt;postData [object, 可选] – Post数据信息。&lt;/li&gt;
&lt;li&gt;headersSize [number] – HTTP请求头的字节数。如果不可用，设置为-1。&lt;/li&gt;
&lt;li&gt;bodySize [number] – 请求body字节数（POST数据）。如果不可用，设置为-1。&lt;/li&gt;
&lt;li&gt;comment [string, 可选]（new in 1.2）– 注释。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;&amp;lt;response&amp;gt;&lt;/h3&gt;

&lt;p&gt;这个对象包含响应的详细信息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;response&quot;: {
    &quot;status&quot;: 200,
    &quot;statusText&quot;: &quot;OK&quot;,
    &quot;httpVersion&quot;: &quot;HTTP/1.1&quot;,
    &quot;cookies&quot;: [],
    &quot;headers&quot;: [],
    &quot;content&quot;: {},
    &quot;redirectURL&quot;: &quot;,
    &quot;headersSize&quot; : 160,
    &quot;bodySize&quot; : 850,
    &quot;comment&quot; : &quot;&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;status [number] – 响应状态。&lt;/li&gt;
&lt;li&gt;statusText [string] – 响应状态描述。&lt;/li&gt;
&lt;li&gt;httpVersion [string] – HTTP版本。&lt;/li&gt;
&lt;li&gt;cookies [array] – cookie列表。&lt;/li&gt;
&lt;li&gt;headers [array] – header列表。&lt;/li&gt;
&lt;li&gt;content [object] – 响应内容的详细信息。&lt;/li&gt;
&lt;li&gt;redirectURL [string] – Location响应头中的重定向URL。&lt;/li&gt;
&lt;li&gt;headersSize [number]*  – HTTP请求头的字节数。如果不可用，设置为-1。&lt;/li&gt;
&lt;li&gt;bodySize [number] – 接收的body字节数。如果响应来自缓存(304)，那么设置为0。如果不可用，设置为-1。&lt;/li&gt;
&lt;li&gt;comment [string, optional]（new in 1.2） – 注释。
注：headersSize – 响应头大小只对从服务器接收到的header进行计算。被浏览器加上的header不计算在内，但是会加在header列表中。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;&amp;lt;cookies&amp;gt;&lt;/h3&gt;

&lt;p&gt;这个对象包含了所有的cookie（在和中被使用）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;cookies&quot;: [
    {
        &quot;name&quot;: &quot;TestCookie&quot;,
        &quot;value&quot;: &quot;Cookie Value&quot;,
        &quot;path&quot;: &quot;/&quot;,
        &quot;domain&quot;: &quot;www.janodvarko.cz&quot;,
        &quot;expires&quot;: &quot;2009-07-24T19:20:30.123+02:00&quot;,
        &quot;httpOnly&quot;: false,
        &quot;secure&quot;: false,
        &quot;comment&quot;: &quot;&quot;,
    }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;name [string] – cookie名称。&lt;/li&gt;
&lt;li&gt;value [string] – cookie值。&lt;/li&gt;
&lt;li&gt;path [string, 可选] – cookie Path。&lt;/li&gt;
&lt;li&gt;domain [string, 可选] – cookie域名。&lt;/li&gt;
&lt;li&gt;expires [string, 可选] – cookie过期时间。(格式ISO 8601 – YYYY-MM-DDThh:mm:ss.sTZD, 例如2009-07-24T19:20:30.123+02:00)。&lt;/li&gt;
&lt;li&gt;httpOnly [boolean, 可选] – 如果cookie只是在HTTP下有效，此值设置为true，否则设置为false。&lt;/li&gt;
&lt;li&gt;secure [boolean, 可选]（new in 1.2） – 如果cookie通过ssl传送，此值设置为true，否则设置为false。&lt;/li&gt;
&lt;li&gt;comment [string, 可选]（new in 1.2） – 注释。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;&amp;lt;headers&amp;gt;&lt;/h3&gt;

&lt;p&gt;这个对象包含了所有的header（可以在&lt;strong&gt;lt;request&amp;gt;&lt;/strong&gt;and&lt;strong&gt;&amp;lt;response&amp;gt;&lt;/strong&gt;中使用）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;headers&quot;: [
    {
        &quot;name&quot;: &quot;Accept-Encoding&quot;,
        &quot;value&quot;: &quot;gzip,deflate&quot;,
        &quot;comment&quot;: &quot;&quot;
    },

    {
        &quot;name&quot;: &quot;Accept-Language&quot;,
        &quot;value&quot;: &quot;en-us,en;q=0.5&quot;,
        &quot;comment&quot;: &quot;&quot;
    }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&amp;lt;queryString&amp;gt;&lt;/h3&gt;

&lt;p&gt;这个对象包含了查询字符串中所有的paramter-value对（嵌在对象中）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;queryString&quot;: [
    {
        &quot;name&quot;: &quot;param1&quot;,
        &quot;value&quot;: &quot;value1&quot;,
        &quot;comment&quot;: &quot;&quot;
    },

    {
        &quot;name&quot;: &quot;param1&quot;,
        &quot;value&quot;: &quot;value1&quot;,
        &quot;comment&quot;: &quot;&quot;
    }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&amp;lt;postData&amp;gt;&lt;/h3&gt;

&lt;p&gt;这个对象描述了POST的数据（嵌在对象中）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;postData&quot;: {
    &quot;mimeType&quot;: &quot;multipart/form-data&quot;,
    &quot;params&quot;: [],
    &quot;text&quot; : &quot;plain posted data&quot;,
    &quot;comment&quot;: &quot;&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;mimeType [string] – POST数据的MIME类型。&lt;/li&gt;
&lt;li&gt;params [array] – POST参数列表 (in case of URL encoded parameters)。&lt;/li&gt;
&lt;li&gt;text [string] – POST数据的纯文本形式(Plain text posted data)。&lt;/li&gt;
&lt;li&gt;comment [string, optional]（new in 1.2） – 注释。
注意：text和params字段是互斥的。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;&amp;lt;params&amp;gt;&lt;/h3&gt;

&lt;p&gt;POST请求参数列表（嵌在 对象中）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;params&quot;: [
    {
        &quot;name&quot;: &quot;paramName&quot;,
        &quot;value&quot;: &quot;paramValue&quot;,
        &quot;fileName&quot;: &quot;example.pdf&quot;,
        &quot;contentType&quot;: &quot;application/pdf&quot;,
        &quot;comment&quot;: &quot;&quot;
    }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;name [string] – POST参数名。&lt;/li&gt;
&lt;li&gt;value [string, 可选] – POST参数的值，或者POST文件的内容。&lt;/li&gt;
&lt;li&gt;fileName [string, 可选] – POST文件的文件名。&lt;/li&gt;
&lt;li&gt;contentType [string, 可选] – POST文件的类型。&lt;/li&gt;
&lt;li&gt;comment [string, 可选]（new in 1.2） – 注释。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;&amp;lt;content&amp;gt;&lt;/h3&gt;

&lt;p&gt;这个对象描述了响应内容的详细情况（嵌在 对象中）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;content&quot;: {
    &quot;size&quot;: 33,
    &quot;compression&quot;: 0,
    &quot;mimeType&quot;: &quot;text/html; charset=&quot;utf-8&quot;,
    &quot;text&quot;: &quot;n&quot;,
    &quot;comment&quot;: &quot;&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;size [number] – 返回内容的字节数。如果内容没有被压缩，应该和response.bodySize相等；如果被压缩，那么会大于response.bodySize。&lt;/li&gt;
&lt;li&gt;compression [number, 可选] – 节省的字节数。如果无法提供此信息，则忽略此字段。&lt;/li&gt;
&lt;li&gt;mimeType [string] – 响应文本的MIME类型 (Content-Type响应头的值)。MIMIE类型的字符集也包含在内。&lt;/li&gt;
&lt;li&gt;text [string, 可选] – 从服务器返回的响应body或者从浏览器缓存加载的内容。这个字段只能用文本型的内容来填充。字段内容可以是HTTP decoded(decompressed &amp;amp; unchunked)的文本，或者是经编码（例如，base64）过的响应内容。如果信息不可用，忽略此字段。&lt;/li&gt;
&lt;li&gt;encoding [string, 可选]（new in 1.2） – 响应内容的编码格式，例如”base64″。如果text字段的内容是经过了HTTP解码(decompressed &amp;amp; unchunked)的，那么忽略此字段。&lt;/li&gt;
&lt;li&gt;comment [string, optional]（new in 1.2） – 注释。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;在设置text字段之前，HTTP响应内容已经完成了解码(decompressed &amp;amp; unchunked)，然后把原始字符编码转换成UTF-8。字段内容同样可以使用base64进行编码，但是HAR工具必须有解码base64的能力。对字段编码还可以把二进制内容包含进HAR文件中。&lt;/p&gt;

&lt;p&gt;这有另一个例子，原始响应内容是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;content&quot;: {
    &quot;size&quot;: 33,
    &quot;compression&quot;: 0,
    &quot;mimeType&quot;: &quot;text/html; charset=&quot;utf-8&quot;,
    &quot;text&quot;: &quot;PGh0bWw+PGhlYWQ+PC9oZWFkPjxib2R5Lz48L2h0bWw+XG4=&quot;,
    &quot;encoding&quot;: &quot;base64&quot;,
    &quot;comment&quot;: &quot;&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&amp;lt;cache&amp;gt;&lt;/h3&gt;

&lt;p&gt;这个对象包含了命中的浏览器缓存信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;cache&quot;: {
    &quot;beforeRequest&quot;: {},
    &quot;afterRequest&quot;: {},
    &quot;comment&quot;: &quot;&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;beforeRequest [object, 可选] – 在请求之前缓存的状态。如果信息不可用，可以忽略此字段。&lt;/li&gt;
&lt;li&gt;afterRequest [object, 可选] – 在请求之后缓存的状态。 如果信息不可用，可以忽略此字段。&lt;/li&gt;
&lt;li&gt;comment [string, 可选]（new in 1.2） – 注释。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;如果缓存信息为空，那么对象如下（或者也可以直接删掉cache这个字段）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;cache&quot;: {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果在请求之前，缓存信息不可用，并且在请求之后也没有对内容进行缓存，那么对象如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;cache&quot;: {
    &quot;afterRequest&quot;: null
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果在请求前后都没有缓存存在，那么对象如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;cache&quot;: {
    &quot;beforeRequest&quot;: null,
    &quot;afterRequest&quot;: null
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下对象表示请求之前没有缓存，但是在请求后，下载的内容被存在了本地缓存中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;cache&quot;: {
    &quot;beforeRequest&quot;: null,
    &quot;afterRequest&quot;: {
        &quot;expires&quot;: &quot;2009-04-16T15:50:36&quot;,
        &quot;lastAccess&quot;: &quot;2009-16-02T15:50:34&quot;,
        &quot;eTag&quot;: &quot;,
        &quot;hitCount&quot;: 0,
        &quot;comment&quot;: &quot;&quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;beforeRequest和afterRequest对象使用以下相同的结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;beforeRequest&quot;: {
    &quot;expires&quot;: &quot;2009-04-16T15:50:36&quot;,
    &quot;lastAccess&quot;: &quot;2009-16-02T15:50:34&quot;,
    &quot;eTag&quot;: &quot;,
    &quot;hitCount&quot;: 0,
    &quot;comment&quot;: &quot;“”
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;expires [string, 可选] – 缓存过期时间。&lt;/li&gt;
&lt;li&gt;lastAccess [string] – 缓存最后被访问的时间。&lt;/li&gt;
&lt;li&gt;eTag [string] – Etag&lt;/li&gt;
&lt;li&gt;hitCount [number] – 缓存被访问的次数。&lt;/li&gt;
&lt;li&gt;comment [string, 可选]（new in 1.2） – 注释&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;&amp;lt;timings&amp;gt;&lt;/h3&gt;

&lt;p&gt;这个对象描述了请求/响应过程的各个阶段。时间都是以毫秒为单位。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;timings&quot;: {
    &quot;blocked&quot;: 0,
    &quot;dns&quot;: -1,
    &quot;connect&quot;: 15,
    &quot;send&quot;: 20,
    &quot;wait&quot;: 38,
    &quot;receive&quot;: 12,
    &quot;ssl&quot;: -1,
    &quot;comment&quot;: &quot;&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;blocked [number, 可选] – 建立网络连接时在队列里边等待的时间。如果时间对于当前请求不可用，置为-1。&lt;/li&gt;
&lt;li&gt;dns [number, 可选] – DNS查询时间。如果时间对于当前请求不可用，置为-1。&lt;/li&gt;
&lt;li&gt;connect [number, 可选] – 建立TCP连接所需的时间。如果时间对于当前请求不可用，置为-1。&lt;/li&gt;
&lt;li&gt;send [number] – 发送HTTP请求到服务器所需的时间。&lt;/li&gt;
&lt;li&gt;wait [number] – 等待服务器返回响应的时间。&lt;/li&gt;
&lt;li&gt;receive [number] – 接收服务器响应（或者缓存）所需时间。&lt;/li&gt;
&lt;li&gt;ssl [number, 可选]（new in 1.2） – SSL/TLS验证花费时间。如果这个字段被定义了，那么这个时间也会被包含进connect字段中(为了向后兼容HAR1.1)。如果时间对于当前请求不可用，置为-1。&lt;/li&gt;
&lt;li&gt;comment [string, 可选]（new in 1.2） – 注释。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;send&lt;/strong&gt;，&lt;strong&gt;wait&lt;/strong&gt;，&lt;strong&gt;receive&lt;/strong&gt;时间是必须提供的，并且不能为负数。导出工具如果不能提供blocked,dns,connect和ssl等时间，那么这些时间可以被忽略。如果工具可以提供这些时间，但是不适用的话，可以把这些值设置为-1。 例如，当请求使用了一个存在的连接，connect会被置为-1。&lt;/p&gt;

&lt;p&gt;一个请求所花的时间等于这些时间的和，不包括值为-1的。   &lt;br/&gt;
&lt;strong&gt;entry.time == entry.timings.blocked + entry.timings.dns + entry.timings.connect + entry.timings.send + entry.timings.wait + entry.timings.receive&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;自定义字段&lt;/h3&gt;

&lt;p&gt;HAR规范允许自定义字段，但是要遵循如下规则：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;自定义字段（field）和元素（element）必须以下划线开头(规范中的字段必须不能以下划线开头)&lt;/li&gt;
&lt;li&gt;HAR工具必须忽略所有自定义字段和元素，如果这个HAR文件不是当前HAR工具生成的。&lt;/li&gt;
&lt;li&gt;当HAR工具不知道如何解析非自定义字段的时候，忽略它们。&lt;/li&gt;
&lt;li&gt;当文件包含了已经被废弃的非自定义字段时候，HAR工具可以拒绝解析此文件。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;版本格式&lt;/h3&gt;

&lt;p&gt;HAR规范的版本号有如下规则：
&amp;lt;主版本号&gt;.&amp;lt;副版本号&gt;
主版本号表示规范的向后兼容性，副版本号表示增量修改。所以，任何向后兼容的修改都会增加副版本号。如果一个存在的字段被废弃了，那么主版本号要增加(例如2.0)。&lt;/p&gt;

&lt;p&gt;Examples:
1.2 -&gt; 1.3(向后兼容)    &lt;br/&gt;
1.111 -&gt; 1.112 (向后兼容)    &lt;br/&gt;
1.5 -&gt; 2.0 (2.0不兼容1.5)     &lt;br/&gt;
如果HAR工具只支持HAR1.1，那么以下的代码可以被用来检测不被兼容的版本。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (majorVersion != 1 || minorVersion &amp;lt; 1)
{
    throw “Incompatible version”;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子中，如果被解析文件的版本为0.8,0.9,1.0等，那么工具会抛出异常，但是1.1, 1.2, 1.112等版本可以被解析。2.x版本直接拒绝解析。&lt;/p&gt;

&lt;p&gt;原文：&lt;a href=&quot;http://www.softwareishard.com/blog/har-12-spec/&quot;&gt;http://www.softwareishard.com/blog/har-12-spec/&lt;/a&gt;  &lt;br/&gt;
Google Group: &lt;a href=&quot;http://groups.google.com/group/http-archive-specification&quot;&gt;http://groups.google.com/group/http-archive-specification【需翻墙】&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Form的enctype和action属性</title>
   <link href="http://weizhifeng.net/enctype-and-action-in-form.html"/>
   <updated>2011-03-26T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/enctype-and-action-in-form</id>
   <content type="html">&lt;h3&gt;前言&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/HTML&quot;&gt;HTML&lt;/a&gt;中的&lt;a href=&quot;http://www.w3.org/TR/html401/interact/forms.html&quot;&gt;form&lt;/a&gt;标签想必是再熟悉不过了，其有&lt;code&gt;enctype&lt;/code&gt;和&lt;code&gt;action&lt;/code&gt;两个属性，平时并没有特别注意这两个属性的含义，今天介绍一下。&lt;/p&gt;

&lt;h3&gt;说明&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;enctype&lt;/p&gt;

&lt;p&gt;form的enctype属性为编码方式，常用有两种：&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;     &lt;br/&gt;
和&lt;code&gt;multipart/form-data&lt;/code&gt;，默认为&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;action&lt;/p&gt;

&lt;p&gt;当&lt;code&gt;action&lt;/code&gt;为&lt;code&gt;GET&lt;/code&gt;时候，浏览器用&lt;code&gt;x-www-form-urlencoded&lt;/code&gt;的编码方式把form数据转换成一个字串（name1=value1&amp;amp; amp;name2=value2...），然后把这个字串追加到url后面，用&lt;code&gt;?&lt;/code&gt;分割，然后再加载这个新的url。&lt;/p&gt;

&lt;p&gt;当&lt;code&gt;action&lt;/code&gt;为&lt;code&gt;POST&lt;/code&gt;时候，浏览器把form数据封装到&lt;strong&gt;HTTP body&lt;/strong&gt;中，然后发送到服务器。
如果没有&lt;code&gt;type=file&lt;/code&gt;的&lt;code&gt;input&lt;/code&gt;控件，用默认的&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;就可以了。但是如果有 &lt;code&gt;type=file&lt;/code&gt;的话，就要用到&lt;code&gt;multipart/form-data&lt;/code&gt;了。   &lt;br/&gt;
浏览器会把整个表单以控件为单位分割，并为每个部分加上以下标识符：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Content- Disposition&lt;/code&gt;(form-data或者file)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Content-Type&lt;/code&gt;(默认为text/plain)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;name&lt;/code&gt;(控件 name)等信息，&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;并且每个标识符后面都加上分割符(&lt;strong&gt;boundary&lt;/strong&gt;)。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;如果有以下form，并选择上传文件&lt;strong&gt;file1.txt&lt;/strong&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;form action=&quot;http://server.com/cgi/handle&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&amp;gt;
    &amp;lt;input name=&quot;submit-name&quot; type=&quot;text&quot; value=&quot;chmod777&quot; /&amp;gt;
    What files are you sending?
    &amp;lt;input name=&quot;files&quot; type=&quot;file&quot; /&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;则有如下body：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Content-Type: multipart/form-data; boundary=AaB03x

--AaB03x
Content-Disposition: form-data; name=”submit-name”

chmod777
--AaB03x
Content-Disposition: form-data; name=”files”; filename=”file1.txt”
Content-Type: text/plain

...contents of file1.txt...
--AaB03x--
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.w3.org/TR/html401/interact/forms.html#h-17.13.1&quot;&gt;http://www.w3.org/TR/html401/interact/forms.html#h-17.13.1&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PHP_SELF，SCRIPT_NAME，SCRIPT_FILENAME，PATH_INFO，REQUEST_URI的区别</title>
   <link href="http://weizhifeng.net/difference-between-php_self-script_name-script_filename-path_info-and-request_uri.html"/>
   <updated>2011-03-26T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/difference-between-php_self-script_name-script_filename-path_info-and-request_uri</id>
   <content type="html">&lt;h3&gt;前言&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.php.net&quot; title=&quot;PHP Hypertext Preprocessor&quot;&gt;PHP&lt;/a&gt;的&lt;a href=&quot;http://cn2.php.net/reserved.variables.server.php&quot; title=&quot;$_SERVER&quot;&gt;$_SERVER&lt;/a&gt;数组中存在五个和路径相关的变量：&lt;code&gt;PHP_SELF&lt;/code&gt;，&lt;code&gt;SCRIPT_NAME&lt;/code&gt;，    &lt;br/&gt;
&lt;code&gt;SCRIPT_FILENAME&lt;/code&gt;，&lt;code&gt;PATH_INFO&lt;/code&gt;，&lt;code&gt;REQUEST_URI&lt;/code&gt;，这五个变量经常会被混淆，做下区分。&lt;/p&gt;

&lt;h3&gt;测试环境&lt;/h3&gt;

&lt;p&gt;Nginx0.8.54 + FastCGI + PHP5.3.4&lt;/p&gt;

&lt;p&gt;要先配置Nginx的&lt;code&gt;PATH_INFO&lt;/code&gt;，在&lt;code&gt;nginx.conf&lt;/code&gt;中加入如下配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;location ~ .* .php {
    fastcgi_pass   127.0.0.1:9000;
    fastcgi_index  index.php;

    #从$fastcgi_script_name中分离出真正执行的脚本名称和PATH_INFO
    set $real_script_name $fastcgi_script_name;

    if ($fastcgi_script_name ~ &quot;^(.+?.php)(/.+)$&quot;) {
        set $real_script_name $1;
        set $path_info $2;
     }

    #重新设置SCRIPT_FILENAME
    fastcgi_param SCRIPT_FILENAME $document_root$real_script_name;
    fastcgi_param  QUERY_STRING       $query_string;
    fastcgi_param  REQUEST_METHOD     $request_method;
    fastcgi_param  CONTENT_TYPE       $content_type;
    fastcgi_param  CONTENT_LENGTH     $content_length;

    #重新设置SCRIPT_NAME

    fastcgi_param SCRIPT_NAME $real_script_name;
    fastcgi_param PATH_INFO $path_info;
    fastcgi_param  REQUEST_URI        $request_uri;
    fastcgi_param  DOCUMENT_URI       $document_uri;
    fastcgi_param  DOCUMENT_ROOT      $document_root;
    fastcgi_param  SERVER_PROTOCOL    $server_protocol;
    fastcgi_param  GATEWAY_INTERFACE  CGI/1.1;
    fastcgi_param  SERVER_SOFTWARE    nginx/$nginx_version;
    fastcgi_param  REMOTE_ADDR        $remote_addr;
    fastcgi_param  REMOTE_PORT        $remote_port;
    fastcgi_param  SERVER_ADDR        $server_addr;
    fastcgi_param  SERVER_PORT        $server_port;
    fastcgi_param  SERVER_NAME        $server_name;

    # PHP only, required if PHP was built with --enable-force-cgi-redirect
    fastcgi_param  REDIRECT_STATUS    200;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们的根目录为&lt;code&gt;/var/www&lt;/code&gt;，测试域名为&lt;code&gt;example.com&lt;/code&gt;（不过这个域名只能改&lt;code&gt;hosts&lt;/code&gt;文件YY一下了），结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var
 |---www
       |---test
             |---test.php
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;测试脚本&lt;/h3&gt;

&lt;p&gt;使用如下脚本进行测试：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
    echo 'SCRIPT_NAME=' . $_SERVER['SCRIPT_NAME'] . '&amp;lt;br /&amp;gt;';
    echo 'SCRIPT_FILENAME=' . $_SERVER['SCRIPT_FILENAME'] . '&amp;lt;br /&amp;gt;';
    echo 'PATH_INFO=' . $_SERVER['PATH_INFO'] . '&amp;lt;br /&amp;gt;';
    echo 'REQUEST_URI=' . $_SERVER['REQUEST_URI'] . '&amp;lt;br /&amp;gt;';
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;测试结果&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;PHP_SELF: 当前所执行的脚本的文件名，这个值是相对于根目录来说。&lt;/p&gt;

&lt;p&gt;如果请求&lt;strong&gt;http://example.com/test/test.php?k=v&lt;/strong&gt;，则&lt;code&gt;PHP_SELF&lt;/code&gt;的值为   &lt;br/&gt;
&lt;strong&gt;/test/test.php&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SCRIPT_NAME： 当前执行的脚本的路径。&lt;/p&gt;

&lt;p&gt;如果请求&lt;strong&gt;http://example.com/test/test.php?k=v&lt;/strong&gt;，则&lt;code&gt;SCRIPT_NAME&lt;/code&gt;的值   &lt;br/&gt;
为&lt;strong&gt;/test/test.php&lt;/strong&gt;。这个变量是在&lt;a href=&quot;http://tools.ietf.org/html/rfc3875&quot; title=&quot;CGI/1.1&quot;&gt;CGI/1.1&lt;/a&gt;中定义的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SCRIPT_FILENAME： 当前执行的脚本的绝对路径。&lt;/p&gt;

&lt;p&gt;如果请求&lt;strong&gt;http://example.com/test/test.php?k=v&lt;/strong&gt;，则&lt;code&gt;SCRIPT_FILENAME&lt;/code&gt;的值   &lt;br/&gt;
为&lt;strong&gt;/var/www/test/test.php&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;注意：如果一个脚本以相对路径，&lt;a href=&quot;http://php.net/manual/en/features.commandline.php&quot; title=&quot;PHP CLI&quot;&gt;CLI&lt;/a&gt;方式来执行，例如&lt;strong&gt;../test/test.php&lt;/strong&gt;，那么   &lt;br/&gt;
&lt;code&gt;$_SERVER['SCRIPT_FILENAME']&lt;/code&gt;的值为相对路径，即&lt;strong&gt;../test/test.php&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;PATH_INFO：客户端提供的路径信息，即在实际执行脚本后面尾随的内容，但是会去掉&lt;strong&gt;Query String&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;如果请求&lt;strong&gt;http://example.com/test/test.php/a/b?k=v&lt;/strong&gt;，则&lt;code&gt;PATH_INFO&lt;/code&gt;的值为&lt;strong&gt;/a/b&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://tools.ietf.org/html/rfc3875&quot; title=&quot;CGI/1.1&quot;&gt;CGI1.1&lt;/a&gt;标准中如下描述：&quot;&lt;strong&gt;The PATH_INFO string is the trailing part of thecomponent of the script URI that follows the SCRIPT_NAME part of the path.&lt;/strong&gt;&quot;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;REQUEST_URI：包含HTTP协议中定义的URI内容。&lt;/p&gt;

&lt;p&gt;如果请求&lt;strong&gt;http://example.com/test/test.php?k=v&lt;/strong&gt;，则&lt;code&gt;REQUEST_URI&lt;/code&gt;   &lt;br/&gt;
为&lt;strong&gt;/test/test.php?k=v&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;区别&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;PHP_SELF VS SCRIPT_NAME：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PHP_SELF&lt;/code&gt;和&lt;code&gt;SCRIPT_NAME&lt;/code&gt;的值在大部分情况下都是一样的，但是访问   &lt;br/&gt;
&lt;strong&gt;http://example.com/test/test.php/a/b?k=v&lt;/strong&gt;这类URL时候，&lt;code&gt;PHP_SELF&lt;/code&gt;   &lt;br/&gt;
为&lt;strong&gt;/test/test.php/a/b&lt;/strong&gt;，&lt;code&gt;SCRIPT_NAME&lt;/code&gt;为&lt;strong&gt;/test/test.php&lt;/strong&gt;，可以看出&lt;code&gt;PHP_SELF&lt;/code&gt;   &lt;br/&gt;
比&lt;code&gt;SCRIPT_NAME&lt;/code&gt;多了&lt;code&gt;PATH_INFO&lt;/code&gt;的内容。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;REQUEST_URI VS SCRIPT_NAME：&lt;/p&gt;

&lt;p&gt;在访问&lt;strong&gt;http://example.com/test/test.php?k=v&lt;/strong&gt;后，&lt;code&gt;REQUEST_URI&lt;/code&gt;  &lt;br/&gt;
为&lt;strong&gt;/test/test.php?k=v&lt;/strong&gt;，&lt;code&gt;SCRIPT_NAME&lt;/code&gt;为&lt;strong&gt;/test/test.php&lt;/strong&gt;，可以看出&lt;code&gt;REQUEST_URI&lt;/code&gt;   &lt;br/&gt;
比&lt;code&gt;SCRIPT_NAME&lt;/code&gt;多了&lt;strong&gt;Query String&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;如果&lt;strong&gt;http://example.com/test/test.php&lt;/strong&gt;在服务器端做了&lt;strong&gt;rewrite&lt;/strong&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  rewrite /test/test.php /test/test2.php; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么&lt;code&gt;REQUEST_URI&lt;/code&gt;为&lt;strong&gt;/test/test.php&lt;/strong&gt;，&lt;code&gt;SCRIPT_NAME&lt;/code&gt;为&lt;strong&gt;/test/test2.php&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-robinson-www-interface-00&quot;&gt;http://tools.ietf.org/html/draft-robinson-www-interface-00&lt;/a&gt;    &lt;br/&gt;
&lt;a href=&quot;http://stackoverflow.com/questions/279966/php-self-vs-path-info-vs-script-name-vs-request-uri&quot;&gt;http://stackoverflow.com/questions/279966/php-self-vs-path-info-vs-script-name-vs-request-uri&lt;/a&gt; &lt;br/&gt;
&lt;a href=&quot;http://ca.php.net/manual/en/reserved.variables.server.php&quot;&gt;http://ca.php.net/manual/en/reserved.variables.server.php&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Diff与Patch</title>
   <link href="http://weizhifeng.net/diff-and-patch.html"/>
   <updated>2011-03-26T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/diff-and-patch</id>
   <content type="html">&lt;h3&gt;问题&lt;/h3&gt;

&lt;p&gt;假设/path/to/a目录下有a.txt，b.txt两个文件(内容如下)，我们如何才能通过打补丁的方式把a.txt升级为b.txt呢？
a.txt，b.txt的内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat a/a.txt
    a
    b
    c

$ cat a/b.txt
    a
    d
    c
    f
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;创建补丁文件&lt;/h3&gt;

&lt;p&gt;利用&lt;a href=&quot;http://en.wikipedia.org/wiki/Diff&quot;&gt;diff&lt;/a&gt;命令来完成，更多的选项可以通过&lt;code&gt;diff --help&lt;/code&gt;查看&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;diff -uN a/a.txt b/b.txt &amp;gt; a.patch
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;补丁文件格式&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;--- a/a.txt
+++ a/b.txt
@@ -1,3 +1,4 @@
 a
-b
+d
 c
+f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;--- a/a.txt&lt;/code&gt;中的&lt;code&gt;---&lt;/code&gt;表示旧文件    &lt;br/&gt;
&lt;code&gt;+++ a/b.txt&lt;/code&gt;中的&lt;code&gt;+++&lt;/code&gt;表示新文件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;@@ -1,3 +1,4 @@&lt;/code&gt;为内容变更区域：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-1,3&lt;/code&gt;表示旧文件(a.txt)的变更区域，从第1行开始，变动的行数是3，即1到3行会有变化 &lt;br/&gt;
&lt;code&gt;+1,4&lt;/code&gt;表示新文件(b.txt)的变更区域，从第1行开始，变动的行数是4，即1到4行会有变化   &lt;br/&gt;
&lt;code&gt;+&lt;/code&gt;表示添加新的一行 &lt;code&gt;+d&lt;/code&gt;表示添加了一行，内容是&lt;code&gt;d&lt;/code&gt;   &lt;br/&gt;
&lt;code&gt;-&lt;/code&gt;表示删除了这一行 &lt;code&gt;-b&lt;/code&gt;表示删除了b这一行&lt;/p&gt;

&lt;h3&gt;打补丁&lt;/h3&gt;

&lt;p&gt;利用&lt;a href=&quot;http://en.wikipedia.org/wiki/Patch&quot;&gt;patch&lt;/a&gt;命令来完成，参数可以通过&lt;code&gt;patch --help&lt;/code&gt;查看，常用方式有两种：&lt;/p&gt;

&lt;p&gt;如果使用参数&lt;code&gt;-p0&lt;/code&gt;，那就表示直接用补丁文件中的路径来查找文件(即a/a.txt)来进行patch操作，如果我们在/path/to目录下，我们如下打补丁：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;patch -p0 &amp;lt; a.patch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果使用参数&lt;code&gt;-p1&lt;/code&gt;，那就表示忽略补丁文件中的第一层目录(即a/a.txt中的a)，从当前目录中直接查找a.txt来进行patch操作，如果我们在/path/to/a目录下，我们如下打补丁：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;patch -p1 &amp;lt; a.patch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打好补丁以后，我们来看a.txt文件的内容：&lt;/p&gt;

&lt;p&gt;$ cat a.txt
    a
    d
    c
    f&lt;/p&gt;

&lt;p&gt;以上只是一个小小的demo，复杂的情况还需要去深入研究:)&lt;/p&gt;

&lt;h3&gt;参考：&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Diff&quot;&gt;http://en.wikipedia.org/wiki/Diff&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>使用Awstats分析Nginx日志</title>
   <link href="http://weizhifeng.net/awstats-nginx-log.html"/>
   <updated>2011-03-26T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/awstats-nginx-log</id>
   <content type="html">&lt;h3&gt;前言&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.awstats.org/&quot; title=&quot;awstats&quot;&gt;Awstats&lt;/a&gt;是用Perl开发的，功能强大的服务器日志分析工具，但是默认只支持Apache和IIS，本文介绍下如何用其来分析Nginx日志，并且在Nginx下运行awstats。由于Nginx没有内置的Perl执行能力，我们采用Fastcgi来执行Perl。&lt;/p&gt;

&lt;h3&gt;创建Fastcgi-fpm&lt;/h3&gt;

&lt;p&gt;确保机器上已经安装了&lt;a href=&quot;http://www.perl.com/&quot; title=&quot;Perl&quot;&gt;Perl&lt;/a&gt;和cpan，输入&lt;code&gt;cpan&lt;/code&gt;，然后安装&lt;code&gt;PerlFCGI&lt;/code&gt;    &lt;br/&gt;
和&lt;code&gt;FCGI::ProcManager&lt;/code&gt;两个包：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cpan&amp;gt;install FCGI
$ cpan&amp;gt;install FCGI::ProcManager
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建文件/usr/local/bin/cgiwrap-fcgi.pl，作为Fastcgi-fpm：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wget -O /usr/local/bin/cgiwrap-fcgi.pl https://raw.github.com/gist/3675629/60391f70fe69b53e16831fe44d2bbed4a2026699/cgiwrap-fcgi.pl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;赋予cgiwrap-fcgi.pl执行权限：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ chmod 755 /usr/local/bin/cgiwrap-fcgi.pl
$ mkdir -p /var/run/nginx/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动FPM，Nginx需要对socket有读写权限，否则会报502错误&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ /usr/local/bin/cgiwrap-fcgi.pl &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp;;
$ chown -R www:www /var/run/nginx/cgiwrap-dispatch.sock
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Awstats安装配置&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ cd /usr/local
$ wget http://prdownloads.sourceforge.net/awstats/awstats-7.0.tar.gz
$ tar -zxvf awstats-7.0.tar.gz
$ mv awstats-7.0 awstats
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行&lt;code&gt;/usr/local/awstats/tools/awstats_configure.pl&lt;/code&gt;，进行awstats配置。系统会提示选择日志格式种类，目前awstats默认只支持&lt;code&gt;Apache&lt;/code&gt;和&lt;code&gt;IIS&lt;/code&gt;，由于是Nginx，所以选择&lt;code&gt;none&lt;/code&gt;；按要求输入自己的域名，假设为example.com，那么会在&lt;code&gt;/etc/awstats/&lt;/code&gt;下面生成&lt;code&gt;/etc/awstats/awstats.example.com.conf&lt;/code&gt;的配置文件。&lt;/p&gt;

&lt;p&gt;修改配置文件&lt;code&gt;/etc/awstats/awstats.example.com.conf&lt;/code&gt;，添加如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#指定日志文件位置，因为我们要在凌晨1点分析日志，所以要指定的是前一天的日志文件
LogFile=&quot;/usr/local/nginx/logs/access_%YYYY-0%MM-0%DD-24.log&quot;

#日志格式，需要与Nginx中的日志格式一致
LogFormat=&quot;%host - %time1 %methodurl %code %bytesd %refererquot %uaquot&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建切割日志脚本/usr/local/nginx/sbin/logcron.sh：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
# 日志切割脚本
mv /usr/local/nginx/logs/access.log /usr/local/nginx/logs/access_`date +%Y%m%d`.log
kill -s SIGUSR1 `cat /usr/local/nginx/nginx.pid`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建awstats日志更新脚本/usr/local/nginx/sbin/awstats_up.sh :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
# 更新awstats日志
/usr/local/awstats/wwwroot/cgi-bin/awstats.pl -update -config=example.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加crontab任务，内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#23:59切割nginx日志
59 23 * * * /usr/local/nginx/sbin/logcron.sh

# 1点开始生成awstats统计数据
00 1 * * * /usr/local/nginx/sbin/awstats_up.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;配置Nginx&lt;/h3&gt;

&lt;p&gt;修改Nginx配置/usr/local/nginx/conf/nginx.conf，添加如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#log格式，注意空格，这个格式必须与awstats中的LogFormat一样
log_format  main     '$remote_addr - [$time_local] &quot;$request&quot; '
'$status $body_bytes_sent &quot;$http_referer&quot; '
'&quot;$http_user_agent&quot; $http_x_forwarded_for';

access_log logs/access.log main;

#awstats运行配置
server {
    listen 127.0.0.1:80;
    server_name awstats.com;
    access_log off;
    error_log off;

    root  /usr/local/awstats/wwwroot;
    index index.html;

    location ~ ^/cgi-bin/.*.cgi$ {
        gzip off;
        fastcgi_pass  unix:/var/run/nginx/cgiwrap-dispatch.sock;
        fastcgi_index index.cgi;
        include fastcgi_params;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改Fastcgi配置/usr/local/nginx/conf/fastcgi_params，添加如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fastcgi_param  SCRIPT_FILENAME    $document_root$fastcgi_script_name;
fastcgi_param  QUERY_STRING       $query_string;
fastcgi_param  REQUEST_METHOD     $request_method;
fastcgi_param  CONTENT_TYPE       $content_type;
fastcgi_param  CONTENT_LENGTH     $content_length;

fastcgi_param  SCRIPT_NAME        $fastcgi_script_name;
fastcgi_param  REQUEST_URI        $request_uri;
fastcgi_param  DOCUMENT_URI       $document_uri;
fastcgi_param  DOCUMENT_ROOT      $document_root;
fastcgi_param  SERVER_PROTOCOL    $server_protocol;

fastcgi_param  GATEWAY_INTERFACE  CGI/1.1;
fastcgi_param  SERVER_SOFTWARE    nginx/$nginx_version;
fastcgi_param  REMOTE_ADDR        $remote_addr;
fastcgi_param  REMOTE_PORT        $remote_port;
fastcgi_param  SERVER_ADDR        $server_addr;
fastcgi_param  SERVER_PORT        $server_port;
fastcgi_param  SERVER_NAME        $server_name;

# PHP only, required if PHP was built with --enable-force-cgi-redirect
fastcgi_param  REDIRECT_STATUS    200;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;访问方式：http://example.com/cgi-bin/awstats.pl?config=example.com&lt;/p&gt;

&lt;h3&gt;参考：&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://wiki.nginx.org/NginxSimpleCGI&quot;&gt;http://wiki.nginx.org/NginxSimpleCGI&lt;/a&gt;   &lt;br/&gt;
&lt;a href=&quot;http://5ydycm.blog.51cto.com/115934/140029&quot;&gt;http://5ydycm.blog.51cto.com/115934/140029&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Apache SSL配置</title>
   <link href="http://weizhifeng.net/apache-ssl.html"/>
   <updated>2011-03-26T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/apache-ssl</id>
   <content type="html">&lt;h3&gt;概念&lt;/h3&gt;

&lt;p&gt;开始之前介绍几个SSL相关的概念：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CA(Certification Authority，认证中心)&lt;/li&gt;
&lt;li&gt;SSL (Secure Sockets Layer,安全套接层协议)&lt;/li&gt;
&lt;li&gt;TLS(Transport Layer Security，传输层安全)&lt;/li&gt;
&lt;li&gt;CSR (Certificate Signing Request，证书签名请求)&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;流程&lt;/h3&gt;

&lt;p&gt;需要启用SSL的服务器自己生成CSR，然后让权威的CA进行签名认证或者 自己创建一个CA证书，然后给自己的CSR签名，不过这样的证书不会被浏览器认可。
以下步骤确保已经安装了&lt;a href=&quot;http://www.openssl.org/&quot; title=&quot;open ssl&quot;&gt;openssl&lt;/a&gt;，windows版本的&lt;a href=&quot;http://www.slproweb.com/products/Win32OpenSSL.html&quot;&gt;在这&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;创建一个自签名的CA证书：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;openssl req -x509 -newkey rsa:1024 -keyout ca.key -out ca.crt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成服务器CSR：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;openssl req -newkey rsa:1024 -keyout server.key -out server.csr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不使需要CA证书签名的话，进行如下操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;openssl req -x509 -days 1024 -key server.key -in server.csr &amp;gt; server.crt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果需要用CA证书签名：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;openssl x509 -req -in server.csr -out server.crt -CA ca.crt -CAkey ca.key -CAcreateserial
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看证书：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;openssl x509 -noout -text -in server.crt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;验证证书：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;openssl verify -CAfile ca.crt server.crt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成客户端CSR：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;openssl req -newkey rsa:1024 -keyout client.key -out client.csr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用CA证书签名：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;openssl x509 -req -in client.csr -out client.crt -CA caca.crt -CAkey caca.key -CAcreateserial
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;转换，使证书可以安装到浏览器：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;openssl pkcs12 -export -clcerts -in client.crt -inkey client.key -out client.pfx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改配置文件&lt;code&gt;httpd-ssl.conf&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SSLCertificateFile conf/ssl.crt/server.crt #服务器证书
SSLCertificateKeyFile conf/ssl.key/server.key #服务器私钥
SSLCACertificateFile conf/ssl.crt/ca/ca.crt  #CA证书
SSLVerifyClient require #强制浏览器必须安装了证书才能访问
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;证书链介绍&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;生成Root CA私钥与证书： 生成RootCA私钥 —&gt; 使用私钥生成CSR —&gt; 生成自签名根证书（用来给二级CA证书签名）。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生成二级CA 私钥与证书：（假如有两个二级CA， 分别负责管理服务器端和客户端证书）   &lt;br/&gt;
2.1 生成ServerCA私钥 —&gt; 使用私钥生成CSR —&gt; 使用根证书签名生成二级证书（ServerCA证书用来给服务器证书签名）。    &lt;br/&gt;
2.2 先生成ClientCA私钥 —&gt; 使用私钥生成 CSR—&gt; 使用根证书签名生成二级证书（ClientCA证书用来给客户端证书签名）。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生成服务器端与客户端的私钥与证书：     &lt;br/&gt;
3.1 生成ServerA私钥 —&gt; 使用私钥生成CSR —&gt; 使用ServerCA证书签名生成三级证书（ServerA证书）。    &lt;br/&gt;
3.2 生成ClientA私钥 —&gt; 使用私钥生成 CSR—&gt; 使用ClientCA证书签名生成三级证书（ClientA证书）。     &lt;br/&gt;
3.3 先生成ClientB私钥 —&gt; 使用私钥生成 CSR—&gt; 使用ClientCA证书签名生成三级证书（ClientB证书）。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;...可以生成N个客户端证书&lt;/p&gt;

&lt;h3&gt;证书结构：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;RootCA
|
|-------ServerCA
|          |
|          |--------ServerA
|
|-------ClientCA
            |
            |------- ClientA
            |------- ClientB
            |......
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;参考：&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.shenmiguo.com/archives/2009/284_linux-apache-ssl-guide.html&quot;&gt;http://www.shenmiguo.com/archives/2009/284_linux-apache-ssl-guide.html&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Nginx信号处理与平滑升级</title>
   <link href="http://weizhifeng.net/nginx-signal-processing-and-upgrade.html"/>
   <updated>2011-03-24T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/nginx-signal-processing-and-upgrade</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;http://nginx.org/&quot; title=&quot;Nginx&quot;&gt;Nginx&lt;/a&gt;进程分为&lt;strong&gt;master&lt;/strong&gt;进程和&lt;strong&gt;worker&lt;/strong&gt;进程，我们可以通过信号来控制&lt;strong&gt;master&lt;/strong&gt;进程。默认情况下，Nginx会把它的&lt;strong&gt;master&lt;/strong&gt;进程id写到&lt;code&gt;/usr/local/nginx/logs/nginx.pid&lt;/code&gt;中。你可以在编译的时候通过&lt;code&gt;./configure&lt;/code&gt;来指定，或者在配置文件中用&lt;code&gt;pid&lt;/code&gt;来配置。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Master&lt;/strong&gt;进程能够接收并处理如下的信号：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ERM, INT（快速退出，当前的请求不执行完成就退出）&lt;/li&gt;
&lt;li&gt;QUIT （优雅退出，执行完当前的请求后退出）&lt;/li&gt;
&lt;li&gt;HUP （重新加载配置文件，用新的配置文件启动新worker进程，并优雅的关闭旧的worker进程）&lt;/li&gt;
&lt;li&gt;USR1 （重新打开日志文件）&lt;/li&gt;
&lt;li&gt;USR2 （平滑的升级nginx二进制文件）&lt;/li&gt;
&lt;li&gt;WINCH （优雅的关闭worker进程）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;Worker&lt;/strong&gt;进程也可以接收并处理一些信号：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TERM, INT （快速退出）&lt;/li&gt;
&lt;li&gt;QUIT （优雅退出）&lt;/li&gt;
&lt;li&gt;USR1 （重新打开日志文件）&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;用HUP信号使Nginx加载新的配置文件&lt;/h3&gt;

&lt;p&gt;当Nginx接收到&lt;code&gt;HUP&lt;/code&gt;信号的时候，它会尝试着去解析并应用这个配置文件，如果没有问题，那么它会创建新的&lt;strong&gt;worker&lt;/strong&gt;进程，并发送信号给旧的 &lt;strong&gt;worker&lt;/strong&gt;进程，让其优雅的退出。接收到信号的旧的&lt;strong&gt;worker&lt;/strong&gt;进程会关闭监听&lt;strong&gt;socket&lt;/strong&gt;，但是还会处理当前的请求，处理完请求之后，旧的 &lt;strong&gt;worker&lt;/strong&gt;进程退出。如果Nginx不能够应用新的配置文件，那么仍将用旧的配置文件来提供服务。&lt;/p&gt;

&lt;h3&gt;在线升级Nginx二进制文件&lt;/h3&gt;

&lt;p&gt;当你想升级Nginx到一个新的版本，增加或减少module的时候，你需要替换Nginx的二进制文件，你可以平滑的实现它，没有请求会丢失。&lt;/p&gt;

&lt;p&gt;首先，用新的二进制文件替换掉旧的，然后发送&lt;code&gt;USR2&lt;/code&gt;信号给&lt;strong&gt;master&lt;/strong&gt;进程。&lt;strong&gt;master&lt;/strong&gt;进程会把自己的&lt;strong&gt;.pid&lt;/strong&gt;文件重命名为&lt;strong&gt;.oldbin&lt;/strong&gt;（例 如，&lt;strong&gt;/usr/local/nginx/logs/nginx.pid.oldbin&lt;/strong&gt;），然后执行新的二进制文件，从而启动一个新的&lt;strong&gt;master&lt;/strong&gt;进程和新的&lt;strong&gt;worker&lt;/strong&gt;进程：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; PID  PPID USER    %CPU   VSZ WCHAN  COMMAND
33126     1 root     0.0  1164 pause  nginx: master process /usr/local/nginx/sbin/nginx
33134 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
33135 33126 nobody   0.0  1380 kqread nginx: worker process (nginx)
33136 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
36264 33126 root     0.0  1148 pause  nginx: master process /usr/local/nginx/sbin/nginx
36265 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
36266 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
36267 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个时候，有两个Nginx实例在运行，一起处理进来的请求。为了让旧的实例退出，你需要发送&lt;code&gt;WINCH&lt;/code&gt;信号给旧的&lt;strong&gt;master&lt;/strong&gt;进程，这样旧&lt;strong&gt;master&lt;/strong&gt;进程的&lt;strong&gt;worker&lt;/strong&gt;进程就会优雅的退出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    PID  PPID USER    %CPU   VSZ WCHAN  COMMAND
33126     1 root     0.0  1164 pause  nginx: master process /usr/local/nginx/sbin/nginx
33135 33126 nobody   0.0  1380 kqread nginx: worker process is shutting down (nginx)
36264 33126 root     0.0  1148 pause  nginx: master process /usr/local/nginx/sbin/nginx
36265 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
36266 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
36267 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一段时间后，旧的&lt;strong&gt;worke&lt;/strong&gt;r进程都已经退出了，只有新的&lt;strong&gt;worker&lt;/strong&gt;进程处理进来的请求：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PID  PPID USER    %CPU   VSZ WCHAN  COMMAND
33126     1 root     0.0  1164 pause  nginx: master process /usr/local/nginx/sbin/nginx
36264 33126 root     0.0  1148 pause  nginx: master process /usr/local/nginx/sbin/nginx
36265 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
36266 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
36267 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个时候你仍然可以通过以下几个步骤回滚到旧的服务，因为旧&lt;strong&gt;master&lt;/strong&gt;进程并没有关闭其监听的&lt;strong&gt;socket&lt;/strong&gt;： 发送&lt;code&gt;HUP&lt;/code&gt;信号给旧的&lt;strong&gt;master&lt;/strong&gt;进程，它会启动&lt;strong&gt;worker&lt;/strong&gt;进程并且不需要重新加载配置文件 发送&lt;code&gt;QUIT&lt;/code&gt;信号给新的&lt;strong&gt;master&lt;/strong&gt;进程，让它优雅的终止其&lt;strong&gt;worker&lt;/strong&gt;进程发送&lt;code&gt;TERM&lt;/code&gt;信号给新的&lt;strong&gt;master&lt;/strong&gt;进程，强制其退出 如果一些原因，新的&lt;strong&gt;worker&lt;/strong&gt;进程没有退出，发送&lt;code&gt;KILL&lt;/code&gt;信号给它们 当新的&lt;strong&gt;master&lt;/strong&gt;进程退出之后，旧的&lt;strong&gt;master&lt;/strong&gt;进程会删除其&lt;strong&gt;pid&lt;/strong&gt;文件名中的后缀&lt;strong&gt;.oldbin&lt;/strong&gt;，这样一切就又变成升级之前的样子。 如果一个升级已经成功，然后你想只保留新的server，那么发送&lt;code&gt;QUIT&lt;/code&gt;信号给旧的&lt;strong&gt;master&lt;/strong&gt;进程让新的server来提供服务：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PID  PPID USER    %CPU   VSZ WCHAN  COMMAND
36264     1 root     0.0  1148 pause  nginx: master process /usr/local/nginx/sbin/nginx
36265 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
36266 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
36267 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原文：&lt;a href=&quot;http://wiki.nginx.org/NginxCommandLine&quot;&gt;http://wiki.nginx.org/NginxCommandLine&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>無題</title>
   <link href="http://weizhifeng.net/23230002225.html"/>
   <updated>2011-03-17T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/23230002225</id>
   <content type="html">&lt;p&gt;仰天望長雲  &lt;br/&gt;
朝霞又映春 &lt;br/&gt;
試問梅下客  &lt;br/&gt;
誰人不念親&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>初五歸寧</title>
   <link href="http://weizhifeng.net/23229959420.html"/>
   <updated>2011-02-07T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/23229959420</id>
   <content type="html">&lt;p&gt;極目白與藍  &lt;br/&gt;
浮行在雲端   &lt;br/&gt;
此去一千裏    &lt;br/&gt;
隨風到江南&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>無題</title>
   <link href="http://weizhifeng.net/23229863973.html"/>
   <updated>2011-02-01T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/23229863973</id>
   <content type="html">&lt;p&gt;满城山色映柳湖   &lt;br/&gt;
昨日行人已歧途    &lt;br/&gt;
问君此时心何往    &lt;br/&gt;
一轮冰月水中浮&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>秋夜難眠</title>
   <link href="http://weizhifeng.net/23230772891.html"/>
   <updated>2010-10-28T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/23230772891</id>
   <content type="html">&lt;p&gt;冷月沈暮雲   &lt;br/&gt;
秋風夜已深  &lt;br/&gt;
起身望窗外  &lt;br/&gt;
路有夜歸人&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>秋別</title>
   <link href="http://weizhifeng.net/23230717656.html"/>
   <updated>2010-08-29T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/23230717656</id>
   <content type="html">&lt;p&gt;清晨初雨濕秋花    &lt;br/&gt;
秦淮綠水繞人家  &lt;br/&gt;
再走一次長江路   &lt;br/&gt;
明日又要奔天涯&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>七夕夜</title>
   <link href="http://weizhifeng.net/23230744739.html"/>
   <updated>2010-08-16T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/23230744739</id>
   <content type="html">&lt;p&gt;遠山掛玉盤&lt;br/&gt;
燈火棲水岸&lt;br/&gt;
今夜堤柳下&lt;br/&gt;
共賞秋月圓&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>遊高淳</title>
   <link href="http://weizhifeng.net/23230684030.html"/>
   <updated>2010-04-05T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/23230684030</id>
   <content type="html">&lt;p&gt;春風剪柳遍野黃    &lt;br/&gt;
桃與百花共爭芳     &lt;br/&gt;
半卷春色初展開    &lt;br/&gt;
一抹青水入農鄉&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>憶江南</title>
   <link href="http://weizhifeng.net/23230644042.html"/>
   <updated>2010-03-14T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/23230644042</id>
   <content type="html">&lt;p&gt;金陵春 &lt;br/&gt;
晨靄隨風度  &lt;br/&gt;
心巧慧靈昨日事   &lt;br/&gt;
小樓望斷今朝霧    &lt;br/&gt;
梅語西窗佇&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>游朝天宮</title>
   <link href="http://weizhifeng.net/23230618486.html"/>
   <updated>2010-03-07T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/23230618486</id>
   <content type="html">&lt;p&gt;青竹石路三月寒   &lt;br/&gt;
朱墻金瓦梅紅衫  &lt;br/&gt;
流水不戀半岸春 &lt;br/&gt;
逶迤帶綠盡江天&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>感春</title>
   <link href="http://weizhifeng.net/23231056547.html"/>
   <updated>2010-02-28T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/23231056547</id>
   <content type="html">&lt;p&gt;雨細風疏與梅約   &lt;br/&gt;
桃紅柳綠樓吻月   &lt;br/&gt;
又到一年春歸時   &lt;br/&gt;
青踏秦淮念舊雪&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>無題</title>
   <link href="http://weizhifeng.net/23231012368.html"/>
   <updated>2010-02-02T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/23231012368</id>
   <content type="html">&lt;p&gt;暖晨輕霧漸濕花   &lt;br/&gt;
小橋溪水過人家  &lt;br/&gt;
坐看雲海影成雙  &lt;br/&gt;
脈脈水岸夕陽斜&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>冬游石城</title>
   <link href="http://weizhifeng.net/23230970645.html"/>
   <updated>2010-01-10T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/23230970645</id>
   <content type="html">&lt;p&gt;虎踞之地謂石城  &lt;br/&gt;
綿延七裏宛如龍  &lt;br/&gt;
碧波夕照映柳斜 &lt;br/&gt;
倚欄獨立秦淮東&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>冬至</title>
   <link href="http://weizhifeng.net/23230991719.html"/>
   <updated>2009-12-22T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/23230991719</id>
   <content type="html">&lt;p&gt;薄霧枯樹月半彎  &lt;br/&gt;
冬至滿城盡飛煙  &lt;br/&gt;
道旁多見祭祖者  &lt;br/&gt;
掩面獨泣霜漫天&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>读宋</title>
   <link href="http://weizhifeng.net/23230946869.html"/>
   <updated>2009-12-20T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/23230946869</id>
   <content type="html">&lt;p&gt;北宋富庶如夢裏  &lt;br/&gt;
女真難拒烽煙起  &lt;br/&gt;
徽宗不識亡國難  &lt;br/&gt;
獨戀園林瘦金體&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>長干里</title>
   <link href="http://weizhifeng.net/23230923912.html"/>
   <updated>2009-12-13T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/23230923912</id>
   <content type="html">&lt;p&gt;青寂石路鋪落葉  &lt;br/&gt;
十裏古墻難飛鵲  &lt;br/&gt;
燈火昏黃近冬暮   &lt;br/&gt;
秦淮水岸待明月&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>夜思</title>
   <link href="http://weizhifeng.net/23230900989.html"/>
   <updated>2009-09-26T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/23230900989</id>
   <content type="html">&lt;p&gt;清夜淺雲半月樓  &lt;br/&gt;
燈火車潮近中秋  &lt;br/&gt;
繁華似錦夜都市  &lt;br/&gt;
能有幾處百姓留&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>登臺城</title>
   <link href="http://weizhifeng.net/23230874249.html"/>
   <updated>2009-09-06T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/23230874249</id>
   <content type="html">&lt;p&gt;獨上臺城觀湖柳   &lt;br/&gt;
遊人似酌月下酒  &lt;br/&gt;
問君哪得飄桂香  &lt;br/&gt;
只緣時節近中秋&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>玄武湖初秋</title>
   <link href="http://weizhifeng.net/23231034092.html"/>
   <updated>2009-09-01T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/23231034092</id>
   <content type="html">&lt;p&gt;清波粼粼蟬鳴柳   &lt;br/&gt;
湖面向晚泛遠舟 &lt;br/&gt;
昨日黃昏今日路 &lt;br/&gt;
秋風已上柳梢頭&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>白鷺洲</title>
   <link href="http://weizhifeng.net/23230836212.html"/>
   <updated>2009-07-25T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/23230836212</id>
   <content type="html">&lt;p&gt;綠水石橋秦淮柳  &lt;br/&gt;
低樓古曲水泊舟  &lt;br/&gt;
人間何處尋此景  &lt;br/&gt;
太白詩詠白鷺洲&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>游燕子嘰</title>
   <link href="http://weizhifeng.net/24127916196.html"/>
   <updated>2009-07-12T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/24127916196</id>
   <content type="html">&lt;p&gt;獨臨瀾亭江風吹  &lt;br/&gt;
花沁芬香引蝶追  &lt;br/&gt;
燕磯夕照今猶在  &lt;br/&gt;
最是難留長江水&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>遊明文化村</title>
   <link href="http://weizhifeng.net/24127935877.html"/>
   <updated>2009-06-21T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/24127935877</id>
   <content type="html">&lt;p&gt;青山鳥鳴綠柳揚  &lt;br/&gt;
和風水暈遠亭妝  &lt;br/&gt;
前朝朱閣轉何方  &lt;br/&gt;
今世夢醒桂花窗&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>莫愁湖</title>
   <link href="http://weizhifeng.net/24128664948.html"/>
   <updated>2009-05-30T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/24128664948</id>
   <content type="html">&lt;p&gt;五月荷風魚水弄  &lt;br/&gt;
石橋池邊花意重  &lt;br/&gt;
莫愁湖畔散幽曲  &lt;br/&gt;
愁人愁事愁東風&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>醉秦淮</title>
   <link href="http://weizhifeng.net/24127954861.html"/>
   <updated>2009-05-03T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/24127954861</id>
   <content type="html">&lt;p&gt;獨憑朱欄水暈黃 &lt;br/&gt;
風搖酒旗飄盡香  &lt;br/&gt;
畫舟行水歌滿樓  &lt;br/&gt;
單櫓輕擺映斜陽&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>送孫亮歸廬州</title>
   <link href="http://weizhifeng.net/24127972941.html"/>
   <updated>2009-04-05T00:00:00+08:00</updated>
   <id>http://weizhifeng.net/24127972941</id>
   <content type="html">&lt;p&gt;二月淺春柳隨風  &lt;br/&gt;
玄武水岸花正紅  &lt;br/&gt;
今朝與君暫別離  &lt;br/&gt;
他日共賞黃山峰&lt;/p&gt;
</content>
 </entry>
 
 
</feed>