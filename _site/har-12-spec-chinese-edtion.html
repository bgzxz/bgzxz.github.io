<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8" />
   <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
   <meta name="apple-mobile-web-app-capable" content="yes" />
   <meta name="apple-mobile-web-app-status-bar-style" content="black" />
   <!-- <link rel="apple-touch-icon" href="http://s0-weizhifeng-net.b0.upaiyun.com/touch-icon-iphone.png" /> -->
   <link rel="apple-touch-icon-precomposed" href="http://s0-weizhifeng-net.b0.upaiyun.com/touch-icon-iphone-precomposed.png" />
   <link rel="apple-touch-icon" sizes="72x72" href="http://s0-weizhifeng-net.b0.upaiyun.com/touch-icon-ipad.png" />
   <link rel="apple-touch-icon" sizes="114x114" href="http://s0-weizhifeng-net.b0.upaiyun.com/touch-icon-iphone-retina.png" />
   <link rel="apple-touch-icon" sizes="144x144" href="http://s0-weizhifeng-net.b0.upaiyun.com/touch-icon-ipad-retina.png" />
   
   <title>HAR(HTTP Archive)规范</title>
   <meta name="author" content="Jeremy Wei" />
   <link href="http://feeds.feedburner.com/JeremyWei" rel="alternate" title="Jeremy Wei" type="application/atom+xml" />
   <link rel="shortcut icon" type="image/x-icon" href="http://s0-weizhifeng-net.b0.upaiyun.com/favicon.ico">
   
   <!-- syntax highlighting CSS -->
   <link rel="stylesheet" href="http://s0-weizhifeng-net.b0.upaiyun.com/css/syntax.css?20130623" type="text/css" />
   
   <!-- Homepage CSS -->
   <link rel="stylesheet" href="http://s0-weizhifeng-net.b0.upaiyun.com/css/screen.css?20130721v1" type="text/css" media="screen, projection" />
   <!-- <link rel="stylesheet" href="/css/screen.css?072122" type="text/css" media="screen, projection" /> -->
   
   <script type="text/javascript" charset="utf-8">
   // Mobile Safari in standalone mode
   if(("standalone" in window.navigator) && window.navigator.standalone){
	   
   	// If you want to prevent remote links in standalone web apps opening Mobile Safari, change 'remotes' to true
   	var noddy, remotes = true;
	
   	document.addEventListener('click', function(event) {
		
   		noddy = event.target;
		
   		// Bubble up until we hit link or top HTML element. Warning: BODY element is not compulsory so better to stop on HTML
   		while(noddy.nodeName !== "A" && noddy.nodeName !== "HTML") {
   	        noddy = noddy.parentNode;
   	    }
		
   		if('href' in noddy && noddy.href.indexOf('http') !== -1 && (noddy.href.indexOf(document.location.host) !== -1 || remotes))
   		{
   			event.preventDefault();
   			document.location.href = noddy.href;
   		}
	
   	},false);
   }
   </script>
</head>
<body>
	
<div class="site">
  <pre class="nav margin-for-mobile">{"<a href='/tech.html'>文</a>", "<a href='/translate.html'>譯</a>", "<a href='/poem.html'>詩</a>", "<a href='/5000years.html'>國史</a>", "<a href='/resume.html'>己</a>"}</pre>
  <br />
  <div id="post">
	<h1>HAR(HTTP Archive)规范</h1>
	<div class="copyright">
	作者: JeremyWei | 可以转载, 但必须以超链接形式标明文章原始出处和作者信息及版权声明<br />
	网址: http://weizhifeng.net/har-12-spec-chinese-edtion.html
	</div>

	<p><a href="http://www.softwareishard.com/blog/har-12-spec/" title="har-12-spec">HAR</a>（HTTP Archive），是一个用来储存HTTP请求/响应信息的通用文件格式，基于<a href="http://www.ietf.org/rfc/rfc4627.txt" title="JSON">JSON</a>。这个格式的出现可以使HTTP监测工具以一种通用的格式导出所收集的数据，这些数据可以被其他支持HAR的HTTP<a href="http://www.softwareishard.com/blog/har-adopters/" title="分析工具">分析工具</a>（包括<a href="http://getfirebug.com/" title="Firebug">Firebug</a>，<a href="http://www.httpwatch.com/" title="httpwatch">httpwatch</a>，<a href="http://www.fiddler2.com/fiddler2/" title="Fiddler">Fiddler</a>等）所使用，来分析网站的性能瓶颈。目前HAR规范最新版本为<a href="http://www.softwareishard.com/blog/har-12-spec/" title="har-12-spec">HAR 1.2</a>。HAR文件必须是UTF-8编码，有无BOM无所谓。</p>

<h3>HAR数据结构：</h3>

<p>一个HAR文件就是一个JSON对象，如下：</p>

<pre><code>{
    "log": {
        "version" : "1.2",
        "creator" : {},
        "browser" : {},
        "pages": [],
        "entries": [],
        "comment": ""
    }
}
</code></pre>

<ul>
<li>version [string] – 版本，默认为1.1。</li>
<li>creator [object] – 创建HAR文件的程序名称和版本信息。</li>
<li>browser [object, 可选] – 浏览器的名称和版本信息。</li>
<li>pages [array, 可选] – 页面列表，如果应用不支持按照page分组，可以省去此字段。</li>
<li>entries [array] – 所有HTTP请求的列表。</li>
<li>comment [string, 可选]（new in 1.2） – 注释。</li>
</ul>


<p>注：每个页面对应一个 对象，每个HTTP请求对应一个对象。如果HTTP的监测分析工具不能把请求按照page分组，那么为空。</p>

<h3>&lt;creator&gt; &amp; &lt;browser&gt;</h3>

<p>这两个对象的结构是一样的</p>

<pre><code>"creator": {
    "name": "Firebug",
    "version": "1.6",
    "comment": "",
}

"browser": {
    "name": "Firefox",
    "version": "3.6",
    "comment": ""
}
</code></pre>

<ul>
<li>name [string] – HAR生成工具或者浏览器的名称。</li>
<li>version [string] – HAR生成工具或者浏览器的版本。</li>
<li>comment [string, 可选]（new in 1.2） – 注释。</li>
</ul>


<h3>&lt;pages&gt;</h3>

<p>这个对象保存了页面列表，格式如下：</p>

<pre><code>"pages": [
    {
        "startedDateTime": "2009-04-16T12:07:25.123+01:00",
        "id": "page_0",
        "title": "Test Page",
        "pageTimings": {...},
        "comment": ""
    }
]
</code></pre>

<ul>
<li>startedDateTime [string] – 页面开始加载的时间(格式ISO 8601 – YYYY-MM-DDThh:mm:ss.sTZD, 例如2009-07-24T19:20:30.45+01:00)。</li>
<li>id [string] – page的唯一标示，entry会用到这个id来和page关联在一起。</li>
<li>title [string] – 页面标题。</li>
<li>pageTimings[object] – 页面加载过程中详细的时间信息。</li>
<li>comment [string, 可选]（new in 1.2） – 注释。</li>
</ul>


<h3>&lt;pageTimings&gt;</h3>

<p>这个对象描述了在页面加载过程中各个事件发生的时间点。所有的时间都是以毫秒计算的。如果有的时间无法计算出来，那么相应字段置为-1。</p>

<pre><code>"pageTimings": [
    {
        "onContentLoad": 1720,
        "onLoad": 2500,
        "comment": ""
    }
]
</code></pre>

<ul>
<li>onContentLoad [number, 可选] – 页面内容加载时间，相对于页面开始加载时间的毫秒数（page.startedDateTime）。如果时间不适用于当前的请求，那么置为-1。</li>
<li>onLoad [number,可选] – 页面加载时间（即onLoad事件触发的时间）。相对于页面开始加载时间的毫秒数（page.startedDateTime）。如果时间不适用于当前的请求，那么置为-1。</li>
<li>comment [string, 可选]（new in 1.2） – 注释。</li>
</ul>


<p>由于不同浏览器实现不一样，onContentLoad属性可能代表<strong>DOMContentLoad</strong>事件触发，也可能代表document.readyState等于<strong>interactive</strong>。</p>

<h3>&lt;entries&gt;</h3>

<p>这个对象包含了一个数组，数组中每个元素的内容就是一个HTTP请求的相应信息。用startedDateTime来排序的话可以加快数据导出的速度。HAR分析工具要确保此数组是按照startedDateTime排序的。</p>

<pre><code>"entries": [
    {
        "pageref": "page_0",
        "startedDateTime": "2009-04-16T12:07:23.596Z",
        "time": 50,
        "request": {...},
        "response": {...},
        "cache": {...},
        "timings": {},
        "serverIPAddress": "10.0.0.1",
        "connection": "52492",
        "comment": ""
    }
]
</code></pre>

<ul>
<li>pageref [string, unique, 可选] – 页面id，如果不支持按照page分组，那么字段为空。</li>
<li>startedDateTime [string] – 请求开始时间 (格式ISO 8601 – YYYY-MM-DDThh:mm:ss.sTZD)。</li>
<li>time [number] – 请求消耗的时间，以毫秒为单位。这个值是timings对象中所有可用(值不为-1) timing的和。</li>
<li>request [object] – 请求的详细信息。</li>
<li>response [object] – 响应的详细信息。</li>
<li>cache [object] – 缓存使用情况的信息。</li>
<li>timings [object] – 请求/响应过程（round trip）的详细时间信息。</li>
<li>serverIPAddress [string, 可选]（new in 1.2） – 服务器IP地址。</li>
<li>connection [string, 可选]（new in 1.2）– TCP/IP连接的唯一标示。 如果程序不支持，直接忽略此字段。</li>
<li>comment [string, optional]（new in 1.2） – 注释。</li>
</ul>


<h3>&lt;request&gt;</h3>

<p>这个对象包含了请求的详细信息</p>

<pre><code>"request": {
    "method": "GET",
    "url": "http://www.example.com/path/?param=value",
    "httpVersion": "HTTP/1.1",
    "cookies": [],
    "headers": [],
    "queryString" : [],
    "postData" : {},
    "headersSize" : 150,
    "bodySize" : 0,
    "comment" : "",
}
</code></pre>

<ul>
<li>method [string] – 请求方法(GET，POST，...)。</li>
<li>url [string] – 请求的绝对URL(fragments are not included)。</li>
<li>httpVersion [string] – 请求HTTP版本。</li>
<li>cookies [array] – cookie列表。</li>
<li>headers [array] – header列表。</li>
<li>queryString [object] – 查询字符串信息。</li>
<li>postData [object, 可选] – Post数据信息。</li>
<li>headersSize [number] – HTTP请求头的字节数。如果不可用，设置为-1。</li>
<li>bodySize [number] – 请求body字节数（POST数据）。如果不可用，设置为-1。</li>
<li>comment [string, 可选]（new in 1.2）– 注释。</li>
</ul>


<h3>&lt;response&gt;</h3>

<p>这个对象包含响应的详细信息。</p>

<pre><code>"response": {
    "status": 200,
    "statusText": "OK",
    "httpVersion": "HTTP/1.1",
    "cookies": [],
    "headers": [],
    "content": {},
    "redirectURL": ",
    "headersSize" : 160,
    "bodySize" : 850,
    "comment" : ""
}
</code></pre>

<ul>
<li>status [number] – 响应状态。</li>
<li>statusText [string] – 响应状态描述。</li>
<li>httpVersion [string] – HTTP版本。</li>
<li>cookies [array] – cookie列表。</li>
<li>headers [array] – header列表。</li>
<li>content [object] – 响应内容的详细信息。</li>
<li>redirectURL [string] – Location响应头中的重定向URL。</li>
<li>headersSize [number]*  – HTTP请求头的字节数。如果不可用，设置为-1。</li>
<li>bodySize [number] – 接收的body字节数。如果响应来自缓存(304)，那么设置为0。如果不可用，设置为-1。</li>
<li>comment [string, optional]（new in 1.2） – 注释。
注：headersSize – 响应头大小只对从服务器接收到的header进行计算。被浏览器加上的header不计算在内，但是会加在header列表中。</li>
</ul>


<h3>&lt;cookies&gt;</h3>

<p>这个对象包含了所有的cookie（在和中被使用）。</p>

<pre><code>"cookies": [
    {
        "name": "TestCookie",
        "value": "Cookie Value",
        "path": "/",
        "domain": "www.janodvarko.cz",
        "expires": "2009-07-24T19:20:30.123+02:00",
        "httpOnly": false,
        "secure": false,
        "comment": "",
    }
]
</code></pre>

<ul>
<li>name [string] – cookie名称。</li>
<li>value [string] – cookie值。</li>
<li>path [string, 可选] – cookie Path。</li>
<li>domain [string, 可选] – cookie域名。</li>
<li>expires [string, 可选] – cookie过期时间。(格式ISO 8601 – YYYY-MM-DDThh:mm:ss.sTZD, 例如2009-07-24T19:20:30.123+02:00)。</li>
<li>httpOnly [boolean, 可选] – 如果cookie只是在HTTP下有效，此值设置为true，否则设置为false。</li>
<li>secure [boolean, 可选]（new in 1.2） – 如果cookie通过ssl传送，此值设置为true，否则设置为false。</li>
<li>comment [string, 可选]（new in 1.2） – 注释。</li>
</ul>


<h3>&lt;headers&gt;</h3>

<p>这个对象包含了所有的header（可以在<strong>lt;request&gt;</strong>and<strong>&lt;response&gt;</strong>中使用）</p>

<pre><code>"headers": [
    {
        "name": "Accept-Encoding",
        "value": "gzip,deflate",
        "comment": ""
    },

    {
        "name": "Accept-Language",
        "value": "en-us,en;q=0.5",
        "comment": ""
    }
]
</code></pre>

<h3>&lt;queryString&gt;</h3>

<p>这个对象包含了查询字符串中所有的paramter-value对（嵌在对象中）。</p>

<pre><code>"queryString": [
    {
        "name": "param1",
        "value": "value1",
        "comment": ""
    },

    {
        "name": "param1",
        "value": "value1",
        "comment": ""
    }
]
</code></pre>

<h3>&lt;postData&gt;</h3>

<p>这个对象描述了POST的数据（嵌在对象中）</p>

<pre><code>"postData": {
    "mimeType": "multipart/form-data",
    "params": [],
    "text" : "plain posted data",
    "comment": ""
}
</code></pre>

<ul>
<li>mimeType [string] – POST数据的MIME类型。</li>
<li>params [array] – POST参数列表 (in case of URL encoded parameters)。</li>
<li>text [string] – POST数据的纯文本形式(Plain text posted data)。</li>
<li>comment [string, optional]（new in 1.2） – 注释。
注意：text和params字段是互斥的。</li>
</ul>


<h3>&lt;params&gt;</h3>

<p>POST请求参数列表（嵌在 对象中）</p>

<pre><code>"params": [
    {
        "name": "paramName",
        "value": "paramValue",
        "fileName": "example.pdf",
        "contentType": "application/pdf",
        "comment": ""
    }
]
</code></pre>

<ul>
<li>name [string] – POST参数名。</li>
<li>value [string, 可选] – POST参数的值，或者POST文件的内容。</li>
<li>fileName [string, 可选] – POST文件的文件名。</li>
<li>contentType [string, 可选] – POST文件的类型。</li>
<li>comment [string, 可选]（new in 1.2） – 注释。</li>
</ul>


<h3>&lt;content&gt;</h3>

<p>这个对象描述了响应内容的详细情况（嵌在 对象中）</p>

<pre><code>"content": {
    "size": 33,
    "compression": 0,
    "mimeType": "text/html; charset="utf-8",
    "text": "n",
    "comment": ""
}
</code></pre>

<ul>
<li>size [number] – 返回内容的字节数。如果内容没有被压缩，应该和response.bodySize相等；如果被压缩，那么会大于response.bodySize。</li>
<li>compression [number, 可选] – 节省的字节数。如果无法提供此信息，则忽略此字段。</li>
<li>mimeType [string] – 响应文本的MIME类型 (Content-Type响应头的值)。MIMIE类型的字符集也包含在内。</li>
<li>text [string, 可选] – 从服务器返回的响应body或者从浏览器缓存加载的内容。这个字段只能用文本型的内容来填充。字段内容可以是HTTP decoded(decompressed &amp; unchunked)的文本，或者是经编码（例如，base64）过的响应内容。如果信息不可用，忽略此字段。</li>
<li>encoding [string, 可选]（new in 1.2） – 响应内容的编码格式，例如”base64″。如果text字段的内容是经过了HTTP解码(decompressed &amp; unchunked)的，那么忽略此字段。</li>
<li>comment [string, optional]（new in 1.2） – 注释。</li>
</ul>


<p>在设置text字段之前，HTTP响应内容已经完成了解码(decompressed &amp; unchunked)，然后把原始字符编码转换成UTF-8。字段内容同样可以使用base64进行编码，但是HAR工具必须有解码base64的能力。对字段编码还可以把二进制内容包含进HAR文件中。</p>

<p>这有另一个例子，原始响应内容是：</p>

<pre><code>"content": {
    "size": 33,
    "compression": 0,
    "mimeType": "text/html; charset="utf-8",
    "text": "PGh0bWw+PGhlYWQ+PC9oZWFkPjxib2R5Lz48L2h0bWw+XG4=",
    "encoding": "base64",
    "comment": ""
}
</code></pre>

<h3>&lt;cache&gt;</h3>

<p>这个对象包含了命中的浏览器缓存信息</p>

<pre><code>"cache": {
    "beforeRequest": {},
    "afterRequest": {},
    "comment": ""
}
</code></pre>

<ul>
<li>beforeRequest [object, 可选] – 在请求之前缓存的状态。如果信息不可用，可以忽略此字段。</li>
<li>afterRequest [object, 可选] – 在请求之后缓存的状态。 如果信息不可用，可以忽略此字段。</li>
<li>comment [string, 可选]（new in 1.2） – 注释。</li>
</ul>


<p>如果缓存信息为空，那么对象如下（或者也可以直接删掉cache这个字段）：</p>

<pre><code>"cache": {}
</code></pre>

<p>如果在请求之前，缓存信息不可用，并且在请求之后也没有对内容进行缓存，那么对象如下：</p>

<pre><code>"cache": {
    "afterRequest": null
}
</code></pre>

<p>如果在请求前后都没有缓存存在，那么对象如下：</p>

<pre><code>"cache": {
    "beforeRequest": null,
    "afterRequest": null
}
</code></pre>

<p>以下对象表示请求之前没有缓存，但是在请求后，下载的内容被存在了本地缓存中。</p>

<pre><code>"cache": {
    "beforeRequest": null,
    "afterRequest": {
        "expires": "2009-04-16T15:50:36",
        "lastAccess": "2009-16-02T15:50:34",
        "eTag": ",
        "hitCount": 0,
        "comment": ""
    }
}
</code></pre>

<p>beforeRequest和afterRequest对象使用以下相同的结构：</p>

<pre><code>"beforeRequest": {
    "expires": "2009-04-16T15:50:36",
    "lastAccess": "2009-16-02T15:50:34",
    "eTag": ",
    "hitCount": 0,
    "comment": "“”
}
</code></pre>

<ul>
<li>expires [string, 可选] – 缓存过期时间。</li>
<li>lastAccess [string] – 缓存最后被访问的时间。</li>
<li>eTag [string] – Etag</li>
<li>hitCount [number] – 缓存被访问的次数。</li>
<li>comment [string, 可选]（new in 1.2） – 注释</li>
</ul>


<h3>&lt;timings&gt;</h3>

<p>这个对象描述了请求/响应过程的各个阶段。时间都是以毫秒为单位。</p>

<pre><code>"timings": {
    "blocked": 0,
    "dns": -1,
    "connect": 15,
    "send": 20,
    "wait": 38,
    "receive": 12,
    "ssl": -1,
    "comment": ""
}
</code></pre>

<ul>
<li>blocked [number, 可选] – 建立网络连接时在队列里边等待的时间。如果时间对于当前请求不可用，置为-1。</li>
<li>dns [number, 可选] – DNS查询时间。如果时间对于当前请求不可用，置为-1。</li>
<li>connect [number, 可选] – 建立TCP连接所需的时间。如果时间对于当前请求不可用，置为-1。</li>
<li>send [number] – 发送HTTP请求到服务器所需的时间。</li>
<li>wait [number] – 等待服务器返回响应的时间。</li>
<li>receive [number] – 接收服务器响应（或者缓存）所需时间。</li>
<li>ssl [number, 可选]（new in 1.2） – SSL/TLS验证花费时间。如果这个字段被定义了，那么这个时间也会被包含进connect字段中(为了向后兼容HAR1.1)。如果时间对于当前请求不可用，置为-1。</li>
<li>comment [string, 可选]（new in 1.2） – 注释。</li>
</ul>


<p><strong>send</strong>，<strong>wait</strong>，<strong>receive</strong>时间是必须提供的，并且不能为负数。导出工具如果不能提供blocked,dns,connect和ssl等时间，那么这些时间可以被忽略。如果工具可以提供这些时间，但是不适用的话，可以把这些值设置为-1。 例如，当请求使用了一个存在的连接，connect会被置为-1。</p>

<p>一个请求所花的时间等于这些时间的和，不包括值为-1的。   <br/>
<strong>entry.time == entry.timings.blocked + entry.timings.dns + entry.timings.connect + entry.timings.send + entry.timings.wait + entry.timings.receive</strong></p>

<h3>自定义字段</h3>

<p>HAR规范允许自定义字段，但是要遵循如下规则：</p>

<ul>
<li>自定义字段（field）和元素（element）必须以下划线开头(规范中的字段必须不能以下划线开头)</li>
<li>HAR工具必须忽略所有自定义字段和元素，如果这个HAR文件不是当前HAR工具生成的。</li>
<li>当HAR工具不知道如何解析非自定义字段的时候，忽略它们。</li>
<li>当文件包含了已经被废弃的非自定义字段时候，HAR工具可以拒绝解析此文件。</li>
</ul>


<h3>版本格式</h3>

<p>HAR规范的版本号有如下规则：
&lt;主版本号>.&lt;副版本号>
主版本号表示规范的向后兼容性，副版本号表示增量修改。所以，任何向后兼容的修改都会增加副版本号。如果一个存在的字段被废弃了，那么主版本号要增加(例如2.0)。</p>

<p>Examples:
1.2 -> 1.3(向后兼容)    <br/>
1.111 -> 1.112 (向后兼容)    <br/>
1.5 -> 2.0 (2.0不兼容1.5)     <br/>
如果HAR工具只支持HAR1.1，那么以下的代码可以被用来检测不被兼容的版本。</p>

<pre><code>if (majorVersion != 1 || minorVersion &lt; 1)
{
    throw “Incompatible version”;
}
</code></pre>

<p>这个例子中，如果被解析文件的版本为0.8,0.9,1.0等，那么工具会抛出异常，但是1.1, 1.2, 1.112等版本可以被解析。2.x版本直接拒绝解析。</p>

<p>原文：<a href="http://www.softwareishard.com/blog/har-12-spec/">http://www.softwareishard.com/blog/har-12-spec/</a>  <br/>
Google Group: <a href="http://groups.google.com/group/http-archive-specification">http://groups.google.com/group/http-archive-specification【需翻墙】</a></p>

	(完)

	<div class="post-info">
		26 Mar 2011  
	
		
	
		
	</div>
	
	<!-- disqus start -->
	<div id="disqus_thread"></div>
	<script type="text/javascript">
	    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
	    var disqus_shortname = 'jeremywei'; // required: replace example with your forum shortname

	    /* * * DON'T EDIT BELOW THIS LINE * * */
	    (function() {
	        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
	        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	    })();
	</script>
	<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
	<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
	<!-- disqus end -->

	<!-- related start -->
	<div id="related">
	  <h2>相关内容</h2>
	  <ul class="posts">
	    
	      <li><span>21 Jul 2013</span> &raquo; <a href="/viewports.html">两个viewport的故事（第一部分）</a></li>
	    
	      <li><span>14 Jul 2013</span> &raquo; <a href="/a-pixel-is-not.html">不是像素的像素不是像素</a></li>
	    
	      <li><span>06 Jul 2013</span> &raquo; <a href="/make-web-app-more-native.html">把你的网站改造成一个iOS Web App</a></li>
	    
	      <li><span>06 Jul 2013</span> &raquo; <a href="/cross-browser-inline-block.html">跨浏览器的Inline-Block</a></li>
	    
	      <li><span>30 Jun 2013</span> &raquo; <a href="/css-underscore-hack.html">The Underscore Hack</a></li>
	    
	  </ul>
	</div>
	<!-- related end -->
</div>
  
<div class="footer"></div>
<div class="power">  
  Powered by <a href="http://github.com/" targe="_blank">Github</a> &nbsp;&amp;&amp;&nbsp; <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> 
</div>
</div>

<a href="http://github.com/jeremywei" target="_blank">
	<img class="right-banner first" src="http://s0-weizhifeng-net.b0.upaiyun.com/images/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub" />
</a>

<a href="http://www.phptherightway.com" target="_blank">
    <img class="right-banner second" src="http://s0-weizhifeng-net.b0.upaiyun.com/images/php-the-right-way-120x60.png" alt="PHP: The Right Way"/>
</a>
</body>

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-5179718-7']);
  _gaq.push(['_setDomainName', 'weizhifeng.net']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</html>
