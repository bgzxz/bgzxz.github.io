<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bgzxz&#39;s Blog</title>
    <link>https://bgzxz.github.io/</link>
    <description>Recent content on bgzxz&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <managingEditor>bgzxz1987@email.com (bgzxz)</managingEditor>
    <webMaster>bgzxz1987@email.com (bgzxz)</webMaster>
    <lastBuildDate>Fri, 24 May 2019 20:11:54 +0800</lastBuildDate>
    
	<atom:link href="https://bgzxz.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>使用nginx和keepalived构建高可用websocket</title>
      <link>https://bgzxz.github.io/posts/build_highly_available_websockets_using_nginx_and_keepalived/</link>
      <pubDate>Fri, 24 May 2019 20:11:54 +0800</pubDate>
      <author>bgzxz1987@email.com (bgzxz)</author>
      <guid>https://bgzxz.github.io/posts/build_highly_available_websockets_using_nginx_and_keepalived/</guid>
      <description>背景： 日常项目中的消息推送，im等需求会使用到websocket，项目对于高可用和扩展性要求比较高的时候就必须使用一些HA和负载均衡方案，本文将基于keepalived和nginx构建高可用websocket部署。
部署架构图： 软件配置： server1：
keepalived配置
global_defs { } vrrp_script chk_nginx { script &amp;#34;killall -0 nginx&amp;#34; # cheaper than pidof interval 2 # check every 2 seconds } vrrp_instance VI_1 { state BACKUP interface enp0s3 virtual_router_id 51 priority 50 advert_int 1 virtual_ipaddress { 192.168.1.110 } track_script { chk_nginx } } vrrp_instance VI_2 { state MASTER interface enp0s3 virtual_router_id 52 priority 100 advert_int 1 virtual_ipaddress { 192.168.1.112 } track_script { chk_nginx } }  nginx配置：</description>
    </item>
    
    <item>
      <title>nginx限流</title>
      <link>https://bgzxz.github.io/posts/nginx_limit_req/</link>
      <pubDate>Wed, 22 May 2019 20:31:34 +0800</pubDate>
      <author>bgzxz1987@email.com (bgzxz)</author>
      <guid>https://bgzxz.github.io/posts/nginx_limit_req/</guid>
      <description>配置： http { limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s; server { location /search/ { limit_req zone=one burst=5; limit_req_log_level error; limit_req_status 429; } error_page 429 /429.html; } }
配置指令含义：
limit_req_zone key zone=name:size rate=rate; 配置根据key来限制请求速率 limit_req zone=one burst=5; 设置限流使用的zone和爆发数 limit_req_log_level 设置被限流的请求的日志纪录级别 limit_req_status 设置被限流请求的状态相应码</description>
    </item>
    
    <item>
      <title>redis cluster环境搭建</title>
      <link>https://bgzxz.github.io/posts/redis-cluster/</link>
      <pubDate>Tue, 21 May 2019 20:31:34 +0800</pubDate>
      <author>bgzxz1987@email.com (bgzxz)</author>
      <guid>https://bgzxz.github.io/posts/redis-cluster/</guid>
      <description>redis cluster是什么？ 官网解答
如何搭建集群环境？ 1.官网下载源码 wget http://download.redis.io/releases/redis-5.0.5.tar.gz
2.编译安装程序 tar -xzf redis-5.0.5.tar.gz cd redis-5.0.5 make make make install
3.使用源码包utils里的install_server.sh快速配置redis server分布如下： 192.168.1.2 6379 192.168.1.6 6379 6380 6381 6382 192.168.1.7 6379 6380 6381  4.修改生成的配置文件，开启redis集群功能 cluster-enabled yes cluster-config-file nodes.conf cluster-node-timeout 5000 5.通过redis-server /etc/redis/***.conf启动server
6.通过ps -ef | grep redis-server 确认server启动
7.通过redis-cli 连接相应的节点，执行info命令，确保节点可访问，并开启了集群功能
8.通过redis-cli &amp;ndash;cluster 工具初始化集群 redis-cli --cluster create 192.168.1.2:6379 192.168.1.6:6379 192.168.1.6:6380 192.168.1.6:6381 192.168.1.6:6382 192.168.1.7:6379 192.168.1.7:6380 192.168.1.7:6381 --cluster-replicas 1 工具会提示如下信息，主要是用来显示集群的Slot是如何分配，以及复制关系 &amp;gt;&amp;gt;&amp;gt; Performing hash slots allocation on 8 nodes.</description>
    </item>
    
    <item>
      <title>metrics领域的SLF4J(Micrometer)</title>
      <link>https://bgzxz.github.io/posts/micrometer/</link>
      <pubDate>Thu, 02 May 2019 22:31:34 +0800</pubDate>
      <author>bgzxz1987@email.com (bgzxz)</author>
      <guid>https://bgzxz.github.io/posts/micrometer/</guid>
      <description>Micrometer是什么？ 供应商中立的应用程序指标facade库
Micrometer为用于最流行的监控系统的仪表客户端提供了一个简单的facade，允许您在没有供应商锁定的情况下检测基于JVM的应用程序代码。可以理解为metrics领域的SLF4J。
Micrometer实现了哪些功能？  多维度的Metrics
timers, gauges, counters, distribution summaries, and long task timers
 预配置的绑定
Out-of-the-box instrumentation of caches, the class loader, garbage collection, processor utilization, thread pools, and more tailored to actionable insight
 spring集成
Starting with Spring Boot 2.0, Micrometer is the instrumentation library powering the delivery of application metrics from Spring. Support is ported back to Boot 1.x through an additional library dependency
 支持各种流行的监控系统</description>
    </item>
    
    <item>
      <title>实现应用程序可观察性的3种方式</title>
      <link>https://bgzxz.github.io/posts/observability_3_ways/</link>
      <pubDate>Wed, 01 May 2019 22:31:34 +0800</pubDate>
      <author>bgzxz1987@email.com (bgzxz)</author>
      <guid>https://bgzxz.github.io/posts/observability_3_ways/</guid>
      <description> 项目上线报错了，
线上功能报错了，
用户投诉页面卡顿了，
系统故障导致业务数据异常了 。。。
作为程序员，在日常的工作中总是要面对如上的哪些问题。只有更多的了解系统的内部状态信息，才能更快更精确的定位和解决这些问题。那么如何让系统提供更多的有用信息了。
提升系统的可观测性可以从以下三个方法中获取：
 Logging - 纪录事件
 Metrics － 纪录指标数据事件
 Tracing － 纪录系统之间的因果关系事件
  参考资料 </description>
    </item>
    
    <item>
      <title>使用jmh进行基准测试</title>
      <link>https://bgzxz.github.io/posts/java_benchmark/</link>
      <pubDate>Sat, 09 Mar 2019 14:11:54 +0800</pubDate>
      <author>bgzxz1987@email.com (bgzxz)</author>
      <guid>https://bgzxz.github.io/posts/java_benchmark/</guid>
      <description>什么是基准测试 基准测试是指通过设计科学的测试方法、测试工具和测试系统，实现对一类测试对象的某项性能指标进行定量的和可对比的测试。
java基准测试工具jmh 官方介绍
JMH is a Java harness for building, running, and analysing nano/micro/milli/macro benchmarks written in Java and other languages targetting the JVM.
使用官网mvn骨架工程创建项目 命令行方式
mvn archetype:generate -DinteractiveMode=false -DarchetypeGroupId=org.openjdk.jmh -DarchetypeArtifactId=jmh-java-benchmark-archetype -DarchetypeVersion=1.21 -DgroupId=io.docbot -DartifactId=jmh-example -Dversion=1.0-SNAPSHOT -DarchetypeCatalog=https://maven.aliyun.com/repository/public/archetype-catalog.xml idea方式
idea新建maven项目并添加骨架类型
填写必要的项目信息 第一个例子 package io.docbot; import org.openjdk.jmh.annotations.Benchmark; import org.openjdk.jmh.annotations.BenchmarkMode; import org.openjdk.jmh.annotations.Mode; import org.openjdk.jmh.annotations.OutputTimeUnit; import org.openjdk.jmh.runner.Runner; import org.openjdk.jmh.runner.RunnerException; import org.openjdk.jmh.runner.options.Options; import org.openjdk.jmh.runner.options.OptionsBuilder; import java.util.concurrent.TimeUnit; public class MyBenchmark { @Benchmark @BenchmarkMode(Mode.AverageTime) @OutputTimeUnit(TimeUnit.MILLISECONDS) public void testMethod() { try { Thread.</description>
    </item>
    
    <item>
      <title>java注解处理器</title>
      <link>https://bgzxz.github.io/posts/annotation-processing/</link>
      <pubDate>Sun, 11 Mar 2018 22:11:54 +0800</pubDate>
      <author>bgzxz1987@email.com (bgzxz)</author>
      <guid>https://bgzxz.github.io/posts/annotation-processing/</guid>
      <description>最近发现周围的一些小伙伴开始像下面这样写DTO了
import lombok.AccessLevel; import lombok.Setter; import lombok.Data; import lombok.ToString; @Data public class ExampleDTO { private final String name; @Setter(AccessLevel.PACKAGE) private int age; private double score; private String[] tags; @ToString(includeFieldNames=true) @Data(staticConstructor=&amp;#34;of&amp;#34;) public static class Exercise&amp;lt;T&amp;gt; { private final String name; private final T value; } } 顺着引用的包路径找到lombok这个包，看了下官网的介绍
Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java. Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.</description>
    </item>
    
    <item>
      <title>Full Stack</title>
      <link>https://bgzxz.github.io/posts/full_stack/</link>
      <pubDate>Mon, 05 Feb 2018 17:34:52 +0800</pubDate>
      <author>bgzxz1987@email.com (bgzxz)</author>
      <guid>https://bgzxz.github.io/posts/full_stack/</guid>
      <description>facebook the-full-stack-part阅读心得
1,全栈工程师是个通才，能理解软件系统的不同层的行为
2,通过应用的行为就能想得到软件栈的行为
3,对系统的数据形成和数据流有深刻的认识，从而能更好的设计和优化系统
一些有用的理解数据形成和数据流的因素:
 Working data size Average request size Request rate Mutation rate Consistency Locality Computation Latency Contention  </description>
    </item>
    
    <item>
      <title>每个软件工程师都应该知道的延迟数据</title>
      <link>https://bgzxz.github.io/posts/numbers_everyone_should_know/</link>
      <pubDate>Thu, 01 Feb 2018 16:16:05 +0800</pubDate>
      <author>bgzxz1987@email.com (bgzxz)</author>
      <guid>https://bgzxz.github.io/posts/numbers_everyone_should_know/</guid>
      <description>图片来源于Jeff Dean大神的分享</description>
    </item>
    
    <item>
      <title>语义化版本</title>
      <link>https://bgzxz.github.io/posts/semantic_versioning/</link>
      <pubDate>Wed, 03 Jan 2018 08:31:34 +0800</pubDate>
      <author>bgzxz1987@email.com (bgzxz)</author>
      <guid>https://bgzxz.github.io/posts/semantic_versioning/</guid>
      <description>版本格式：主版本号.次版本号.修订号，版本号递增规则如下：
1.主版本号：当你做了不兼容的 API 修改
2.次版本号：当你做了向下兼容的功能性新增
3.修订号：当你做了向下兼容的问题修正
先行版本号及版本编译元数据可以加到“主版本号.次版本号.修订号”的后面，作为延伸。
作为一位负责任的开发者，你理当确保每次包升级的运作与版本号的表述一致。现实世界是复杂的，我们除了提高警觉外能做的不多。你所能做的就是让语义化的版本控制为你提供一个健全的方式来发行以及升级包，而无需推出新的依赖包，节省你的时间及烦恼。
更多细节见官网</description>
    </item>
    
    <item>
      <title>使用hugo和github搭建个人blog</title>
      <link>https://bgzxz.github.io/posts/build_blog_use_hugo_and_github/</link>
      <pubDate>Mon, 01 Jan 2018 14:11:54 +0800</pubDate>
      <author>bgzxz1987@email.com (bgzxz)</author>
      <guid>https://bgzxz.github.io/posts/build_blog_use_hugo_and_github/</guid>
      <description>hugo简介 golang实现的高性能静态站点生辰工具
更多细节见官方网站
安装hugo Homebrew (macOS)
brew install hugo 源码安装 git clone https://github.com/gohugoio/hugo.git cd hugo go install --tags extended
更多安装方式见官方文档
验证安装 执行hugo version,显示版本号表示安装成功
创建一个site hugo new site quickstart 添加主题 cd quickstart; git init; git submodule add https://github.com/aos/temple.git themes/temple; # Edit your config.toml configuration file # and add the temple theme. echo &amp;#39;theme = &amp;#34;temple&amp;#34;&amp;#39; &amp;gt;&amp;gt; config.toml 添加文章 hugo new posts/my-first-post.md 启动本地服务并验证页面 hugo server -D Start Hugo dev server... | EN +------------------+----+ Pages | 11 Paginator pages | 0 Non-page files | 0 Static files | 1 Processed images | 0 Aliases | 0 Sitemaps | 1 Cleaned | 0 Total in 26 ms Watching for changes in /Users/bgxzx/my-site/blog/{content,data,layouts,static,themes} Watching for config changes in /Users/bgxzx/my-site/blog/config.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://bgzxz.github.io/about/</link>
      <pubDate>Sun, 31 Dec 2017 11:18:03 +0800</pubDate>
      <author>bgzxz1987@email.com (bgzxz)</author>
      <guid>https://bgzxz.github.io/about/</guid>
      <description>后端程序猿
喜欢阅读技术书籍和文章</description>
    </item>
    
    <item>
      <title>My First Post</title>
      <link>https://bgzxz.github.io/posts/my-first-post/</link>
      <pubDate>Sat, 30 Dec 2017 23:31:34 +0800</pubDate>
      <author>bgzxz1987@email.com (bgzxz)</author>
      <guid>https://bgzxz.github.io/posts/my-first-post/</guid>
      <description>Hello Hugo!</description>
    </item>
    
  </channel>
</rss>